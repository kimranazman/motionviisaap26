---
phase: 27-conversion-visibility-archive
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/app/api/deals/route.ts
  - src/app/api/deals/[id]/route.ts
  - src/app/api/potential-projects/route.ts
  - src/app/api/potential-projects/[id]/route.ts
  - src/app/api/projects/route.ts
  - src/app/api/projects/[id]/route.ts
autonomous: true
must_haves:
  truths:
    - "Deal, PotentialProject, and Project models have isArchived field"
    - "API routes return project relation for deals and potentials"
    - "API routes support filtering by isArchived query param"
    - "API routes support PATCH with isArchived field"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "isArchived field on Deal, PotentialProject, Project"
      contains: "isArchived"
    - path: "src/app/api/deals/route.ts"
      provides: "GET with project include and archive filter"
      exports: ["GET", "POST"]
    - path: "src/app/api/deals/[id]/route.ts"
      provides: "PATCH with isArchived support and project include"
      exports: ["GET", "PATCH", "DELETE"]
  key_links:
    - from: "prisma/schema.prisma"
      to: "API routes"
      via: "prisma.deal.findMany include project"
      pattern: "include.*project"
---

<objective>
Add isArchived field to schema and update API routes to include project relations and support archive filtering.

Purpose: Foundation for conversion visibility (requires project data) and archive system (requires isArchived field).
Output: Updated schema with isArchived, API routes returning project relations and supporting archive filter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-conversion-visibility-archive/27-RESEARCH.md
@prisma/schema.prisma
@src/app/api/deals/route.ts
@src/app/api/deals/[id]/route.ts
@src/app/api/potential-projects/route.ts
@src/app/api/potential-projects/[id]/route.ts
@src/app/api/projects/route.ts
@src/app/api/projects/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isArchived field to schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add isArchived Boolean field to Deal, PotentialProject, and Project models:

For Deal model (after position field):
```prisma
isArchived     Boolean   @default(false) @map("is_archived")

@@index([isArchived])
```

For PotentialProject model (after position field):
```prisma
isArchived     Boolean   @default(false) @map("is_archived")

@@index([isArchived])
```

For Project model (after endDate field):
```prisma
isArchived     Boolean   @default(false) @map("is_archived")

@@index([isArchived])
```

Run `npx prisma db push` to apply migration.
  </action>
  <verify>
Run `npx prisma db push` - should complete without errors.
Run `npx prisma studio` - verify isArchived column exists on all three tables.
  </verify>
  <done>Schema has isArchived on Deal, PotentialProject, Project. Database migration applied.</done>
</task>

<task type="auto">
  <name>Task 2: Update deals API routes</name>
  <files>src/app/api/deals/route.ts, src/app/api/deals/[id]/route.ts</files>
  <action>
Update GET /api/deals to:
1. Accept optional `showArchived` query param
2. Filter by isArchived when showArchived !== 'true'
3. Include project relation in response

```typescript
// In route.ts GET
export async function GET(request: NextRequest) {
  const { error } = await requireAuth()
  if (error) return error

  try {
    const { searchParams } = new URL(request.url)
    const showArchived = searchParams.get('showArchived') === 'true'

    const deals = await prisma.deal.findMany({
      where: {
        ...(showArchived ? {} : { isArchived: false }),
      },
      include: {
        company: { select: { id: true, name: true } },
        contact: { select: { id: true, name: true } },
        project: {
          select: {
            id: true,
            title: true,
            revenue: true,
            potentialRevenue: true,
          },
        },
      },
      orderBy: [{ stage: 'asc' }, { position: 'asc' }],
    })

    // Serialize Decimal fields
    const serialized = deals.map(deal => ({
      ...deal,
      value: deal.value ? Number(deal.value) : null,
      project: deal.project ? {
        ...deal.project,
        revenue: deal.project.revenue ? Number(deal.project.revenue) : null,
        potentialRevenue: deal.project.potentialRevenue ? Number(deal.project.potentialRevenue) : null,
      } : null,
    }))

    return NextResponse.json(serialized)
  } catch (error) {
    console.error('Error fetching deals:', error)
    return NextResponse.json({ error: 'Failed to fetch deals' }, { status: 500 })
  }
}
```

Update POST /api/deals to include project in response (for consistency).

Update GET /api/deals/[id] to include project relation.

Update PATCH /api/deals/[id] to:
1. Accept isArchived in body
2. Include project in response

```typescript
// Add to PATCH data object
...(body.isArchived !== undefined && { isArchived: body.isArchived }),
```
  </action>
  <verify>
`curl http://localhost:3000/api/deals` - returns deals with project field (null for unconverted, object for converted).
`curl http://localhost:3000/api/deals?showArchived=true` - returns all deals including archived.
  </verify>
  <done>Deals API returns project relation, supports archive filter, supports PATCH isArchived.</done>
</task>

<task type="auto">
  <name>Task 3: Update potential-projects and projects API routes</name>
  <files>src/app/api/potential-projects/route.ts, src/app/api/potential-projects/[id]/route.ts, src/app/api/projects/route.ts, src/app/api/projects/[id]/route.ts</files>
  <action>
Apply same pattern to potential-projects:

1. GET /api/potential-projects: Add showArchived filter, include project relation
2. GET /api/potential-projects/[id]: Include project relation
3. PATCH /api/potential-projects/[id]: Accept isArchived, include project

For projects:

1. GET /api/projects/route.ts: Add showArchived filter (if route exists, otherwise check page.tsx)
2. PATCH /api/projects/[id]: Accept isArchived

Note: Projects API may fetch directly in page.tsx. Check and update accordingly.

For potential-projects include:
```typescript
project: {
  select: {
    id: true,
    title: true,
    revenue: true,
    potentialRevenue: true,
  },
},
```

Serialize Decimal fields (estimatedValue, project.revenue, project.potentialRevenue).
  </action>
  <verify>
`curl http://localhost:3000/api/potential-projects` - returns projects with project field.
Visit /projects page - projects still load correctly with archive filter available.
  </verify>
  <done>All API routes include project relation and support archive filtering.</done>
</task>

</tasks>

<verification>
1. Schema: `npx prisma db push` succeeds, `npx prisma studio` shows isArchived columns
2. Deals API: Returns project data, filters archived by default
3. Potentials API: Returns project data, filters archived by default
4. Projects API: Filters archived by default
5. All PATCH endpoints accept isArchived field
</verification>

<success_criteria>
- [ ] isArchived field exists on Deal, PotentialProject, Project models
- [ ] Database migration applied successfully
- [ ] GET /api/deals includes project relation and archive filter
- [ ] GET /api/potential-projects includes project relation and archive filter
- [ ] PATCH endpoints accept isArchived field
- [ ] No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/27-conversion-visibility-archive/27-01-SUMMARY.md`
</output>
