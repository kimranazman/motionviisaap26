---
phase: 21-infrastructure-schema
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/app/api/files/[projectId]/[filename]/route.ts
  - src/types/dashboard.ts
  - src/lib/file-utils.ts
autonomous: true

must_haves:
  truths:
    - "Prisma schema includes Document model with projectId, filename, storagePath, category"
    - "Prisma schema includes UserPreferences model with dashboardLayout JSON field"
    - "Prisma schema includes AdminDefaults model with dashboardLayout and widgetRoles JSON fields"
    - "Authenticated API route serves files from /uploads/ directory"
    - "Unauthenticated requests to file API return 401"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Document, UserPreferences, AdminDefaults models"
      contains: "model Document"
    - path: "src/app/api/files/[projectId]/[filename]/route.ts"
      provides: "Authenticated file serving endpoint"
      exports: ["GET"]
    - path: "src/types/dashboard.ts"
      provides: "TypeScript types for dashboard JSON fields"
      exports: ["WidgetConfig", "DashboardLayout", "DateFilter"]
    - path: "src/lib/file-utils.ts"
      provides: "File streaming utilities"
      exports: ["streamFile"]
  key_links:
    - from: "src/app/api/files/[projectId]/[filename]/route.ts"
      to: "@/lib/auth-utils"
      via: "requireAuth import"
      pattern: "import.*requireAuth.*auth-utils"
    - from: "src/app/api/files/[projectId]/[filename]/route.ts"
      to: "src/lib/file-utils.ts"
      via: "streamFile import"
      pattern: "import.*streamFile.*file-utils"
    - from: "prisma/schema.prisma"
      to: "User model"
      via: "UserPreferences.userId relation"
      pattern: "user.*User.*@relation"
---

<objective>
Create Prisma schema models for documents and dashboard preferences, plus authenticated file serving API.

Purpose: Establish data layer foundation for document management (Phase 22) and dashboard customization (Phases 23-24). The file serving route provides secure access to uploaded documents.

Output: Updated Prisma schema with Document/UserPreferences/AdminDefaults models, file serving API route, TypeScript types for JSON fields, file streaming utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-infrastructure-schema/21-RESEARCH.md
@prisma/schema.prisma
@src/lib/auth-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Prisma schema models</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the following to prisma/schema.prisma:

1. DocumentCategory enum (after existing enums):
```prisma
enum DocumentCategory {
  RECEIPT
  INVOICE
  OTHER
}
```

2. Document model (relates to Project and User):
```prisma
model Document {
  id            String           @id @default(cuid())
  projectId     String           @map("project_id")
  project       Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)

  filename      String           @db.VarChar(255)  // Original filename for display
  storagePath   String           @db.VarChar(500)  // Relative path: projects/{id}/{uuid}.ext
  mimeType      String           @db.VarChar(100)
  size          Int              // File size in bytes
  category      DocumentCategory @default(OTHER)

  uploadedById  String           @map("uploaded_by_id")
  uploadedBy    User             @relation(fields: [uploadedById], references: [id])

  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@index([projectId])
  @@index([category])
  @@map("documents")
}
```

3. UserPreferences model (one-to-one with User):
```prisma
model UserPreferences {
  id              String   @id @default(cuid())
  userId          String   @unique @map("user_id")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  dashboardLayout Json?    @db.Json
  dateFilter      Json?    @db.Json

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("user_preferences")
}
```

4. AdminDefaults model (singleton for system-wide defaults):
```prisma
model AdminDefaults {
  id              String   @id @default(cuid())

  dashboardLayout Json     @db.Json
  widgetRoles     Json     @db.Json

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("admin_defaults")
}
```

5. Update User model - add relations:
```prisma
documents     Document[]
preferences   UserPreferences?
```

6. Update Project model - add documents relation:
```prisma
documents     Document[]
```
  </action>
  <verify>
1. Run `npx prisma validate` - should pass without errors
2. Run `npx prisma generate` - should generate client successfully
3. Run `npx prisma db push` - should apply schema to database
  </verify>
  <done>
- DocumentCategory enum exists
- Document model with all fields and relations
- UserPreferences model with JSON fields
- AdminDefaults model with JSON fields
- User has documents and preferences relations
- Project has documents relation
- Schema validates and migrations apply
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types and file utilities</name>
  <files>src/types/dashboard.ts, src/lib/file-utils.ts</files>
  <action>
1. Create src/types/dashboard.ts with TypeScript interfaces for JSON fields:
```typescript
/**
 * Dashboard customization types
 * Used for typing Prisma JSON fields in UserPreferences and AdminDefaults
 */

export interface WidgetConfig {
  id: string;       // Widget type identifier (e.g., 'revenue', 'pipeline')
  x: number;        // Grid position X
  y: number;        // Grid position Y
  w: number;        // Width in grid units
  h: number;        // Height in grid units
}

export interface DashboardLayout {
  widgets: WidgetConfig[];
}

export interface DateFilter {
  startDate: string | null;  // ISO date string
  endDate: string | null;    // ISO date string
  preset?: 'thisMonth' | 'lastMonth' | 'thisQuarter' | 'thisYear' | 'custom';
}

export interface WidgetRoleRestrictions {
  [widgetId: string]: string[];  // widgetId -> array of allowed role names
}
```

2. Create src/lib/file-utils.ts with streaming utilities:
```typescript
import fs from 'fs';

/**
 * Convert Node.js ReadStream to async generator
 */
async function* nodeStreamToIterator(stream: fs.ReadStream): AsyncGenerator<Uint8Array> {
  for await (const chunk of stream) {
    yield new Uint8Array(chunk as Buffer);
  }
}

/**
 * Convert async iterator to Web ReadableStream
 */
function iteratorToStream(iterator: AsyncGenerator<Uint8Array>): ReadableStream<Uint8Array> {
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await iterator.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
  });
}

/**
 * Stream a file from filesystem as Web ReadableStream
 * Memory efficient - doesn't load entire file into memory
 */
export function streamFile(filePath: string): ReadableStream<Uint8Array> {
  const nodeStream = fs.createReadStream(filePath);
  return iteratorToStream(nodeStreamToIterator(nodeStream));
}

/**
 * Content type mapping for allowed file extensions
 */
export const CONTENT_TYPES: Record<string, string> = {
  '.pdf': 'application/pdf',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
};

/**
 * Get content type from filename extension
 */
export function getContentType(filename: string): string {
  const ext = filename.toLowerCase().slice(filename.lastIndexOf('.'));
  return CONTENT_TYPES[ext] || 'application/octet-stream';
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` or check TypeScript compiles without errors
2. Confirm files exist: `ls src/types/dashboard.ts src/lib/file-utils.ts`
  </verify>
  <done>
- src/types/dashboard.ts exports WidgetConfig, DashboardLayout, DateFilter, WidgetRoleRestrictions
- src/lib/file-utils.ts exports streamFile, getContentType, CONTENT_TYPES
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create authenticated file serving API route</name>
  <files>src/app/api/files/[projectId]/[filename]/route.ts</files>
  <action>
Create src/app/api/files/[projectId]/[filename]/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { requireAuth } from '@/lib/auth-utils';
import { streamFile, getContentType } from '@/lib/file-utils';
import fsPromises from 'fs/promises';
import path from 'path';

const UPLOADS_DIR = process.env.UPLOADS_DIR || '/app/uploads';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ projectId: string; filename: string }> }
) {
  // Require authentication
  const { error } = await requireAuth();
  if (error) return error;

  const { projectId, filename } = await params;

  // SECURITY: Validate path components to prevent directory traversal
  if (projectId.includes('..') || filename.includes('..') ||
      projectId.includes('/') || filename.includes('/')) {
    return NextResponse.json({ error: 'Invalid path' }, { status: 400 });
  }

  const filePath = path.join(UPLOADS_DIR, 'projects', projectId, filename);

  try {
    // Check file exists and get stats
    const stats = await fsPromises.stat(filePath);

    // Stream the file
    const stream = streamFile(filePath);
    const contentType = getContentType(filename);

    return new Response(stream, {
      status: 200,
      headers: {
        'Content-Disposition': `inline; filename="${filename}"`,
        'Content-Type': contentType,
        'Content-Length': stats.size.toString(),
        'Cache-Control': 'private, max-age=3600',
      },
    });
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {
      return NextResponse.json({ error: 'File not found' }, { status: 404 });
    }
    console.error('[FILES API] Error serving file:', err);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

Key points:
- Uses requireAuth() from existing auth-utils (returns 401 if not authenticated)
- Validates path params to prevent directory traversal attacks
- Streams file instead of loading into memory
- Returns proper Content-Type based on file extension
- params is a Promise in Next.js 15 - must await it
  </action>
  <verify>
1. Run `npm run build` - should compile without errors
2. File exists: `ls src/app/api/files/\[projectId\]/\[filename\]/route.ts`
  </verify>
  <done>
- File serving route exists at /api/files/[projectId]/[filename]
- Route requires authentication (returns 401 if not logged in)
- Route validates path params (returns 400 for invalid paths)
- Route streams files with proper Content-Type headers
- Build succeeds
  </done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes
2. `npx prisma generate` succeeds
3. `npx prisma db push` applies schema to database
4. `npm run build` succeeds
5. Document, UserPreferences, AdminDefaults models exist in schema
6. File serving route at /api/files/[projectId]/[filename] compiles
7. TypeScript types exported from src/types/dashboard.ts
</verification>

<success_criteria>
- Prisma schema includes all required models with proper relations
- Database schema updated via prisma db push
- File serving API route exists and requires authentication
- TypeScript types defined for dashboard JSON fields
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/21-infrastructure-schema/21-02-SUMMARY.md`
</output>
