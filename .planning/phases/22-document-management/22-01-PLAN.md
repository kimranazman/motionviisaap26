---
phase: 22-document-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/app/api/projects/[id]/documents/route.ts
  - src/app/api/projects/[id]/documents/[documentId]/route.ts
  - src/app/api/projects/[id]/route.ts
  - src/lib/document-utils.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/projects/{id}/documents accepts file upload and returns document record"
    - "GET /api/projects/{id}/documents returns list of documents for project"
    - "DELETE /api/projects/{id}/documents/{documentId} removes document and file"
    - "PATCH /api/projects/{id}/documents/{documentId} updates document category"
    - "Project model includes startDate and endDate fields"
    - "PATCH /api/projects/{id} can update startDate and endDate"
  artifacts:
    - path: "src/app/api/projects/[id]/documents/route.ts"
      provides: "Document upload (POST) and list (GET) endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/projects/[id]/documents/[documentId]/route.ts"
      provides: "Document delete (DELETE) and category update (PATCH) endpoints"
      exports: ["DELETE", "PATCH"]
    - path: "src/lib/document-utils.ts"
      provides: "Document utility functions for category colors, file size formatting"
      exports: ["getCategoryColor", "formatFileSize", "isPreviewable", "DOCUMENT_CATEGORIES"]
    - path: "prisma/schema.prisma"
      provides: "Project model with startDate, endDate fields"
      contains: "startDate"
  key_links:
    - from: "src/app/api/projects/[id]/documents/route.ts"
      to: "prisma.document"
      via: "database query"
      pattern: "prisma\\.document\\.(create|findMany)"
    - from: "src/app/api/projects/[id]/documents/route.ts"
      to: "/app/uploads/projects/{id}/"
      via: "fs.writeFile"
      pattern: "writeFile"
---

<objective>
Create document management API routes and schema updates for project dates

Purpose: Establish the backend foundation for document upload, listing, deletion, and category management, plus project date fields
Output: Working API endpoints for document CRUD operations and updated Project model with date fields
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-document-management/22-RESEARCH.md

# Phase 21 infrastructure (Document model, file serving API)
@.planning/phases/21-infrastructure-schema/21-02-SUMMARY.md

# Existing patterns
@src/app/api/projects/[id]/costs/route.ts
@src/app/api/projects/[id]/costs/[costId]/route.ts
@src/lib/cost-utils.ts
@src/lib/file-utils.ts
@src/app/api/files/[projectId]/[filename]/route.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add project date fields to schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add startDate and endDate fields to the Project model in schema.prisma:

1. Add to Project model (after `status` field):
```prisma
  startDate       DateTime?       @map("start_date")
  endDate         DateTime?       @map("end_date")
```

2. Run `npx prisma db push` to apply schema changes

Note: Both fields are optional (nullable) since projects may not have dates set initially.
  </action>
  <verify>
Run `npx prisma db push` - should succeed with no errors
Run `npx prisma generate` - should generate client types
  </verify>
  <done>Project model includes startDate and endDate fields, Prisma client regenerated</done>
</task>

<task type="auto">
  <name>Task 2: Create document utility functions</name>
  <files>src/lib/document-utils.ts</files>
  <action>
Create document utility functions following the cost-utils.ts pattern:

```typescript
// src/lib/document-utils.ts

// Document category colors for badges (matching cost-utils pattern)
export function getCategoryColor(category: string): string {
  const colors: Record<string, string> = {
    RECEIPT: 'bg-green-100 text-green-700 border-green-200',
    INVOICE: 'bg-blue-100 text-blue-700 border-blue-200',
    OTHER: 'bg-gray-100 text-gray-700 border-gray-200',
  }
  return colors[category] || colors.OTHER
}

// Format file size for display
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`
}

// Check if file is previewable inline (images only)
export function isPreviewable(mimeType: string): boolean {
  return mimeType.startsWith('image/')
}

// Document category options for selects
export const DOCUMENT_CATEGORIES = [
  { value: 'RECEIPT', label: 'Receipt' },
  { value: 'INVOICE', label: 'Invoice' },
  { value: 'OTHER', label: 'Other' },
] as const

export type DocumentCategory = (typeof DOCUMENT_CATEGORIES)[number]['value']

// Allowed MIME types for uploads
export const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'image/png',
  'image/jpeg',
]

// Maximum file size in bytes (10MB)
export const MAX_FILE_SIZE = 10 * 1024 * 1024
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass without type errors
  </verify>
  <done>Document utility functions created with category colors, file size formatting, and constants</done>
</task>

<task type="auto">
  <name>Task 3: Create document API routes</name>
  <files>
src/app/api/projects/[id]/documents/route.ts
src/app/api/projects/[id]/documents/[documentId]/route.ts
src/app/api/projects/[id]/route.ts
  </files>
  <action>
Create document CRUD API routes following the costs route patterns.

**1. Create `src/app/api/projects/[id]/documents/route.ts`:**

```typescript
import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { requireAuth, requireEditor } from '@/lib/auth-utils'
import { writeFile, mkdir, unlink } from 'fs/promises'
import path from 'path'
import { randomUUID } from 'crypto'
import { ALLOWED_MIME_TYPES, MAX_FILE_SIZE } from '@/lib/document-utils'

const UPLOADS_DIR = process.env.UPLOADS_DIR || '/app/uploads'

// GET /api/projects/[id]/documents - List documents for project
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { error } = await requireAuth()
  if (error) return error

  try {
    const { id } = await params

    // Verify project exists
    const project = await prisma.project.findUnique({
      where: { id },
      select: { id: true },
    })

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      )
    }

    const documents = await prisma.document.findMany({
      where: { projectId: id },
      include: {
        uploadedBy: { select: { id: true, name: true } },
      },
      orderBy: { createdAt: 'desc' },
    })

    return NextResponse.json(documents)
  } catch (error) {
    console.error('Error fetching documents:', error)
    return NextResponse.json(
      { error: 'Failed to fetch documents' },
      { status: 500 }
    )
  }
}

// POST /api/projects/[id]/documents - Upload document
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { session, error } = await requireEditor()
  if (error) return error

  try {
    const { id: projectId } = await params
    const formData = await request.formData()
    const file = formData.get('file') as File | null
    const category = (formData.get('category') as string) || 'OTHER'

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 })
    }

    // Validate MIME type
    if (!ALLOWED_MIME_TYPES.includes(file.type)) {
      return NextResponse.json(
        { error: 'Invalid file type. Allowed: PDF, PNG, JPG' },
        { status: 400 }
      )
    }

    // Validate file size
    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { error: 'File too large. Maximum: 10MB' },
        { status: 400 }
      )
    }

    // Verify project exists
    const project = await prisma.project.findUnique({ where: { id: projectId } })
    if (!project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }

    // Create unique storage filename (UUID + original extension)
    const ext = path.extname(file.name)
    const uniqueName = `${randomUUID()}${ext}`
    const relativePath = `projects/${projectId}/${uniqueName}`
    const fullPath = path.join(UPLOADS_DIR, relativePath)

    // Ensure directory exists
    await mkdir(path.dirname(fullPath), { recursive: true })

    // Write file to disk
    const bytes = await file.arrayBuffer()
    await writeFile(fullPath, Buffer.from(bytes))

    try {
      // Create database record
      const document = await prisma.document.create({
        data: {
          projectId,
          filename: file.name, // Original filename for display
          storagePath: relativePath,
          mimeType: file.type,
          size: file.size,
          category: category as 'RECEIPT' | 'INVOICE' | 'OTHER',
          uploadedById: session.user.id,
        },
        include: {
          uploadedBy: { select: { id: true, name: true } },
        },
      })

      return NextResponse.json(document, { status: 201 })
    } catch (dbError) {
      // Cleanup file if DB write failed
      try {
        await unlink(fullPath)
      } catch {}
      throw dbError
    }
  } catch (error) {
    console.error('Error uploading document:', error)
    return NextResponse.json(
      { error: 'Failed to upload document' },
      { status: 500 }
    )
  }
}
```

**2. Create `src/app/api/projects/[id]/documents/[documentId]/route.ts`:**

```typescript
import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { requireEditor } from '@/lib/auth-utils'
import { unlink } from 'fs/promises'
import path from 'path'

const UPLOADS_DIR = process.env.UPLOADS_DIR || '/app/uploads'

// DELETE /api/projects/[id]/documents/[documentId] - Delete document
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; documentId: string }> }
) {
  const { error } = await requireEditor()
  if (error) return error

  try {
    const { id: projectId, documentId } = await params

    // Find document
    const document = await prisma.document.findFirst({
      where: { id: documentId, projectId },
    })

    if (!document) {
      return NextResponse.json(
        { error: 'Document not found' },
        { status: 404 }
      )
    }

    // Delete file from filesystem
    const fullPath = path.join(UPLOADS_DIR, document.storagePath)
    try {
      await unlink(fullPath)
    } catch (fsError) {
      console.error('Failed to delete file:', fsError)
      // Continue with DB deletion even if file deletion fails
    }

    // Delete database record
    await prisma.document.delete({ where: { id: documentId } })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting document:', error)
    return NextResponse.json(
      { error: 'Failed to delete document' },
      { status: 500 }
    )
  }
}

// PATCH /api/projects/[id]/documents/[documentId] - Update document category
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; documentId: string }> }
) {
  const { error } = await requireEditor()
  if (error) return error

  try {
    const { id: projectId, documentId } = await params
    const body = await request.json()

    // Validate category
    const validCategories = ['RECEIPT', 'INVOICE', 'OTHER']
    if (body.category && !validCategories.includes(body.category)) {
      return NextResponse.json(
        { error: 'Invalid category' },
        { status: 400 }
      )
    }

    // Verify document exists and belongs to project
    const existing = await prisma.document.findFirst({
      where: { id: documentId, projectId },
    })

    if (!existing) {
      return NextResponse.json(
        { error: 'Document not found' },
        { status: 404 }
      )
    }

    // Update document
    const document = await prisma.document.update({
      where: { id: documentId },
      data: {
        category: body.category as 'RECEIPT' | 'INVOICE' | 'OTHER',
      },
      include: {
        uploadedBy: { select: { id: true, name: true } },
      },
    })

    return NextResponse.json(document)
  } catch (error) {
    console.error('Error updating document:', error)
    return NextResponse.json(
      { error: 'Failed to update document' },
      { status: 500 }
    )
  }
}
```

**3. Update `src/app/api/projects/[id]/route.ts` to handle startDate and endDate:**

Add `startDate` and `endDate` to the PATCH handler body processing. Find the existing PATCH function and update its data object to include:

```typescript
// In the PATCH handler, add to the data object:
startDate: body.startDate ? new Date(body.startDate) : (body.startDate === null ? null : undefined),
endDate: body.endDate ? new Date(body.endDate) : (body.endDate === null ? null : undefined),
```

Also update the GET response to include these fields (they should already be included since Prisma returns all fields).
  </action>
  <verify>
Run `npm run build` - should pass without errors
Test with curl (after dev server running):
- `curl -X GET http://localhost:3000/api/projects/{projectId}/documents` should return []
  </verify>
  <done>
Document API routes created:
- GET /api/projects/{id}/documents returns document list
- POST /api/projects/{id}/documents uploads file and creates record
- DELETE /api/projects/{id}/documents/{documentId} removes document and file
- PATCH /api/projects/{id}/documents/{documentId} updates category
- PATCH /api/projects/{id} accepts startDate and endDate
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes
2. `npx prisma db push` succeeds
3. Document model has relationship to Project via projectId
4. Project model has startDate and endDate fields
5. API routes exist at correct paths
</verification>

<success_criteria>
- Project schema includes startDate and endDate (nullable DateTime)
- Document utility functions exported from src/lib/document-utils.ts
- POST /api/projects/{id}/documents accepts multipart form data with file
- POST validates file type (PDF, PNG, JPG only) and size (max 10MB)
- POST stores file in /uploads/projects/{id}/{uuid}.ext
- GET /api/projects/{id}/documents returns document array
- DELETE removes both database record and file from filesystem
- PATCH updates document category
- Project PATCH accepts startDate and endDate
</success_criteria>

<output>
After completion, create `.planning/phases/22-document-management/22-01-SUMMARY.md`
</output>
