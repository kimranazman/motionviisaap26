---
phase: 29-schema-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
autonomous: true

must_haves:
  truths:
    - "Supplier model exists with name, contact info, and credit terms fields"
    - "Department model exists under Company with cascade delete"
    - "Contact, Deal, and PotentialProject have optional departmentId FK"
    - "Deliverable model exists linked to Project with cascade delete"
    - "Task model exists with self-referencing parent/children for subtasks"
    - "TaskComment and Tag/TaskTag models exist for task features"
    - "ActivityLog model exists with polymorphic entityType/entityId pattern"
    - "Database schema is synchronized and Prisma Client regenerated"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "All v1.4 model definitions"
      contains:
        - "model Supplier"
        - "model Department"
        - "model Deliverable"
        - "model Task"
        - "model TaskComment"
        - "model Tag"
        - "model TaskTag"
        - "model ActivityLog"
        - "enum PaymentTerms"
        - "enum TaskStatus"
        - "enum TaskPriority"
        - "enum ActivityEntityType"
        - "enum ActivityAction"
        - "enum InitiativeDepartment"
  key_links:
    - from: "Department"
      to: "Company"
      via: "companyId FK with onDelete: Cascade"
      pattern: "company\\s+Company\\s+@relation.*onDelete: Cascade"
    - from: "Contact"
      to: "Department"
      via: "optional departmentId FK"
      pattern: "departmentId\\s+String\\?"
    - from: "Task"
      to: "Task"
      via: "self-referencing parent/children relation"
      pattern: "@relation\\(\"TaskSubtasks\""
    - from: "ActivityLog"
      to: "Deal/Potential/Project"
      via: "polymorphic entityType + entityId"
      pattern: "entityType\\s+ActivityEntityType"
---

<objective>
Add all v1.4 database models to Prisma schema: Supplier, Department, Deliverable, Task (with comments/tags), and ActivityLog.

Purpose: Establish the data foundation for supplier tracking, organizational structure, project deliverables, task management, and activity logging features.

Output: Updated prisma/schema.prisma with all new models, relations, and indexes; database synchronized via db:push.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-schema-foundation/29-RESEARCH.md
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add v1.4 enums and models to schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Update prisma/schema.prisma following the exact patterns from 29-RESEARCH.md:

**1. Add new enums (after existing enums section):**

```prisma
// v1.4 Enums
enum PaymentTerms {
  IMMEDIATE
  NET_7
  NET_15
  NET_30
  NET_45
  NET_60
  NET_90
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
}

enum ActivityEntityType {
  DEAL
  POTENTIAL
  PROJECT
}

enum ActivityAction {
  CREATED
  UPDATED
  STAGE_CHANGED
  TITLE_SYNCED
  REVENUE_UPDATED
  STATUS_CHANGED
  CONVERTED
}
```

**2. Rename existing Department enum to InitiativeDepartment:**
- Change `enum Department {` to `enum InitiativeDepartment {`
- Update Initiative model: change `department Department` to `department InitiativeDepartment`

**3. Add Supplier model:**

```prisma
model Supplier {
  id              String        @id @default(cuid())
  name            String        @db.VarChar(255)

  // Contact info
  email           String?       @db.VarChar(255)
  phone           String?       @db.VarChar(50)
  address         String?       @db.Text
  website         String?       @db.VarChar(255)
  contactPerson   String?       @map("contact_person") @db.VarChar(255)

  // Credit terms
  acceptsCredit   Boolean       @default(false) @map("accepts_credit")
  paymentTerms    PaymentTerms? @map("payment_terms")

  notes           String?       @db.Text

  // Relations
  costs           Cost[]

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([name])
  @@map("suppliers")
}
```

**4. Add Department model:**

```prisma
model Department {
  id          String   @id @default(cuid())
  name        String   @db.VarChar(255)
  description String?  @db.Text

  companyId   String   @map("company_id")
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  contacts    Contact[]
  deals       Deal[]
  potentials  PotentialProject[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([companyId, name])
  @@index([companyId])
  @@map("departments")
}
```

**5. Add Deliverable model:**

```prisma
model Deliverable {
  id          String   @id @default(cuid())
  title       String   @db.VarChar(500)
  description String?  @db.Text
  value       Decimal? @db.Decimal(12, 2)
  sortOrder   Int      @default(0) @map("sort_order")

  projectId   String   @map("project_id")
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  aiExtracted Boolean  @default(false) @map("ai_extracted")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([projectId])
  @@map("deliverables")
}
```

**6. Add Task model (with self-reference):**

```prisma
model Task {
  id           String       @id @default(cuid())
  title        String       @db.VarChar(500)
  description  String?      @db.Text

  status       TaskStatus   @default(TODO)
  priority     TaskPriority @default(MEDIUM)
  dueDate      DateTime?    @map("due_date")

  assignee     TeamMember?

  projectId    String       @map("project_id")
  project      Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // Self-referencing for subtasks (up to 5 levels)
  parentId     String?      @map("parent_id")
  parent       Task?        @relation("TaskSubtasks", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children     Task[]       @relation("TaskSubtasks")

  depth        Int          @default(0)
  sortOrder    Int          @default(0)  @map("sort_order")

  comments     TaskComment[]
  tags         TaskTag[]

  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@index([projectId])
  @@index([parentId])
  @@index([status])
  @@index([assignee])
  @@index([dueDate])
  @@map("tasks")
}
```

**7. Add TaskComment model:**

```prisma
model TaskComment {
  id        String   @id @default(cuid())
  content   String   @db.Text

  taskId    String   @map("task_id")
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)

  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([taskId])
  @@index([userId])
  @@map("task_comments")
}
```

**8. Add Tag model:**

```prisma
model Tag {
  id        String    @id @default(cuid())
  name      String    @unique @db.VarChar(50)
  color     String    @default("#6B7280") @db.VarChar(7)

  tasks     TaskTag[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@map("tags")
}
```

**9. Add TaskTag model (join table):**

```prisma
model TaskTag {
  id        String   @id @default(cuid())

  taskId    String   @map("task_id")
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)

  tagId     String   @map("tag_id")
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  inherited Boolean  @default(false)

  createdAt DateTime @default(now())

  @@unique([taskId, tagId])
  @@index([taskId])
  @@index([tagId])
  @@map("task_tags")
}
```

**10. Add ActivityLog model:**

```prisma
model ActivityLog {
  id          String             @id @default(cuid())

  entityType  ActivityEntityType @map("entity_type")
  entityId    String             @map("entity_id")

  action      ActivityAction
  field       String?            @db.VarChar(50)
  oldValue    String?            @map("old_value") @db.Text
  newValue    String?            @map("new_value") @db.Text

  userId      String?            @map("user_id")
  user        User?              @relation(fields: [userId], references: [id])

  createdAt   DateTime           @default(now())

  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([userId])
  @@map("activity_logs")
}
```
  </action>
  <verify>Run `npx prisma validate` - should output "The schema at prisma/schema.prisma is valid"</verify>
  <done>Schema file contains all new enums and models with correct relations and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Update existing models with new relations</name>
  <files>prisma/schema.prisma</files>
  <action>
Modify existing models to add relation fields for v1.4 features:

**1. Update Company model - add departments relation:**
```prisma
// Add after projects   Project[] line:
departments Department[]
```

**2. Update Contact model - add optional department FK:**
```prisma
// Add after role field:
departmentId String?     @map("department_id")
department   Department? @relation(fields: [departmentId], references: [id])

// Add to existing @@index section:
@@index([departmentId])
```

**3. Update Deal model - add optional department FK:**
```prisma
// Add after contact relation:
departmentId String?     @map("department_id")
department   Department? @relation(fields: [departmentId], references: [id])

// Add to existing @@index section:
@@index([departmentId])
```

**4. Update PotentialProject model - add optional department FK:**
```prisma
// Add after contact relation:
departmentId String?     @map("department_id")
department   Department? @relation(fields: [departmentId], references: [id])

// Add to existing @@index section:
@@index([departmentId])
```

**5. Update Project model - add deliverables and tasks relations:**
```prisma
// Add after documents Document[] line:
deliverables Deliverable[]
tasks        Task[]
```

**6. Update Cost model - add optional supplier FK:**
```prisma
// Add after aiImported field:
supplierId String?   @map("supplier_id")
supplier   Supplier? @relation(fields: [supplierId], references: [id])

// Add to existing @@index section:
@@index([supplierId])
```

**7. Update User model - add taskComments and activityLogs relations:**
```prisma
// Add after preferences UserPreferences? line:
taskComments TaskComment[]
activityLogs ActivityLog[]
```
  </action>
  <verify>Run `npx prisma validate` - should output "The schema at prisma/schema.prisma is valid"</verify>
  <done>All existing models updated with new relation fields and indexes</done>
</task>

<task type="auto">
  <name>Task 3: Sync database and regenerate client</name>
  <files>prisma/schema.prisma</files>
  <action>
Run Prisma commands to sync the schema to the database and regenerate the client:

1. Run `npm run db:push` to sync schema to database
   - This creates all new tables: suppliers, departments, deliverables, tasks, task_comments, tags, task_tags, activity_logs
   - This adds new columns to existing tables: costs.supplier_id, contacts.department_id, deals.department_id, potential_projects.department_id
   - This renames the Department enum to InitiativeDepartment in the database

2. Run `npm run db:generate` to regenerate Prisma Client
   - This updates the TypeScript types for all new models
   - This enables the new relations in the Prisma client

Note: If db:push warns about data loss due to enum rename, this is safe since no data exists that uses the old enum in a conflicting way (the Initiative.department field keeps the same values).
  </action>
  <verify>
Run `npx prisma db pull --force` then `npx prisma validate` to verify the database matches the schema.
Run `npm run build` to verify TypeScript compiles with new Prisma types.
  </verify>
  <done>Database schema synchronized, Prisma Client regenerated, TypeScript compiles successfully</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema validation passes: `npx prisma validate` outputs "valid"
2. All new tables exist in database (via db:push success)
3. TypeScript compiles: `npm run build` succeeds
4. New types available in code (can import Supplier, Department, Task, etc. from @prisma/client)

Manual spot checks:
- Supplier model has: name, email, phone, address, website, contactPerson, acceptsCredit, paymentTerms, costs relation
- Department model has: name, description, companyId with Cascade delete, contacts/deals/potentials relations
- Task model has: self-referencing parent/children with "TaskSubtasks" relation name
- ActivityLog has: entityType enum, entityId string (polymorphic pattern)
</verification>

<success_criteria>
- [ ] prisma/schema.prisma contains all 8 new models
- [ ] prisma/schema.prisma contains all 6 new enums (including renamed InitiativeDepartment)
- [ ] Department enum renamed to InitiativeDepartment, Initiative.department updated
- [ ] Cost.supplierId, Contact.departmentId, Deal.departmentId, PotentialProject.departmentId fields added
- [ ] Company.departments, Project.deliverables, Project.tasks, User.taskComments, User.activityLogs relations added
- [ ] `npx prisma validate` passes
- [ ] `npm run db:push` succeeds
- [ ] `npm run build` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/29-schema-foundation/29-01-SUMMARY.md`
</output>
