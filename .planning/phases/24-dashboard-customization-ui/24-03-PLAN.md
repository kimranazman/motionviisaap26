---
phase: 24-dashboard-customization-ui
plan: 03
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/components/dashboard/dashboard-grid.tsx
  - src/components/dashboard/widget-wrapper.tsx
  - src/lib/hooks/use-dashboard-layout.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard displays widgets in grid layout with correct positions"
    - "User can drag widgets to reposition them (when in edit mode)"
    - "User can resize widgets via drag handles (when in edit mode)"
    - "Drag and resize disabled on mobile breakpoints"
    - "Widgets push down when another is dragged over them (vertical compaction)"
  artifacts:
    - path: "src/components/dashboard/dashboard-grid.tsx"
      provides: "Main grid container using react-grid-layout"
      exports: ["DashboardGrid"]
    - path: "src/components/dashboard/widget-wrapper.tsx"
      provides: "Common wrapper for all widgets with resize handles"
      exports: ["WidgetWrapper"]
    - path: "src/lib/hooks/use-dashboard-layout.ts"
      provides: "Layout state management with undo history"
      exports: ["useDashboardLayout"]
  key_links:
    - from: "src/components/dashboard/dashboard-grid.tsx"
      to: "react-grid-layout"
      via: "ResponsiveGridLayout component"
      pattern: "ResponsiveGridLayout"
    - from: "src/lib/hooks/use-dashboard-layout.ts"
      to: "src/lib/widgets/layout-utils.ts"
      via: "addWidgetToLayout, removeWidgetFromLayout"
      pattern: "(addWidgetToLayout|removeWidgetFromLayout)"
---

<objective>
Create dashboard grid component with drag-drop and resize capabilities.

Purpose: Users can visually arrange widgets by dragging and resizing them in a responsive grid layout.
Output: Working dashboard grid with react-grid-layout, responsive breakpoints, and edit mode toggle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-dashboard-customization-ui/24-CONTEXT.md
@.planning/phases/24-dashboard-customization-ui/24-RESEARCH.md
@.planning/phases/24-dashboard-customization-ui/24-01-SUMMARY.md
@src/lib/widgets/layout-utils.ts
@src/lib/widgets/registry.ts
@src/types/dashboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard layout hook with undo</name>
  <files>
    - src/lib/hooks/use-dashboard-layout.ts
  </files>
  <action>
Create src/lib/hooks/use-dashboard-layout.ts:

```typescript
'use client';

import { useState, useCallback } from 'react';
import type { LayoutWidgetConfig } from '@/types/dashboard';
import { addWidgetToLayout, removeWidgetFromLayout } from '@/lib/widgets/layout-utils';
import { WIDGET_REGISTRY } from '@/lib/widgets/registry';
```

Interface:
```typescript
interface LayoutState {
  current: LayoutWidgetConfig[];
  history: LayoutWidgetConfig[][];
  historyIndex: number;
}

interface UseDashboardLayoutReturn {
  layout: LayoutWidgetConfig[];
  updateLayout: (newLayout: LayoutWidgetConfig[]) => void;
  addWidget: (widgetId: string) => void;
  removeWidget: (instanceId: string) => void;
  undo: () => void;
  canUndo: boolean;
  isDirty: boolean;
}
```

Hook implementation:
1. Initialize state with initialLayout prop
2. updateLayout: Add current to history, set new layout, trim history to max 20 entries
3. addWidget: Use addWidgetToLayout with widget's defaultSize from WIDGET_REGISTRY
4. removeWidget: Use removeWidgetFromLayout
5. undo: If historyIndex > 0, decrement and set current to previous history entry
6. canUndo: historyIndex > 0
7. isDirty: Compare current layout to initialLayout (use JSON.stringify comparison)

Keep history simple: linear stack, no branching. Trim oldest entries when exceeding 20.

Export useDashboardLayout hook.
  </action>
  <verify>
    - File exists at src/lib/hooks/use-dashboard-layout.ts
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Dashboard layout hook with undo history created</done>
</task>

<task type="auto">
  <name>Task 2: Create widget wrapper component</name>
  <files>
    - src/components/dashboard/widget-wrapper.tsx
  </files>
  <action>
Create src/components/dashboard/widget-wrapper.tsx:

```typescript
'use client';

import { X } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { cn } from '@/lib/utils';
```

Props interface:
```typescript
interface WidgetWrapperProps {
  title: string;
  instanceId: string;
  isEditMode: boolean;
  onRemove?: (instanceId: string) => void;
  children: React.ReactNode;
  className?: string;
}
```

Component structure:
- Card wrapper with relative positioning
- CardHeader with title and remove button (only visible in edit mode)
- Remove button: absolute positioned top-right, X icon, calls onRemove(instanceId)
- CardContent wraps children
- Add class "cursor-move" to header when isEditMode (indicates draggable)
- Add react-grid-layout drag handle class to header: className="react-grid-layout-drag-handle"

Note: react-grid-layout uses the parent div for dragging by default. We can optionally restrict to header with draggableHandle prop on the grid.

Export WidgetWrapper component.
  </action>
  <verify>
    - File exists at src/components/dashboard/widget-wrapper.tsx
    - Exports WidgetWrapper
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Widget wrapper component with remove button and drag handle</done>
</task>

<task type="auto">
  <name>Task 3: Create dashboard grid component</name>
  <files>
    - src/components/dashboard/dashboard-grid.tsx
  </files>
  <action>
Create src/components/dashboard/dashboard-grid.tsx:

```typescript
'use client';

import { useState, useEffect, useMemo } from 'react';
import { Responsive, WidthProvider, Layout } from 'react-grid-layout';
import 'react-grid-layout/css/styles.css';
import 'react-resizable/css/styles.css';

import { WIDGET_REGISTRY } from '@/lib/widgets/registry';
import { WidgetWrapper } from './widget-wrapper';
import { convertToGridLayout, convertFromGridLayout } from '@/lib/widgets/layout-utils';
import type { LayoutWidgetConfig } from '@/types/dashboard';
```

Create ResponsiveGridLayout:
```typescript
const ResponsiveGridLayout = WidthProvider(Responsive);
```

Constants:
```typescript
const BREAKPOINTS = { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 };
const COLS = { lg: 12, md: 12, sm: 6, xs: 4, xxs: 2 };
const ROW_HEIGHT = 100;
```

Props interface:
```typescript
interface DashboardGridProps {
  layout: LayoutWidgetConfig[];
  onLayoutChange: (layout: LayoutWidgetConfig[]) => void;
  onRemoveWidget: (instanceId: string) => void;
  isEditMode: boolean;
  renderWidget: (widgetId: string, instanceId: string) => React.ReactNode;
}
```

Component implementation:

1. SSR Guard: Use mounted state pattern
   ```typescript
   const [mounted, setMounted] = useState(false);
   useEffect(() => { setMounted(true); }, []);
   if (!mounted) return <DashboardSkeleton />;
   ```

2. Track current breakpoint:
   ```typescript
   const [currentBreakpoint, setCurrentBreakpoint] = useState<string>('lg');
   const isMobile = ['xs', 'xxs'].includes(currentBreakpoint);
   ```

3. Convert layout to grid format:
   ```typescript
   const gridLayout = useMemo(() => convertToGridLayout(layout), [layout]);
   ```

4. Handle layout change:
   ```typescript
   const handleLayoutChange = (newGridLayout: Layout[]) => {
     const updatedLayout = convertFromGridLayout(newGridLayout, layout);
     onLayoutChange(updatedLayout);
   };
   ```

5. Render ResponsiveGridLayout:
   - layouts={{ lg: gridLayout, md: gridLayout, sm: gridLayout, xs: gridLayout, xxs: gridLayout }}
   - breakpoints={BREAKPOINTS}
   - cols={COLS}
   - rowHeight={ROW_HEIGHT}
   - onLayoutChange={handleLayoutChange}
   - onBreakpointChange={(bp) => setCurrentBreakpoint(bp)}
   - isDraggable={isEditMode && !isMobile}
   - isResizable={isEditMode && !isMobile}
   - compactType="vertical"
   - preventCollision={false}
   - margin={[16, 16]}
   - containerPadding={[0, 0]}

6. Render children (widgets):
   ```typescript
   {layout.map((widget) => {
     const def = WIDGET_REGISTRY[widget.id];
     return (
       <div key={widget.i}>
         <WidgetWrapper
           title={def?.title || widget.id}
           instanceId={widget.i}
           isEditMode={isEditMode}
           onRemove={onRemoveWidget}
         >
           {renderWidget(widget.id, widget.i)}
         </WidgetWrapper>
       </div>
     );
   })}
   ```

7. Create DashboardSkeleton component (simple loading placeholder):
   - Grid of 3-4 skeleton cards with animate-pulse

Export DashboardGrid component.
  </action>
  <verify>
    - File exists at src/components/dashboard/dashboard-grid.tsx
    - CSS imports present for react-grid-layout
    - SSR guard implemented
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Dashboard grid with drag-drop, resize, and responsive breakpoints</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Grid renders in browser (test with placeholder widgets)
- Drag and resize work in edit mode
- Mobile breakpoint disables drag/resize
</verification>

<success_criteria>
- useDashboardLayout hook manages layout state with undo
- WidgetWrapper shows title, handles remove, indicates drag handle
- DashboardGrid uses react-grid-layout with responsive breakpoints
- Vertical compaction pushes widgets down (Notion-style)
- isDraggable and isResizable controlled by isEditMode and breakpoint
- SSR guard prevents hydration mismatch
</success_criteria>

<output>
After completion, create `.planning/phases/24-dashboard-customization-ui/24-03-SUMMARY.md`
</output>
