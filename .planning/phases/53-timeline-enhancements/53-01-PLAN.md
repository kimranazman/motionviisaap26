---
phase: 53-timeline-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/initiatives/[id]/route.ts
  - src/app/(dashboard)/timeline/page.tsx
  - src/hooks/use-gantt-drag.ts
  - src/components/timeline/gantt-chart.tsx
autonomous: true

must_haves:
  truths:
    - "PATCH /api/initiatives/[id] accepts startDate and endDate fields"
    - "Timeline initiative titles display without truncation"
    - "Timeline defaults to Objective grouping with KeyResult sub-headers"
    - "Timeline bars are draggable to change dates (move, resize-left, resize-right)"
    - "Drag changes persist via API and page refreshes"
  artifacts: []
  key_links: []
---

<objective>
Enhance the timeline gantt chart with three capabilities: (1) drag-to-edit dates by dragging bar center or edges, (2) full initiative titles without truncation, (3) default Objective > KeyResult grouping hierarchy with department as alternative.

Purpose: Let users visually manage initiative timelines by dragging bars, see full titles at a glance, and view initiatives organized by strategic objective.
Output: Interactive gantt chart with drag editing, full titles, and objective-based grouping.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@/Users/khairul/.claude/plans/nifty-questing-fountain.md
</context>

## Tasks

### Task 1: Extend PATCH API for date updates

**Files:** `src/app/api/initiatives/[id]/route.ts`

Extend the existing PATCH handler to accept optional `startDate` and `endDate` fields:

1. Read the current PATCH handler (lines ~120-163)
2. After the existing `personInCharge` handling block, add:
   - Parse `body.startDate` as Date if present, validate it's a valid date
   - Parse `body.endDate` as Date if present, validate it's a valid date
   - If both provided: validate startDate < endDate
   - If only one provided: fetch current initiative to get the other date, validate ordering
   - Add to `updateData` object
3. The existing `prisma.initiative.update()` call and response pattern handles the rest

**Verify:** Build passes, no TypeScript errors in the route file.

---

### Task 2: Remove title truncation and update grouping data

**Files:** `src/app/(dashboard)/timeline/page.tsx`, `src/components/timeline/gantt-chart.tsx`

**Part A — Timeline page query (page.tsx):**

1. Add `keyResultId: true` to the select
2. Expand `keyResult` select to include `description`: `keyResult: { select: { krId: true, description: true } }`
3. Update the return mapping to pass `keyResultId` and full `keyResult` object (not just string)

**Part B — Title truncation (gantt-chart.tsx):**

1. Update `Initiative` interface: change `keyResult: string` to `keyResultId: string | null` and `keyResult: { krId: string; description: string } | null`
2. Remove `truncate max-w-[160px] md:max-w-[220px]` from the title `<span>`
3. Change `items-center` to `items-start` on the flex parent div so KR badge aligns to top when text wraps
4. Add `mt-0.5` to the Badge component for vertical alignment
5. Update the Badge content from `{initiative.keyResult}` to `{initiative.keyResult?.krId || 'Unlinked'}`

**Part C — Default grouping and objective hierarchy (gantt-chart.tsx):**

1. Change default state from `useState<'department' | 'objective'>('department')` to `('objective')`
2. Add imports: `formatObjective` from utils, `OBJECTIVE_OPTIONS` if needed
3. Create a `TimelineGroup` interface:
   ```typescript
   interface TimelineGroup {
     key: string
     label: string
     subGroups: Array<{
       key: string
       label: string | null  // null = no sub-header (department mode)
       initiatives: Initiative[]
     }>
   }
   ```
4. Replace `groupedInitiatives` useMemo with `timelineGroups` useMemo:
   - **Department mode:** Each department becomes a group with one sub-group (no sub-header), containing all its initiatives
   - **Objective mode:** Group by `initiative.objective`, then within each objective sub-group by `initiative.keyResult?.krId || 'Unlinked'`. KR sub-headers show `KR1.1 - {description}` format
5. Update the render to iterate `timelineGroups`:
   - Objective/Department header: bold text, gray-50 bg, count of total initiatives
   - KR sub-header (when `subGroup.label` is not null): smaller text (text-xs), indented (pl-6 md:pl-8), lighter bg (bg-gray-50/50), count
   - Initiative rows: same as current but using the new interface
6. Update the group header format:
   - Objective mode: use `formatObjective(groupKey)` or hardcoded labels (`'Obj 1: Scale Events'`, `'Obj 2: Build AI Training'`)
   - Keep existing department formatting for department mode

**Verify:** Build passes, timeline displays with objective grouping by default, department grouping works when switched, titles show in full.

---

### Task 3: Implement drag-to-edit dates

**Files:** `src/hooks/use-gantt-drag.ts` (new), `src/components/timeline/gantt-chart.tsx`

**Part A — Custom hook (use-gantt-drag.ts):**

Create a new hook `useGanttDrag` that encapsulates all drag logic:

```typescript
interface UseGanttDragOptions {
  chartRef: React.RefObject<HTMLDivElement>
  onDatesChange: (id: string, startDate: string, endDate: string) => Promise<void>
}

interface DragState {
  id: string
  mode: 'move' | 'resize-left' | 'resize-right'
  startMouseX: number
  originalStart: Date
  originalEnd: Date
  currentStart: Date
  currentEnd: Date
  hasDragged: boolean
}
```

Key implementation:
1. `handleMouseDown(e, id, mode, startDate, endDate)` — sets drag state, prevents default
2. `useEffect` attaches window-level `mousemove` and `mouseup` when `dragState` is non-null:
   - **mousemove:** Calculate pixel delta from `startMouseX`. Convert to days: `daysDelta = Math.round(deltaX * 365 / containerWidth)`. Apply delta to `originalStart`/`originalEnd` based on mode. Set `hasDragged = true` if movement exceeds 3px threshold. Clamp dates to 2026 boundaries. Enforce minimum 1-day duration.
   - **mouseup:** If `hasDragged`, call `onDatesChange(id, currentStart.toISOString(), currentEnd.toISOString())`. Clear drag state.
3. Return `{ dragState, handleMouseDown, isDragging: dragState !== null, hasDragged: dragState?.hasDragged ?? false }`

Mode-specific date math:
- **move:** Both dates shift by `daysDelta`. Duration preserved. If shifted beyond year boundary, clamp both while preserving duration.
- **resize-left:** Only `currentStart` changes. Clamp: `newStart >= yearStart` and `newStart < originalEnd - 1 day`.
- **resize-right:** Only `currentEnd` changes. Clamp: `newEnd <= yearEnd` and `newEnd > originalStart + 1 day`.

**Part B — Integration into gantt-chart.tsx:**

1. Add imports: `useRef, useCallback` from react, `useRouter` from next/navigation, `useGanttDrag` from hooks
2. Add `chartContainerRef` on the month header grid `<div>` (the `flex-1 grid grid-cols-12` element)
3. Add `handleDatesChange` callback: PATCH fetch to `/api/initiatives/${id}` with `{ startDate, endDate }`, then `router.refresh()` on success
4. Initialize the hook: `const { dragState, handleMouseDown, isDragging, hasDragged } = useGanttDrag({ chartRef: chartContainerRef, onDatesChange: handleDatesChange })`
5. Create `getBarStyleForInitiative(initiative)` function that uses `dragState` current dates when the initiative is being dragged, otherwise uses initiative's dates
6. Update bar rendering — replace the single bar `<div>` with a structured bar:
   ```tsx
   <div style={getBarStyleForInitiative(initiative)} className="absolute top-1/2 -translate-y-1/2 h-6 rounded ... group">
     {/* Left resize handle */}
     <div className="absolute left-0 top-0 bottom-0 w-2 cursor-ew-resize z-10"
       onMouseDown={(e) => handleMouseDown(e, initiative.id, 'resize-left', ...)} />
     {/* Center move area */}
     <div className="absolute inset-0 cursor-grab active:cursor-grabbing"
       onMouseDown={(e) => handleMouseDown(e, initiative.id, 'move', ...)} />
     {/* Right resize handle */}
     <div className="absolute right-0 top-0 bottom-0 w-2 cursor-ew-resize z-10"
       onMouseDown={(e) => handleMouseDown(e, initiative.id, 'resize-right', ...)} />
     {/* Date tooltip during drag */}
     {dragState?.id === initiative.id && (
       <div className="absolute -top-8 left-1/2 -translate-x-1/2 bg-gray-900 text-white text-xs px-2 py-1 rounded whitespace-nowrap z-20 pointer-events-none">
         {dragState.currentStart.toLocaleDateString('en-MY', { day: 'numeric', month: 'short' })}
         {' - '}
         {dragState.currentEnd.toLocaleDateString('en-MY', { day: 'numeric', month: 'short' })}
       </div>
     )}
   </div>
   ```
7. Suppress Tooltip during drag: `<Tooltip open={isDragging ? false : undefined}>`
8. Suppress Link click after drag: add `onClick={(e) => { if (hasDragged) e.preventDefault() }}` to the Link
9. Add visual feedback during drag: ring-2 ring-blue-400 on the dragged bar
10. Add `select-none` class to the chart container during drag to prevent text selection

**Verify:** Build passes. In browser:
- Drag bar center → both dates shift, duration preserved
- Drag left edge → startDate changes, endDate stays
- Drag right edge → endDate changes, startDate stays
- Date tooltip visible during drag
- After release, bar updates to persisted position
- Clicking title still navigates (no drag interference)
