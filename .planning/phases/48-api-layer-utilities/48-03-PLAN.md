---
phase: 48-api-layer-utilities
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/dashboard/stats/route.ts
  - src/app/(dashboard)/page.tsx
  - src/lib/initiative-group-utils.ts
  - src/lib/initiative-kpi-utils.ts
  - src/lib/kr-progress-utils.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard stats API computes revenue from KeyResult actual values (metricType=REVENUE) not hardcoded proxy"
    - "Dashboard page server component computes revenue the same way as the stats API"
    - "Grouping utility groups initiatives by KeyResult FK relation (keyResult.krId) not string normalization"
    - "KPI utilities file exports stub functions that return safe defaults (no runtime crashes in UI components)"
    - "KR progress calculation utility computes weighted objective rollup"
  artifacts:
    - path: "src/app/api/dashboard/stats/route.ts"
      provides: "Real revenue stats from KeyResult model"
      contains: "metricType.*REVENUE"
    - path: "src/app/(dashboard)/page.tsx"
      provides: "Real revenue calculation in server component"
      contains: "metricType.*REVENUE"
    - path: "src/lib/initiative-group-utils.ts"
      provides: "FK-based initiative grouping"
      contains: "keyResult\\.krId"
    - path: "src/lib/initiative-kpi-utils.ts"
      provides: "Stub functions preventing UI component crashes"
      exports: ["calculateKpi", "aggregateKpiTotals"]
    - path: "src/lib/kr-progress-utils.ts"
      provides: "Weighted objective progress calculation"
      exports: ["calculateObjectiveProgress"]
  key_links:
    - from: "src/app/api/dashboard/stats/route.ts"
      to: "prisma.keyResult"
      via: "findMany where metricType REVENUE"
      pattern: "prisma\\.keyResult\\.findMany"
    - from: "src/lib/initiative-group-utils.ts"
      to: "initiative.keyResult.krId"
      via: "FK relation grouping"
      pattern: "item\\.keyResult\\?.krId"
    - from: "src/lib/kr-progress-utils.ts"
      to: "KeyResult.progress and KeyResult.weight"
      via: "weighted average formula"
      pattern: "progress.*weight"
---

<objective>
Update dashboard revenue calculation to use real KeyResult data, rewrite grouping utilities for FK-based grouping, replace KPI utilities with stubs, and create KR progress calculation utility.

Purpose: The dashboard currently shows a meaningless proxy (completed/total * 1M). The grouping utility references a non-existent string field. The KPI utility references removed Initiative fields. This plan fixes all three and adds the weighted progress rollup needed by Phase 49.
Output: 5 files updated/created -- dashboard shows real revenue, grouping works with FK relations, KPI stubs prevent crashes, and new progress utility is ready.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-api-layer-utilities/48-RESEARCH.md

Files to modify:
@src/app/api/dashboard/stats/route.ts
@src/app/(dashboard)/page.tsx
@src/lib/initiative-group-utils.ts
@src/lib/initiative-kpi-utils.ts
@prisma/schema.prisma (reference for KeyResult model with metricType, target, actual, progress, weight)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix dashboard revenue calculation (stats API + page.tsx)</name>
  <files>
    src/app/api/dashboard/stats/route.ts
    src/app/(dashboard)/page.tsx
  </files>
  <action>
Both files have identical hardcoded revenue proxy logic that must be replaced with real KeyResult data.

**src/app/api/dashboard/stats/route.ts:**

Replace lines 40-45 (the hardcoded revenue proxy):
```
const completedCount = statusCounts.find(s => s.status === 'COMPLETED')?._count || 0
const revenueTarget = 1000000
const revenueProgress = totalInitiatives > 0
  ? Math.round((completedCount / totalInitiatives) * revenueTarget)
  : 0
```

With real KR revenue query:
```typescript
// Real revenue from KeyResult model
const revenueKRs = await prisma.keyResult.findMany({
  where: { metricType: 'REVENUE' },
  select: { target: true, actual: true },
})
const revenueTarget = revenueKRs.reduce(
  (sum, kr) => sum + Number(kr.target), 0
)
const revenueProgress = revenueKRs.reduce(
  (sum, kr) => sum + Number(kr.actual), 0
)

const completedCount = statusCounts.find(s => s.status === 'COMPLETED')?._count || 0
```

Keep `completedCount` computation (used for completionRate), but move it after the revenue block. Keep `completionRate` calculation as-is. All other stats (byStatus, byDepartment, byObjective, byPerson, upcomingDeadlines, atRiskCount) remain unchanged.

Import `Prisma` from `@prisma/client` if not already imported (needed for the where clause type).

**src/app/(dashboard)/page.tsx:**

Apply the same change to the `getDashboardData()` function (lines 38-44). Replace:
```
const revenueTarget = 1000000
const revenueProgress = totalInitiatives > 0
  ? Math.round((completedCount / totalInitiatives) * revenueTarget)
  : 0
```

With:
```typescript
// Real revenue from KeyResult model
const revenueKRs = await prisma.keyResult.findMany({
  where: { metricType: 'REVENUE' },
  select: { target: true, actual: true },
})
const revenueTarget = revenueKRs.reduce(
  (sum, kr) => sum + Number(kr.target), 0
)
const revenueProgress = revenueKRs.reduce(
  (sum, kr) => sum + Number(kr.actual), 0
)
```

Keep all other dashboard data (stats, byStatus, byDepartment, byPerson, recentInitiatives, CRM data) unchanged.

**Important:** The response field names `revenueTarget` and `revenueProgress` remain the same -- only the values change. This means the `kpi-cards.tsx` dashboard widget that consumes `stats.revenueTarget` and `stats.revenueProgress` will work without any UI changes.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no errors. Verify with curl:
- `curl http://localhost:3000/api/dashboard/stats` returns `revenueTarget: 1000000` (sum of KR1.1 800K + KR2.2 200K) and `revenueProgress: 0` (actual values are 0 in seed)
- Dashboard page loads without errors
  </verify>
  <done>
Dashboard stats API and page.tsx both compute revenue from KeyResult model (metricType=REVENUE). Revenue target is sum of KR targets (1,000,000), revenue progress is sum of KR actuals. Field names preserved for backward compatibility with UI widgets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite grouping utility, stub KPI utility, create KR progress utility</name>
  <files>
    src/lib/initiative-group-utils.ts
    src/lib/initiative-kpi-utils.ts
    src/lib/kr-progress-utils.ts
  </files>
  <action>
**src/lib/initiative-group-utils.ts -- FULL REWRITE:**

Replace the entire file. The old version groups by `normalizeKeyResult(item.keyResult)` where `keyResult` is a string field that no longer exists. The new version groups by the FK relation `item.keyResult?.krId`.

New types:
```typescript
export interface InitiativeForGrouping {
  id: string
  objective: string
  keyResultId: number | null       // FK field (Int in schema)
  keyResult?: { krId: string } | null  // Included relation
  status: string
  title: string
}

export interface GroupedKeyResult {
  keyResultId: number | null
  krId: string                     // Display label ("KR1.1")
  initiatives: InitiativeForGrouping[]
  totalInitiatives: number
  completedCount: number
}

export interface GroupedObjective {
  objective: string
  keyResults: GroupedKeyResult[]
  totalInitiatives: number
  completedCount: number
  inProgressCount: number
  atRiskCount: number
}
```

New `groupInitiativesByObjective` function:
- Group by `initiative.objective` (same as before)
- Sub-group by `item.keyResult?.krId || 'Unlinked'` (FK relation instead of string normalization)
- Sort key results by krId using localeCompare (same as before)
- Return same GroupedObjective shape (backward compatible for consumers)

Remove the `normalizeKeyResult` function entirely (no longer needed -- FK gives exact grouping).

**src/lib/initiative-kpi-utils.ts -- REPLACE WITH STUBS:**

Keep all type exports (InitiativeWithKpiAndProjects, KpiResult, AggregatedKpi, ProjectForKpi) so importing components do not crash. Replace function implementations with stubs that return safe defaults.

Stub `calculateKpi`: return `{ label: 'N/A', target: null, actual: 0, unit: '', percentage: null, source: 'manual' as const, displayText: 'N/A' }` regardless of input.

Stub `aggregateKpiTotals`: return `{ totalTarget: 0, totalActual: 0, percentage: null, hasData: false, mixedUnits: false, unit: '' }` regardless of input.

Add a JSDoc comment at the top: `/** @deprecated KPI fields removed from Initiative in v2.0. Functions return safe defaults. Remove in Phase 52. */`

The type interfaces stay the same shape so existing imports compile. The function bodies are replaced with no-ops.

**src/lib/kr-progress-utils.ts -- NEW FILE:**

Create a new utility for weighted objective progress rollup (UTIL-03).

```typescript
/**
 * Key Result progress calculation utilities
 *
 * Calculate weighted objective rollup from KeyResult progress and weight values.
 * Used by OKR Hierarchy UI (Phase 49) for objective-level progress display.
 */

export interface KeyResultForProgress {
  progress: number  // 0-100
  weight: number    // any positive number (will be normalized)
}

/**
 * Calculate weighted objective rollup.
 * Formula: Sum(KR_progress_i * KR_weight_i) / Sum(KR_weight_i)
 *
 * Handles:
 * - Empty array: returns 0
 * - Zero total weight: returns 0
 * - Missing/falsy weights: defaults to 1
 * - Result clamped to 0-100
 */
export function calculateObjectiveProgress(
  keyResults: KeyResultForProgress[]
): number {
  if (keyResults.length === 0) return 0

  const totalWeight = keyResults.reduce(
    (sum, kr) => sum + (kr.weight || 1), 0
  )
  if (totalWeight === 0) return 0

  const weightedSum = keyResults.reduce(
    (sum, kr) => sum + (Number(kr.progress) * (kr.weight || 1)), 0
  )

  return Math.max(0, Math.min(100, weightedSum / totalWeight))
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- no errors in any of the 3 files. Verify:
- initiative-group-utils.ts exports GroupedObjective, GroupedKeyResult, InitiativeForGrouping types and groupInitiativesByObjective function
- initiative-kpi-utils.ts exports all existing types plus stub calculateKpi and aggregateKpiTotals functions
- kr-progress-utils.ts exports calculateObjectiveProgress function
- No imports in the codebase break (grep for imports of these files)
  </verify>
  <done>
Grouping utility uses keyResult.krId FK relation for grouping. KPI utility exports stub functions returning safe defaults (no UI crashes). KR progress utility provides calculateObjectiveProgress with weighted rollup formula. All consuming components continue to compile.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors in all 5 files
2. Dashboard stats returns `revenueTarget: 1000000` computed from KeyResult model
3. Dashboard page loads and displays revenue from KR data
4. Grouping utility groups by `keyResult.krId` not string normalization
5. KPI utility stubs prevent runtime crashes in UI components
6. KR progress utility correctly computes weighted average (manual test: `calculateObjectiveProgress([{progress: 50, weight: 2}, {progress: 100, weight: 1}])` = 66.67)
</verification>

<success_criteria>
- Dashboard revenue computed from KeyResult actuals (metricType=REVENUE), not hardcoded proxy
- Grouping utility uses FK-based grouping (keyResult.krId)
- KPI utility is stubbed with safe defaults, types preserved
- New kr-progress-utils.ts exports calculateObjectiveProgress
- No TypeScript compilation errors across the codebase
</success_criteria>

<output>
After completion, create `.planning/phases/48-api-layer-utilities/48-03-SUMMARY.md`
</output>
