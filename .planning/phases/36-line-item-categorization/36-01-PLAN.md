---
phase: 36-line-item-categorization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/ai-categorization.ts
  - src/app/api/projects/[id]/costs/route.ts
  - src/app/api/projects/[id]/costs/[costId]/route.ts
  - src/app/api/costs/[id]/normalize/route.ts
autonomous: true

must_haves:
  truths:
    - "Cost entry has normalizedItem field that can be null or string"
    - "AI assigns normalizedItem when cost is created with supplier"
    - "AI re-assigns normalizedItem when cost description changes"
    - "User can manually edit normalizedItem via API"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "normalizedItem field on Cost model with index"
      contains: "normalizedItem"
    - path: "src/lib/ai-categorization.ts"
      provides: "getNormalizedItem function using OpenAI"
      exports: ["getNormalizedItem"]
    - path: "src/app/api/costs/[id]/normalize/route.ts"
      provides: "PATCH endpoint for manual normalizedItem update"
      exports: ["PATCH"]
  key_links:
    - from: "src/app/api/projects/[id]/costs/route.ts"
      to: "src/lib/ai-categorization.ts"
      via: "fire-and-forget categorization on cost create"
      pattern: "generateCostCategorization"
    - from: "src/app/api/projects/[id]/costs/[costId]/route.ts"
      to: "src/lib/ai-categorization.ts"
      via: "fire-and-forget categorization on description change"
      pattern: "generateCostCategorization"
---

<objective>
Add normalizedItem field to Cost model and implement AI categorization on cost create/update.

Purpose: Enable price comparison by having AI assign standardized item names (categories) to cost entries. Users can then filter by normalizedItem to compare prices across suppliers.

Output: Schema with normalizedItem field, AI categorization helper, modified cost APIs, manual edit endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-line-item-categorization/36-RESEARCH.md

# Existing files to modify
@prisma/schema.prisma
@src/lib/embeddings.ts
@src/app/api/projects/[id]/costs/route.ts
@src/app/api/projects/[id]/costs/[costId]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add normalizedItem field to Cost model and create AI categorization helper</name>
  <files>
    - prisma/schema.prisma
    - src/lib/ai-categorization.ts
  </files>
  <action>
1. Update prisma/schema.prisma - Add to Cost model:
   ```prisma
   // AI-assigned normalized item name for price comparison
   normalizedItem String? @map("normalized_item") @db.VarChar(100)
   ```
   Add index after existing indexes:
   ```prisma
   @@index([normalizedItem])
   ```

2. Create src/lib/ai-categorization.ts:
   - Import OpenAI from 'openai'
   - Lazy initialize OpenAI client (same pattern as embeddings.ts)
   - Export async function getNormalizedItem(description: string): Promise<string>
   - Use gpt-4o-mini model with temperature=0 for consistency
   - System prompt should:
     - Instruct AI to normalize product/service names
     - Remove quantity, units, supplier-specific variations
     - Keep essential identifiers (size, grade, type)
     - Use title case, 3-6 words max
     - For services, prefix with category (e.g., "Transportation - Taxi")
   - Return the trimmed response or description as fallback

3. Run database migration:
   ```bash
   npx prisma db push
   ```
  </action>
  <verify>
    - `npx prisma validate` passes
    - `npx prisma db push` completes without errors
    - src/lib/ai-categorization.ts exists and exports getNormalizedItem
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
    - Cost model has normalizedItem field with @map("normalized_item")
    - Index on normalizedItem exists in schema
    - ai-categorization.ts exports getNormalizedItem function
    - Database schema is updated
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify cost create/update APIs to trigger AI categorization</name>
  <files>
    - src/app/api/projects/[id]/costs/route.ts
    - src/app/api/projects/[id]/costs/[costId]/route.ts
  </files>
  <action>
1. Update src/app/api/projects/[id]/costs/route.ts (POST handler):
   - Import getNormalizedItem from '@/lib/ai-categorization'
   - After creating cost, if supplierId exists, fire-and-forget:
     ```typescript
     generateCostCategorization(cost.id, cost.description).catch(console.error)
     ```
   - Add generateCostCategorization function (similar to generateCostEmbedding):
     ```typescript
     async function generateCostCategorization(costId: string, description: string) {
       try {
         const normalizedItem = await getNormalizedItem(description)
         await prisma.cost.update({
           where: { id: costId },
           data: { normalizedItem },
         })
       } catch (error) {
         console.error(`Failed to categorize cost ${costId}:`, error)
       }
     }
     ```

2. Update src/app/api/projects/[id]/costs/[costId]/route.ts (PATCH handler):
   - Import getNormalizedItem from '@/lib/ai-categorization'
   - Add generateCostCategorization function (same as above)
   - Modify the fire-and-forget section:
     - If description changed AND cost has supplier, trigger categorization
     - If supplier added (was null, now has value), trigger categorization
     ```typescript
     if (cost.supplierId && (descriptionChanged || supplierAdded)) {
       generateCostCategorization(cost.id, cost.description).catch(console.error)
       generateCostEmbedding(cost.id, cost.description).catch(console.error)
     }
     ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Create a test cost with supplier via API and check normalizedItem is set after ~2-3 seconds
    - Update cost description and verify normalizedItem updates
  </verify>
  <done>
    - POST /api/projects/[id]/costs triggers AI categorization for costs with suppliers
    - PATCH /api/projects/[id]/costs/[costId] triggers AI categorization when description changes or supplier is added
    - Both use fire-and-forget pattern (non-blocking)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create manual normalize endpoint for user override</name>
  <files>
    - src/app/api/costs/[id]/normalize/route.ts
  </files>
  <action>
1. Create directory: src/app/api/costs/[id]/normalize/

2. Create src/app/api/costs/[id]/normalize/route.ts:
   - Import NextRequest, NextResponse from 'next/server'
   - Import prisma from '@/lib/prisma'
   - Import requireEditor from '@/lib/auth-utils'
   - Export async PATCH handler:
     ```typescript
     export async function PATCH(
       request: NextRequest,
       { params }: { params: Promise<{ id: string }> }
     ) {
       const { error } = await requireEditor()
       if (error) return error

       try {
         const { id } = await params
         const body = await request.json()

         if (body.normalizedItem === undefined) {
           return NextResponse.json(
             { error: 'normalizedItem is required' },
             { status: 400 }
           )
         }

         const cost = await prisma.cost.update({
           where: { id },
           data: {
             normalizedItem: body.normalizedItem?.trim() || null,
           },
           select: {
             id: true,
             normalizedItem: true,
           },
         })

         return NextResponse.json(cost)
       } catch (error) {
         console.error('Error updating normalizedItem:', error)
         return NextResponse.json(
           { error: 'Failed to update' },
           { status: 500 }
         )
       }
     }
     ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Test with curl: `curl -X PATCH http://localhost:3000/api/costs/{id}/normalize -H "Content-Type: application/json" -d '{"normalizedItem":"Test Category"}'`
    - Should return 200 with updated cost
    - Should return 400 if normalizedItem not in body
  </verify>
  <done>
    - PATCH /api/costs/[id]/normalize endpoint exists
    - Requires editor role
    - Updates normalizedItem field
    - Returns updated cost with id and normalizedItem
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Database: `SELECT normalized_item FROM costs LIMIT 1` works (column exists)
2. API: POST cost with supplier creates normalizedItem after async completion
3. API: PATCH cost description re-categorizes
4. API: PATCH /api/costs/[id]/normalize allows manual override
5. TypeScript: `npx tsc --noEmit` passes
6. No regressions: Existing cost CRUD still works
</verification>

<success_criteria>
- ITEM-01: Cost entry has normalizedItem field (AI-assigned category) - COMPLETE
- ITEM-02: AI assigns normalizedItem when cost is created - COMPLETE
- ITEM-03: AI updates normalizedItem when cost description changes - COMPLETE
- ITEM-04: User can manually edit normalizedItem if AI got it wrong - COMPLETE
</success_criteria>

<output>
After completion, create `.planning/phases/36-line-item-categorization/36-01-SUMMARY.md`
</output>
