---
phase: 34-activity-logging-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/activity-utils.ts
  - src/app/api/activity-logs/route.ts
  - src/app/api/projects/[id]/route.ts
  - src/components/shared/activity-timeline.tsx
autonomous: true

must_haves:
  truths:
    - "Project title change syncs to source deal title"
    - "Project title change syncs to source potential title"
    - "ActivityLog entry created when title syncs"
    - "Activity logs can be fetched by entity type and ID"
  artifacts:
    - path: "src/lib/activity-utils.ts"
      provides: "Activity logging helper functions"
      exports: ["logActivity", "logTitleSync", "formatActivityAction"]
    - path: "src/app/api/activity-logs/route.ts"
      provides: "Activity log GET endpoint"
      exports: ["GET"]
    - path: "src/app/api/projects/[id]/route.ts"
      provides: "Project PATCH with title sync"
      contains: "$transaction"
    - path: "src/components/shared/activity-timeline.tsx"
      provides: "Activity display component"
      exports: ["ActivityTimeline"]
  key_links:
    - from: "src/app/api/projects/[id]/route.ts"
      to: "src/lib/activity-utils.ts"
      via: "import logActivity"
      pattern: "import.*activity-utils"
    - from: "src/app/api/projects/[id]/route.ts"
      to: "prisma.$transaction"
      via: "atomic title sync"
      pattern: "\\$transaction"
---

<objective>
Create activity logging infrastructure and bidirectional title sync.

Purpose: Enable tracking of sync events between projects and deals/potentials, plus ensure project title changes propagate back to source entities atomically.

Output: Activity log API, utility functions, timeline component, and title sync in project PATCH.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-activity-logging-sync/34-RESEARCH.md

# Key existing files
@prisma/schema.prisma (ActivityLog model, ActivityEntityType, ActivityAction enums)
@src/app/api/projects/[id]/route.ts (current project PATCH - needs transaction + sync)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Activity logging utilities</name>
  <files>src/lib/activity-utils.ts</files>
  <action>
Create activity-utils.ts with helper functions for logging activities:

1. logActivity() - generic function to create ActivityLog entry:
   - Parameters: { entityType, entityId, action, field?, oldValue?, newValue?, userId? }
   - Uses prisma to create ActivityLog record
   - Returns the created log entry

2. logTitleSync() - convenience function for title sync events:
   - Parameters: (sourceType: 'DEAL' | 'POTENTIAL', sourceId, oldTitle, newTitle, userId?)
   - Maps sourceType to ActivityEntityType enum
   - Calls logActivity with action: TITLE_SYNCED, field: 'title'

3. formatActivityAction() - formats action enum for display:
   - Input: ActivityAction enum value
   - Output: Human-readable string (e.g., TITLE_SYNCED -> "Title synced from project")

Use existing Prisma client from @/lib/prisma. Import enums from @prisma/client.
  </action>
  <verify>TypeScript compiles without errors. Run: `npx tsc --noEmit src/lib/activity-utils.ts`</verify>
  <done>Activity logging utilities exist with logActivity, logTitleSync, and formatActivityAction functions</done>
</task>

<task type="auto">
  <name>Task 2: Activity logs API route</name>
  <files>src/app/api/activity-logs/route.ts</files>
  <action>
Create GET /api/activity-logs endpoint that fetches activity logs with filters:

1. Query parameters:
   - entityType (required): 'DEAL' | 'POTENTIAL' | 'PROJECT'
   - entityId (required): The entity ID to fetch logs for
   - limit (optional, default 20): Max logs to return

2. Implementation:
   - Use requireAuth() for auth check
   - Validate entityType is valid ActivityEntityType
   - Query prisma.activityLog.findMany() with:
     - where: { entityType, entityId }
     - include: { user: { select: { id, name, image } } }
     - orderBy: { createdAt: 'desc' }
     - take: limit

3. Response:
   - Return JSON array of activity logs with user info
   - Each log: { id, action, field, oldValue, newValue, createdAt, user: { name, image } }

No POST/PATCH/DELETE - activity logs are created internally only, not via API.
  </action>
  <verify>Start dev server, test with curl: `curl -H "Cookie: ..." "http://localhost:3000/api/activity-logs?entityType=DEAL&entityId=xxx"` returns 200 (empty array is fine)</verify>
  <done>Activity logs API returns filtered logs by entity type and ID</done>
</task>

<task type="auto">
  <name>Task 3: Project PATCH with title sync</name>
  <files>src/app/api/projects/[id]/route.ts</files>
  <action>
Enhance the existing PATCH handler to sync title changes to source deal/potential:

1. At start of PATCH, get current project with source links:
   ```typescript
   const currentProject = await prisma.project.findUnique({
     where: { id },
     include: {
       sourceDeal: { select: { id: true, title: true } },
       sourcePotential: { select: { id: true, title: true } },
     },
   })
   ```

2. Check if title is changing:
   ```typescript
   const titleChanged = body.title !== undefined && body.title !== currentProject?.title
   ```

3. Wrap entire update in $transaction:
   - Update project as before
   - If titleChanged AND sourceDeal exists:
     - Update deal title: `tx.deal.update({ where: { id: sourceDeal.id }, data: { title: body.title } })`
     - Create activity log: `tx.activityLog.create({ entityType: 'DEAL', entityId, action: 'TITLE_SYNCED', field: 'title', oldValue, newValue, userId })`
   - If titleChanged AND sourcePotential exists:
     - Update potential title: `tx.potentialProject.update({ where: { id: sourcePotential.id }, data: { title: body.title } })`
     - Create activity log: `tx.activityLog.create({ entityType: 'POTENTIAL', entityId, action: 'TITLE_SYNCED', field: 'title', oldValue, newValue, userId })`

4. Get userId from session: `const { session } = await requireEditor()` - session.user.id

Keep existing update fields and includes. Only add transaction wrapper and sync logic.

IMPORTANT: Use ActivityEntityType and ActivityAction enums from @prisma/client for type safety.
  </action>
  <verify>
1. Create a test project linked to a deal
2. PATCH project title via API
3. Verify deal title also changed
4. Query activity logs for deal - should show TITLE_SYNCED entry
  </verify>
  <done>Project title changes sync to source deal/potential with activity log entries</done>
</task>

</tasks>

<verification>
1. Activity utilities compile: `npx tsc --noEmit src/lib/activity-utils.ts`
2. Activity logs API works: GET /api/activity-logs?entityType=DEAL&entityId=xxx returns 200
3. Title sync works: PATCH project title -> deal/potential title updates
4. Activity logged: Query activity logs shows TITLE_SYNCED entry after title sync
</verification>

<success_criteria>
- Activity logging utilities created with helper functions
- Activity logs API returns filtered logs by entity
- Project title changes propagate to source deal/potential
- Activity log entries created for sync events
- All operations atomic via Prisma transaction
</success_criteria>

<output>
After completion, create `.planning/phases/34-activity-logging-sync/34-01-SUMMARY.md`
</output>
