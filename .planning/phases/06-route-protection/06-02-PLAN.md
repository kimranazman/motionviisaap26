---
phase: 06-route-protection
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/api/initiatives/route.ts
  - src/app/api/initiatives/[id]/route.ts
  - src/app/api/initiatives/[id]/comments/route.ts
  - src/app/api/initiatives/reorder/route.ts
  - src/app/api/initiatives/search/route.ts
  - src/app/api/dashboard/stats/route.ts
  - src/app/api/events-to-attend/route.ts
  - src/app/api/notifications/route.ts
autonomous: true

must_haves:
  truths:
    - "API call without session returns 401 Unauthorized JSON"
    - "API write call with VIEWER role returns 403 Forbidden JSON"
    - "API read call with any authenticated role succeeds"
    - "API write call with ADMIN or EDITOR role succeeds"
  artifacts:
    - path: "src/app/api/initiatives/route.ts"
      provides: "Protected initiatives list/create endpoints"
      contains: "requireAuth"
    - path: "src/app/api/initiatives/[id]/route.ts"
      provides: "Protected initiative CRUD endpoints"
      contains: "requireEditor"
    - path: "src/app/api/dashboard/stats/route.ts"
      provides: "Protected dashboard stats endpoint"
      contains: "requireAuth"
  key_links:
    - from: "src/app/api/initiatives/route.ts"
      to: "src/lib/auth-utils.ts"
      via: "import requireAuth, requireEditor"
      pattern: "import.*require.*from.*@/lib/auth-utils"
    - from: "All API routes"
      to: "Early return on error"
      via: "if (error) return error pattern"
      pattern: "if \\(error\\) return error"
---

<objective>
Protect all API routes with authentication and role-based authorization.

Purpose: Implement PROT-02 (401 for unauthenticated) and PROT-03 (403 for wrong role) requirements by adding auth checks to all 8 API route files.

Output: All API routes protected with consistent 401/403 responses using auth utilities from Plan 01.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-route-protection/06-RESEARCH.md

# Prior plan output
@.planning/phases/06-route-protection/06-01-SUMMARY.md

# Files to modify
@src/app/api/initiatives/route.ts
@src/app/api/initiatives/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Protect initiatives and dashboard routes</name>
  <files>
    src/app/api/initiatives/route.ts
    src/app/api/initiatives/[id]/route.ts
    src/app/api/initiatives/reorder/route.ts
    src/app/api/initiatives/search/route.ts
    src/app/api/dashboard/stats/route.ts
  </files>
  <action>
For each route file, add import at top:
```typescript
import { requireAuth, requireEditor } from '@/lib/auth-utils'
```

Apply protection pattern to each handler:

**GET handlers** (read operations - any authenticated user):
```typescript
export async function GET(request: NextRequest) {
  const { session, error } = await requireAuth()
  if (error) return error

  // ... existing code unchanged
}
```

**POST/PUT/PATCH/DELETE handlers** (write operations - ADMIN or EDITOR only):
```typescript
export async function POST(request: NextRequest) {
  const { session, error } = await requireEditor()
  if (error) return error

  // ... existing code unchanged
}
```

Route-specific mapping:
- `/api/initiatives` GET: requireAuth, POST: requireEditor
- `/api/initiatives/[id]` GET: requireAuth, PUT: requireEditor, PATCH: requireEditor, DELETE: requireEditor
- `/api/initiatives/reorder` POST: requireEditor
- `/api/initiatives/search` GET: requireAuth
- `/api/dashboard/stats` GET: requireAuth

Keep all existing logic intact - just add auth check at the start of each function.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Each file has import from `@/lib/auth-utils`
3. Each handler starts with auth check and early return pattern
  </verify>
  <done>5 route files protected: initiatives (list/create), initiatives/[id], reorder, search, dashboard stats</done>
</task>

<task type="auto">
  <name>Task 2: Protect remaining routes</name>
  <files>
    src/app/api/initiatives/[id]/comments/route.ts
    src/app/api/events-to-attend/route.ts
    src/app/api/notifications/route.ts
  </files>
  <action>
Apply same protection pattern to remaining routes.

For each route file, add import:
```typescript
import { requireAuth, requireEditor } from '@/lib/auth-utils'
```

Route-specific mapping:
- `/api/initiatives/[id]/comments`:
  - GET: requireAuth (view comments)
  - POST: requireAuth (any authenticated user can comment - decision per RESEARCH.md)
  - DELETE: requireEditor (only editors can delete comments)

- `/api/events-to-attend`:
  - GET: requireAuth
  - POST: requireEditor
  - PUT/PATCH: requireEditor
  - DELETE: requireEditor

- `/api/notifications`:
  - GET: requireAuth
  - Any write operations: requireEditor (if they exist)

Note: Comments POST uses requireAuth (not requireEditor) because VIEWERs should be able to add their own comments per research recommendation.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Comments route allows authenticated users to POST
3. Events-to-attend and notifications protected
  </verify>
  <done>3 remaining route files protected: comments, events-to-attend, notifications</done>
</task>

<task type="auto">
  <name>Task 3: Verify all protection and test</name>
  <files>None (verification only)</files>
  <action>
Run comprehensive verification:

1. TypeScript compilation: `npx tsc --noEmit`

2. Build test: `npm run build`

3. Grep verification - ensure all API routes have protection:
   ```bash
   grep -l "requireAuth\|requireEditor" src/app/api/**/route.ts
   ```
   Should list all 8 route files (excluding auth/[...nextauth])

4. Manual verification checklist:
   - [ ] initiatives/route.ts - GET: requireAuth, POST: requireEditor
   - [ ] initiatives/[id]/route.ts - GET: requireAuth, PUT/PATCH/DELETE: requireEditor
   - [ ] initiatives/[id]/comments/route.ts - GET/POST: requireAuth, DELETE: requireEditor
   - [ ] initiatives/reorder/route.ts - POST: requireEditor
   - [ ] initiatives/search/route.ts - GET: requireAuth
   - [ ] dashboard/stats/route.ts - GET: requireAuth
   - [ ] events-to-attend/route.ts - GET: requireAuth, writes: requireEditor
   - [ ] notifications/route.ts - GET: requireAuth

If any route file is missing protection, add it.
  </action>
  <verify>
1. `npm run build` succeeds
2. All 8 API routes have protection imports
3. No unauthenticated API access possible
  </verify>
  <done>All API routes protected, build passes, ready for testing</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. Start dev server: `npm run dev`
3. Test unauthenticated API access (in browser without login):
   - `curl http://localhost:3000/api/initiatives` should return 401
   - `curl http://localhost:3000/api/dashboard/stats` should return 401
4. Test authenticated access (login first, then):
   - `/api/initiatives` GET should succeed
   - POST operations require ADMIN or EDITOR role
</verification>

<success_criteria>
- All 8 API route files import from `@/lib/auth-utils`
- Every GET handler uses `requireAuth()`
- Every POST/PUT/PATCH/DELETE handler uses `requireEditor()` (except comments POST which uses requireAuth)
- `npm run build` passes with no errors
- API returns 401 JSON for unauthenticated requests
- API returns 403 JSON for VIEWER attempting write operations
</success_criteria>

<output>
After completion, create `.planning/phases/06-route-protection/06-02-SUMMARY.md`
</output>
