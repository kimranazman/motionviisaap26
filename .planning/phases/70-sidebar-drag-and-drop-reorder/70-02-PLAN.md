# Plan 70-02: Settings DnD UI & Sidebar Order Rendering

## Frontmatter
- **Phase:** 70
- **Plan:** 02
- **Wave:** 2
- **Depends on:** 70-01
- **Files modified:** src/app/(dashboard)/settings/page.tsx, src/components/layout/sidebar.tsx, src/components/layout/mobile-sidebar.tsx
- **Autonomous:** yes

## Objective

Add drag-and-drop reorder UI to the Settings page using @dnd-kit/sortable. Users can drag items within each nav group to reorder them. The custom order persists and is applied in both desktop and mobile sidebars. A "Reset Order" button restores default order.

## Tasks

<task id="1">
**Add DnD reorder to Settings page**

In `src/app/(dashboard)/settings/page.tsx`:

1. Add imports:
```typescript
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core'
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  useSortable,
  arrayMove,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import { restrictToVerticalAxis, restrictToParentElement } from '@dnd-kit/modifiers'
import { GripVertical, RotateCcw } from 'lucide-react'
import { getDefaultNavOrder } from '@/lib/nav-config'
```

Note: Check if `@dnd-kit/modifiers` is installed. If not, implement vertical constraint without it (just skip the modifiers import and prop).

2. Extract the nav visibility hook to also get ordering:
```typescript
const { hiddenItems, navItemOrder, isLoading: navLoading, saveHiddenItems, saveNavOrder } = useNavVisibility()
```

3. Add local order state:
```typescript
const [localOrder, setLocalOrder] = useState<Record<string, string[]>>({})
```

4. Sync local order from persisted on load:
```typescript
useEffect(() => {
  if (!navLoading) {
    setLocalOrder(navItemOrder ?? getDefaultNavOrder())
  }
}, [navLoading, navItemOrder])
```

5. Extend dirty detection to include order:
```typescript
const isOrderDirty = JSON.stringify(localOrder) !== JSON.stringify(navItemOrder ?? getDefaultNavOrder())
const isHiddenDirty = JSON.stringify([...localHidden].sort()) !== JSON.stringify([...hiddenItems].sort())
const isDirty = isHiddenDirty || isOrderDirty
```

6. Extend save handler to save both:
```typescript
const handleSave = async () => {
  setIsSaving(true)
  try {
    await saveHiddenItems(localHidden)
    if (isOrderDirty) {
      await saveNavOrder(localOrder)
    }
    toast.success('Settings saved')
  } catch {
    toast.error('Failed to save settings')
  } finally {
    setIsSaving(false)
  }
}
```

7. Add reset order handler:
```typescript
const handleResetOrder = () => {
  setLocalOrder(getDefaultNavOrder())
}
```

8. Configure DnD sensors with activation constraint (distance: 5 to prevent accidental drags):
```typescript
const sensors = useSensors(
  useSensor(PointerSensor, { activationConstraint: { distance: 5 } }),
  useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
)
```

9. Add drag end handler per group:
```typescript
const handleDragEnd = (groupKey: string) => (event: DragEndEvent) => {
  const { active, over } = event
  if (!over || active.id === over.id) return

  setLocalOrder((prev) => {
    const items = prev[groupKey] || []
    const oldIndex = items.indexOf(active.id as string)
    const newIndex = items.indexOf(over.id as string)
    if (oldIndex === -1 || newIndex === -1) return prev
    return { ...prev, [groupKey]: arrayMove(items, oldIndex, newIndex) }
  })
}
```

10. Create a SortableNavItem component (inline or extracted) that wraps each nav item row:
```typescript
function SortableNavItem({
  id, item, visible, alwaysOn, localHidden, onToggle, onToggleWithCascade
}: {
  id: string
  item: NavItem
  visible: boolean
  alwaysOn: boolean
  localHidden: string[]
  onToggle: (href: string) => void
  onToggleWithCascade: (item: NavItem) => void
}) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition: sortTransition,
    isDragging,
  } = useSortable({ id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition: sortTransition,
    opacity: isDragging ? 0.5 : 1,
    zIndex: isDragging ? 10 : undefined,
  }

  return (
    <div ref={setNodeRef} style={style}>
      <div className="flex items-center justify-between py-2 px-1">
        <div className="flex items-center gap-2">
          {/* Drag handle */}
          <button
            {...attributes}
            {...listeners}
            className="cursor-grab active:cursor-grabbing p-0.5 text-gray-300 hover:text-gray-500 touch-none"
            aria-label={`Drag to reorder ${item.name}`}
          >
            <GripVertical className="h-4 w-4" />
          </button>
          <item.icon className="h-4 w-4 text-gray-500" />
          <span className="text-sm text-gray-700">{item.name}</span>
          {alwaysOn && (
            <span className="text-xs text-gray-400">(always visible)</span>
          )}
        </div>
        <Switch
          checked={visible}
          onCheckedChange={() =>
            item.children
              ? onToggleWithCascade(item)
              : onToggle(item.href)
          }
          disabled={alwaysOn}
        />
      </div>
      {/* Nested children (not individually sortable) */}
      {item.children && (
        <div className="ml-7 border-l-2 border-gray-100 pl-3 space-y-0.5">
          {item.children.map((child) => {
            const childVisible = !localHidden.includes(child.href) && visible
            return (
              <div
                key={child.href}
                className="flex items-center justify-between py-1.5 px-1"
              >
                <div className="flex items-center gap-3">
                  <child.icon className="h-3.5 w-3.5 text-gray-400" />
                  <span className="text-sm text-gray-600">{child.name}</span>
                </div>
                <Switch
                  checked={childVisible}
                  onCheckedChange={() => onToggle(child.href)}
                  disabled={!visible}
                />
              </div>
            )
          })}
        </div>
      )}
    </div>
  )
}
```

11. Update the nav groups rendering section to use DnD. For each group, wrap items in `DndContext` and `SortableContext`. Use `localOrder[group.key]` to determine the display order of items:

```typescript
{navGroups.map((group) => {
  const orderedHrefs = localOrder[group.key] || group.items.map(i => i.href)
  // Build ordered items list from hrefs, falling back to original for unknown
  const orderedItems = orderedHrefs
    .map(href => group.items.find(i => i.href === href))
    .filter(Boolean) as NavItem[]
  // Append any items not in orderedHrefs (new items)
  for (const item of group.items) {
    if (!orderedHrefs.includes(item.href)) {
      orderedItems.push(item)
    }
  }

  return (
    <div key={group.key}>
      <h4 className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-2">
        {group.label}
      </h4>
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={handleDragEnd(group.key)}
      >
        <SortableContext
          items={orderedItems.map(i => i.href)}
          strategy={verticalListSortingStrategy}
        >
          <div className="space-y-1">
            {orderedItems.map((item) => {
              const alwaysOn = isAlwaysVisible(item.href)
              const visible = alwaysOn || !localHidden.includes(item.href)
              return (
                <SortableNavItem
                  key={item.href}
                  id={item.href}
                  item={item}
                  visible={visible}
                  alwaysOn={alwaysOn}
                  localHidden={localHidden}
                  onToggle={handleToggle}
                  onToggleWithCascade={handleToggleWithCascade}
                />
              )
            })}
          </div>
        </SortableContext>
      </DndContext>
    </div>
  )
})}
```

12. Add a "Reset Order" button in the card footer area (near the Save button). Only show when order is non-default:
```typescript
{(isDirty || isOrderDirty) && (
  <div className="pt-4 border-t border-gray-200 flex gap-2">
    {isOrderDirty && (
      <Button
        variant="outline"
        onClick={handleResetOrder}
        className="flex items-center gap-2"
      >
        <RotateCcw className="h-4 w-4" />
        Reset Order
      </Button>
    )}
    <Button
      onClick={handleSave}
      disabled={isSaving}
      className="flex-1"
    >
      {isSaving ? 'Saving...' : 'Save Changes'}
    </Button>
  </div>
)}
```

Replace the existing `isDirty` save button section with the above.
</task>

<task id="2">
**Apply custom order in desktop sidebar**

In `src/components/layout/sidebar.tsx`:

1. Import `getOrderedItems` from the hook (already using `useNavVisibility`):
```typescript
const { isVisible, getOrderedItems } = useNavVisibility()
```

2. Update the `visibleGroups` memo to apply ordering. The `filterVisible` function passed to `NavGroupComponent` should first order, then filter:
```typescript
const visibleGroups = useMemo(() => {
  return navGroups
    .filter((group) => !group.requireRole || session?.user?.role === group.requireRole)
    .map((group) => {
      const orderedItems = getOrderedItems(group.key, group.items)
      const visibleItems = orderedItems.filter((item) => isVisible(item.href))
      return { group, visibleItems, orderedItems }
    })
    .filter(({ visibleItems }) => visibleItems.length > 0)
}, [session?.user?.role, isVisible, getOrderedItems])
```

3. Update the `filterVisible` prop passed to `NavGroupComponent` to use ordered items:
```typescript
{visibleGroups.map(({ group, visibleItems, orderedItems }) => (
  <NavGroupComponent
    key={group.key}
    group={group}
    visibleCount={visibleItems.length}
    isExpanded={expandedGroups[group.key] ?? true}
    onToggle={() => toggleGroup(group.key)}
    pathname={pathname}
    filterVisible={(items) => {
      const ordered = getOrderedItems(group.key, items)
      return ordered.filter((item) => isVisible(item.href))
    }}
  />
))}
```
</task>

<task id="3">
**Apply custom order in mobile sidebar**

In `src/components/layout/mobile-sidebar.tsx`:

Apply the same changes as the desktop sidebar:

1. Get `getOrderedItems` from the hook:
```typescript
const { isVisible, getOrderedItems } = useNavVisibility()
```

2. Update `visibleGroups` memo to apply ordering before visibility filtering (same pattern as desktop sidebar).

3. Update `filterVisible` prop to order then filter (same pattern as desktop sidebar).
</task>

<task id="4">
**Check @dnd-kit/modifiers availability and handle**

Check if `@dnd-kit/modifiers` is available:
```bash
ls node_modules/@dnd-kit/modifiers 2>/dev/null
```

If NOT available, remove the `restrictToVerticalAxis` and `restrictToParentElement` imports from the Settings page. The DnD will still work without modifiers, just without axis constraint.

If available, add `modifiers={[restrictToVerticalAxis, restrictToParentElement]}` to the `<DndContext>`.
</task>

<task id="5">
**Verify TypeScript compilation and test**

1. Run `npx tsc --noEmit` to verify no type errors
2. Verify the dev server starts: `npm run dev`
3. Manual verification points:
   - Settings page shows drag handles on nav items
   - Dragging reorders within a group
   - Cannot drag between groups (separate DndContext per group)
   - Save button appears after reorder
   - After save, sidebar shows custom order
   - Reset Order button restores default order
   - Mobile sidebar follows same custom order
</task>

## Verification

- [ ] Settings page shows drag handle (GripVertical icon) on each nav item (REORD-01)
- [ ] User can drag to reorder within a group (REORD-02)
- [ ] Items cannot cross group boundaries (separate DndContext per group enforces this) (REORD-03)
- [ ] Save persists order via navItemOrder in UserPreferences (REORD-04)
- [ ] Desktop sidebar renders items in saved custom order (REORD-05)
- [ ] Mobile sidebar renders items in saved custom order (REORD-05)
- [ ] Reset Order button appears when order differs from default and restores default (REORD-06)
- [ ] Children (Departments, Contacts) move with parent Companies item during drag
- [ ] TypeScript compiles without errors
- [ ] Dirty detection covers both visibility changes AND order changes

## must_haves
- Drag handles visible on Settings page items (REORD-01)
- Drag reorder within group works (REORD-02)
- Cross-group drag prevented (REORD-03)
- Custom order persists and sidebar reflects it (REORD-04, REORD-05)
- Reset Order restores default (REORD-06)
