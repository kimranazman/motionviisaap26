# Architecture: v2.1 Collapsible Navigation, Cross-Project Tasks, Member Workload

**Domain:** Navigation UX, cross-project task aggregation, member workload dashboards
**Researched:** 2026-01-27
**Confidence:** HIGH (based on direct codebase analysis of all affected files)

---

## Executive Summary

v2.1 introduces three interconnected features that integrate with the existing Next.js 14 App Router / Prisma / shadcn/ui architecture:

1. **Collapsible sidebar groups** -- Refactoring the sidebar from flat link lists into grouped, collapsible sections using the already-installed `@radix-ui/react-collapsible` (via `src/components/ui/collapsible.tsx`). This also eliminates the navigation duplication between `sidebar.tsx` (desktop) and `mobile-sidebar.tsx` (mobile Sheet).

2. **Cross-project task view** -- A new top-level `/tasks` page that queries tasks across ALL projects (the current Task API is project-scoped: `/api/projects/[id]/tasks`). This requires a new API endpoint (`/api/tasks`) plus two view modes: table and kanban. The existing `@dnd-kit` kanban infrastructure (`kanban-board.tsx`) provides the drag-and-drop pattern, but must be adapted from Initiative-shaped data to Task-shaped data.

3. **Member workload pages** -- A new `/members` or `/team` section showing per-member aggregated workload across Tasks, Initiatives, and SupportTasks. The data already exists (Tasks have `assignee: TeamMember`, Initiatives have `personInCharge: TeamMember`, SupportTasks have `owner: String`) but has never been queried cross-entity.

The key architectural constraint: **Tasks use `TeamMember` enum for `assignee`, Initiatives use `TeamMember` enum for `personInCharge`, but SupportTasks and KeyResults use freeform `String` for `owner`**. This mismatch must be addressed for unified member workload aggregation.

---

## 1. Collapsible Sidebar Architecture

### 1.1 Current State (Problems)

**Problem 1: Navigation duplication.** The navigation items are defined in two separate files:
- `src/components/layout/sidebar.tsx` lines 26-35: `navigation` array (8 items)
- `src/components/layout/mobile-sidebar.tsx` lines 28-45: `navigation` array (8 items) + `crmNavigation` array (5 items)

The desktop sidebar hardcodes each CRM link individually (lines 80-151), while the mobile sidebar uses a `crmNavigation` array. Adding a new nav item means editing both files and keeping them in sync.

**Problem 2: Three separate navigation surfaces.**
- Desktop sidebar (`sidebar.tsx`): Fixed `aside` element, 264px wide, hidden below `md`
- Mobile sidebar (`mobile-sidebar.tsx`): Sheet overlay, triggered by hamburger in header
- Mobile bottom nav (`mobile-nav.tsx`): Fixed bottom bar with 4 key items

**Problem 3: Flat layout does not scale.** The sidebar currently has 8 main items + 6 CRM items + Admin + Settings = 16 items visible. Adding Tasks, Members, and future pages will exceed comfortable scroll height.

### 1.2 Recommended Architecture

#### Single navigation config (shared data)

Create `src/lib/navigation.ts` as the single source of truth:

```typescript
// src/lib/navigation.ts
import { type LucideIcon } from 'lucide-react'

export interface NavItem {
  name: string
  href: string
  icon: LucideIcon
}

export interface NavGroup {
  id: string
  label: string
  defaultOpen?: boolean
  items: NavItem[]
  /** If set, group only renders when condition is met */
  condition?: 'admin-only'
}

export const NAV_GROUPS: NavGroup[] = [
  {
    id: 'planning',
    label: 'Planning',
    defaultOpen: true,
    items: [
      { name: 'Dashboard', href: '/', icon: LayoutDashboard },
      { name: 'By Objective', href: '/objectives', icon: Target },
      { name: 'Timeline', href: '/timeline', icon: GanttChart },
      { name: 'Kanban', href: '/kanban', icon: KanbanSquare },
      { name: 'Calendar', href: '/calendar', icon: Calendar },
    ],
  },
  {
    id: 'work',
    label: 'Work',
    defaultOpen: true,
    items: [
      { name: 'Initiatives', href: '/initiatives', icon: ListTodo },
      { name: 'Tasks', href: '/tasks', icon: CheckSquare },       // NEW
      { name: 'Support Tasks', href: '/support-tasks', icon: ClipboardList },
      { name: 'Members', href: '/members', icon: Users2 },         // NEW
    ],
  },
  {
    id: 'crm',
    label: 'CRM',
    defaultOpen: false,  // collapsed by default
    items: [
      { name: 'Companies', href: '/companies', icon: Building2 },
      { name: 'Pipeline', href: '/pipeline', icon: Funnel },
      { name: 'Potential Projects', href: '/potential-projects', icon: FolderKanban },
      { name: 'Projects', href: '/projects', icon: Briefcase },
      { name: 'Suppliers', href: '/suppliers', icon: Truck },
      { name: 'Price Comparison', href: '/supplier-items', icon: Scale },
    ],
  },
  {
    id: 'events',
    label: 'Events',
    defaultOpen: false,
    items: [
      { name: 'Events to Attend', href: '/events', icon: Ticket },
    ],
  },
  {
    id: 'admin',
    label: 'Admin',
    condition: 'admin-only',
    items: [
      { name: 'Users', href: '/admin/users', icon: Users },
    ],
  },
]

export const BOTTOM_NAV_ITEMS: NavItem[] = [
  { name: 'Dashboard', href: '/', icon: LayoutDashboard },
  { name: 'Initiatives', href: '/initiatives', icon: ListTodo },
  { name: 'Tasks', href: '/tasks', icon: CheckSquare },
  { name: 'CRM', href: '/pipeline', icon: Funnel },
]
```

#### Collapsible sidebar group component

Use the existing `Collapsible` from `@radix-ui/react-collapsible` (`src/components/ui/collapsible.tsx`):

```typescript
// src/components/layout/sidebar-group.tsx
'use client'

import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible'
import { ChevronRight } from 'lucide-react'
import { cn } from '@/lib/utils'

interface SidebarGroupProps {
  label: string
  defaultOpen?: boolean
  children: React.ReactNode
  isActive?: boolean  // true if any child link is active
}

export function SidebarGroup({ label, defaultOpen, children, isActive }: SidebarGroupProps) {
  return (
    <Collapsible defaultOpen={defaultOpen}>
      <CollapsibleTrigger className="w-full flex items-center justify-between px-3 py-1.5 text-xs font-semibold text-gray-400 uppercase tracking-wider hover:text-gray-600 transition-colors">
        {label}
        <ChevronRight className="h-3 w-3 transition-transform duration-200 [[data-state=open]>&]:rotate-90" />
      </CollapsibleTrigger>
      <CollapsibleContent>
        <div className="flex flex-col gap-0.5 mt-1">
          {children}
        </div>
      </CollapsibleContent>
    </Collapsible>
  )
}
```

#### Collapse state persistence

Use `localStorage` to remember which groups are open/closed. This is already the pattern established by `use-detail-view-mode.ts`:

```typescript
// src/lib/hooks/use-sidebar-state.ts
'use client'
import { useState, useCallback, useEffect } from 'react'

const STORAGE_KEY = 'sidebar-groups'

export function useSidebarState(groups: { id: string; defaultOpen?: boolean }[]) {
  const [openGroups, setOpenGroups] = useState<Record<string, boolean>>(() => {
    // Initialize with defaults
    const defaults: Record<string, boolean> = {}
    groups.forEach(g => { defaults[g.id] = g.defaultOpen ?? true })
    return defaults
  })

  // Hydrate from localStorage on mount
  useEffect(() => {
    const stored = localStorage.getItem(STORAGE_KEY)
    if (stored) {
      try { setOpenGroups(JSON.parse(stored)) } catch {}
    }
  }, [])

  const toggle = useCallback((groupId: string) => {
    setOpenGroups(prev => {
      const next = { ...prev, [groupId]: !prev[groupId] }
      localStorage.setItem(STORAGE_KEY, JSON.stringify(next))
      return next
    })
  }, [])

  return { openGroups, toggle }
}
```

### 1.3 Component Boundaries

| Component | File | Responsibility |
|-----------|------|----------------|
| `navigation.ts` | `src/lib/navigation.ts` | Single source of truth for all nav config |
| `SidebarGroup` | `src/components/layout/sidebar-group.tsx` | Collapsible wrapper using Radix primitive |
| `SidebarLink` | `src/components/layout/sidebar-link.tsx` | Single nav link with active state detection |
| `Sidebar` | `src/components/layout/sidebar.tsx` | **REWRITE**: Consume `NAV_GROUPS`, render `SidebarGroup` instances |
| `MobileSidebar` | `src/components/layout/mobile-sidebar.tsx` | **REWRITE**: Consume same `NAV_GROUPS`, Sheet wrapper |
| `MobileNav` | `src/components/layout/mobile-nav.tsx` | **UPDATE**: Consume `BOTTOM_NAV_ITEMS` from config |
| `useSidebarState` | `src/lib/hooks/use-sidebar-state.ts` | Persist open/closed group state in localStorage |

### 1.4 Data Flow

```
navigation.ts (NAV_GROUPS config)
    |
    +---> Sidebar.tsx (desktop)
    |       |
    |       +---> SidebarGroup (per group)
    |               |
    |               +---> SidebarLink (per item)
    |
    +---> MobileSidebar.tsx (Sheet)
    |       |
    |       +---> SidebarGroup (per group)
    |               |
    |               +---> SidebarLink (per item)
    |
    +---> MobileNav.tsx (bottom bar)
            |
            +---> Uses BOTTOM_NAV_ITEMS (flat list, no groups)
```

### 1.5 Key Decisions

**Use Radix Collapsible, NOT custom accordion.** The `@radix-ui/react-collapsible` primitive is already installed and registered as a shadcn/ui component. It handles animation, accessibility (ARIA), and keyboard navigation. No need to add `@radix-ui/react-accordion` -- Collapsible is the correct primitive when groups are independently open/closable (accordion enforces single-open).

**Do NOT add sidebar collapse/minimize (drawer mode).** A full sidebar collapse (hiding labels, showing only icons) is a common request but adds significant complexity: icon-only rendering, tooltip labels, width transition animation, layout shift handling. The sidebar is already hidden on mobile. Keep it simple for v2.1 -- collapsible GROUPS within the sidebar, not collapsing the sidebar itself.

**Auto-open active group on navigation.** When the user navigates to a page whose link is in a collapsed group, that group should auto-open. Detect this by checking `pathname` against group items during render.

---

## 2. Cross-Project Task View Architecture

### 2.1 Current State (Problems)

**Problem: Tasks are only accessible within a project context.** The current architecture:
- API: `GET /api/projects/[id]/tasks` -- scoped to one project
- UI: `TaskTree` component embedded inside project detail sheet/page
- No standalone task page exists at the top level

There is no way to see "all my tasks across all projects" or "all overdue tasks" without opening each project individually.

### 2.2 New API Endpoint

Create a new cross-project task API:

```
GET /api/tasks
  ?assignee=KHAIRUL         (filter by assignee)
  &status=TODO,IN_PROGRESS  (comma-separated statuses)
  &priority=HIGH             (filter by priority)
  &projectId=xxx             (filter by specific project)
  &search=keyword            (search title/description)
  &sort=dueDate              (sort field)
  &order=asc                 (sort direction)
```

**API route file:** `src/app/api/tasks/route.ts`

#### Prisma Query Strategy

```typescript
// Cross-project task query with filters
const tasks = await prisma.task.findMany({
  where: {
    ...(assignee ? { assignee: assignee as TeamMember } : {}),
    ...(status ? { status: { in: statusArray as TaskStatus[] } } : {}),
    ...(priority ? { priority: priority as TaskPriority } : {}),
    ...(projectId ? { projectId } : {}),
    ...(search ? {
      OR: [
        { title: { contains: search } },
        { description: { contains: search } },
      ]
    } : {}),
    // Only top-level tasks for kanban/table (subtasks shown on drill-in)
    parentId: null,
  },
  include: {
    project: { select: { id: true, title: true } },
    tags: { include: { tag: true } },
    _count: { select: { children: true, comments: true } },
  },
  orderBy: sortField
    ? { [sortField]: sortOrder }
    : [{ dueDate: 'asc' }, { priority: 'desc' }],
})
```

**Critical: Query only top-level tasks (parentId: null) for the cross-project view.** The flat task list should show root tasks with a subtask count badge. Clicking a task opens its detail sheet where the subtask hierarchy is visible. This avoids the N+1 problem of loading full task trees across all projects.

### 2.3 Cross-Project Task Page

**Route:** `src/app/(dashboard)/tasks/page.tsx`

**Server Component page pattern** (matching existing pages like `kanban/page.tsx`):

```typescript
// src/app/(dashboard)/tasks/page.tsx
export const dynamic = 'force-dynamic'

async function getAllTasks() {
  const tasks = await prisma.task.findMany({
    where: { parentId: null },
    include: {
      project: { select: { id: true, title: true } },
      tags: { include: { tag: true } },
      _count: { select: { children: true, comments: true } },
    },
    orderBy: [{ dueDate: 'asc' }, { createdAt: 'desc' }],
  })
  return tasks.map(serializeTask)
}

export default async function TasksPage() {
  const tasks = await getAllTasks()
  return (
    <div className="min-h-screen bg-gray-50">
      <Header title="Tasks" description="All tasks across projects" />
      <div className="p-6">
        <CrossProjectTaskView initialData={tasks} />
      </div>
    </div>
  )
}
```

### 2.4 Dual View: Table + Kanban

**Client component:** `src/components/tasks/cross-project-task-view.tsx`

This component provides two view modes via tabs (matching existing `KanbanBoard` viewMode pattern):

#### Table View

Use native HTML `<table>` with shadcn/ui styling (matching the pattern in the project list). Do NOT add `@tanstack/react-table` -- the task table is a straightforward list with sorting and filtering that does not require headless table machinery. The existing codebase has no `@tanstack/react-table` dependency and adding it for a single table is unnecessary.

Table columns:
| Column | Source | Notes |
|--------|--------|-------|
| Title | `task.title` | Clickable, opens detail sheet |
| Project | `task.project.title` | Badge or link |
| Status | `task.status` | Color-coded badge (reuse `getTaskStatusColor`) |
| Priority | `task.priority` | Color-coded badge (reuse `getTaskPriorityColor`) |
| Assignee | `task.assignee` | Avatar/name (reuse `formatTeamMember`) |
| Due Date | `task.dueDate` | Formatted, red if overdue |
| Subtasks | `task._count.children` | Count badge |

Sorting: Client-side sort on column header click. With a 3-person team and moderate project count, the total task set will be small enough (likely <200 root tasks) that client-side sort is fine.

#### Kanban View

Adapt the existing `@dnd-kit` kanban pattern from `kanban-board.tsx`. The adaptation is structural, not from-scratch:

| Existing (Initiatives) | New (Tasks) |
|------------------------|-------------|
| `COLUMNS` with `InitiativeStatus` grouping | `COLUMNS` with `TaskStatus` grouping (TODO, IN_PROGRESS, DONE) |
| `KanbanCard` shows initiative fields | `TaskKanbanCard` shows task + project badge |
| `handleDragEnd` PATCHes `/api/initiatives/{id}` | `handleDragEnd` PATCHes `/api/projects/{projectId}/tasks/{taskId}` |
| Swimlane view by person | Swimlane view by project OR by person |

**Three columns** (matching `TaskStatus` enum):
1. **To Do** - `TODO` status
2. **In Progress** - `IN_PROGRESS` status
3. **Done** - `DONE` status

**Swimlane options** (toggle):
- **By Person** -- Group cards by `assignee` (reuse `KanbanSwimlaneView` pattern)
- **By Project** -- Group cards by `project.title`

### 2.5 Component Boundaries

| Component | File | Responsibility |
|-----------|------|----------------|
| `CrossProjectTaskView` | `src/components/tasks/cross-project-task-view.tsx` | View mode toggle (table/kanban), filter state |
| `TaskTable` | `src/components/tasks/task-table.tsx` | Table view with sortable columns |
| `TaskKanbanBoard` | `src/components/tasks/task-kanban-board.tsx` | DnD kanban (adapt from `kanban-board.tsx`) |
| `TaskKanbanCard` | `src/components/tasks/task-kanban-card.tsx` | Card showing task + project context |
| `TaskFilterBar` | `src/components/tasks/task-filter-bar.tsx` | Filters: assignee, status, priority, project, search |
| `TaskDetailSheet` | **REUSE** `src/components/projects/task-detail-sheet.tsx` | Already exists, needs minor update to accept cross-project context |

### 2.6 Data Flow

```
tasks/page.tsx (Server Component)
  |
  +---> Prisma query: all root tasks with project includes
  |
  +---> CrossProjectTaskView (Client Component)
          |
          +---> TaskFilterBar
          |       |
          |       +---> Filters: assignee, status, priority, project, search
          |
          +---> [Table Mode] TaskTable
          |       |
          |       +---> Rows with sortable columns
          |       +---> onClick -> TaskDetailSheet
          |
          +---> [Kanban Mode] TaskKanbanBoard
                  |
                  +---> DndContext + SortableContext
                  +---> 3 columns (TODO, IN_PROGRESS, DONE)
                  +---> TaskKanbanCard per task
                  +---> onDragEnd -> PATCH /api/projects/{pid}/tasks/{tid}
                  +---> onClick -> TaskDetailSheet
```

### 2.7 Task Status Update from Cross-Project View

**Challenge:** The existing task PATCH endpoint is project-scoped: `PATCH /api/projects/[id]/tasks/[taskId]`. Each task in the cross-project view carries its `projectId`, so the kanban drag handler must construct the URL dynamically:

```typescript
// In TaskKanbanBoard
const handleDragEnd = async (event: DragEndEvent) => {
  const task = findTask(event.active.id)
  if (!task) return

  // Use task's own projectId for the API call
  await fetch(`/api/projects/${task.projectId}/tasks/${task.id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ status: newStatus }),
  })
}
```

**Alternative: Add a top-level task PATCH endpoint.** `PATCH /api/tasks/[taskId]` that internally resolves the project. This is cleaner for the cross-project view but adds another API surface. **Recommendation: Add it.** The `projectId` is already on the task record, so the route can look it up. This also simplifies the member workload page which also needs to update tasks.

```typescript
// src/app/api/tasks/[taskId]/route.ts
export async function PATCH(request, { params }) {
  const { taskId } = await params
  const body = await request.json()

  const task = await prisma.task.update({
    where: { id: taskId },
    data: {
      ...(body.status ? { status: body.status } : {}),
      ...(body.assignee !== undefined ? { assignee: body.assignee } : {}),
      // other updatable fields
    },
  })

  return NextResponse.json(task)
}
```

---

## 3. Member Workload Architecture

### 3.1 Data Model Analysis

The assignee/owner fields across models are inconsistent:

| Model | Field | Type | Example Values |
|-------|-------|------|----------------|
| `Task` | `assignee` | `TeamMember?` (enum) | `KHAIRUL`, `AZLAN`, `IZYANI`, `null` |
| `Initiative` | `personInCharge` | `TeamMember?` (enum) | `KHAIRUL`, `AZLAN`, `IZYANI`, `null` |
| `Initiative` | `accountable` | `TeamMember?` (enum) | Same as above |
| `KeyResult` | `owner` | `String` (varchar) | Freeform text |
| `SupportTask` | `owner` | `String` (varchar) | Freeform text |

**Problem:** KR `owner` and SupportTask `owner` are freeform strings, not the `TeamMember` enum. The v2.0 Prisma schema explicitly chose `String` for these fields (noted in comments: "String per requirements, not TeamMember enum"). This means member workload aggregation for KRs and SupportTasks requires fuzzy matching or a mapping function.

**Recommendation:** Create a mapping utility that normalizes owner strings to `TeamMember` enum values:

```typescript
// src/lib/member-utils.ts
import { TeamMember } from '@prisma/client'

const OWNER_TO_MEMBER: Record<string, TeamMember> = {
  'Khairul': 'KHAIRUL',
  'khairul': 'KHAIRUL',
  'KHAIRUL': 'KHAIRUL',
  'Azlan': 'AZLAN',
  'azlan': 'AZLAN',
  'AZLAN': 'AZLAN',
  'Izyani': 'IZYANI',
  'izyani': 'IZYANI',
  'IZYANI': 'IZYANI',
}

export function resolveOwnerToMember(owner: string | null): TeamMember | null {
  if (!owner) return null
  return OWNER_TO_MEMBER[owner.trim()] ?? null
}
```

For a 3-person team, this is the simplest correct approach. If the team grows, consider migrating `KeyResult.owner` and `SupportTask.owner` to use the `TeamMember` enum, but that is a schema migration best deferred.

### 3.2 Member Workload Page

**Route:** `src/app/(dashboard)/members/page.tsx`

The page serves as an overview listing all team members with aggregated workload stats, and individual member pages showing detailed breakdown.

#### Overview (All Members)

```
/members         -- Overview grid/list of all team members
/members/KHAIRUL -- Khairul's detail workload page
/members/AZLAN   -- Azlan's detail workload page
/members/IZYANI  -- Izyani's detail workload page
```

**Alternative route considered:** `/team` instead of `/members`. Using `/members` because it's more specific and avoids confusion with a potential future "Team Settings" page.

#### Server Component Data Fetching

The member overview page aggregates across all entity types:

```typescript
// src/app/(dashboard)/members/page.tsx
async function getMemberWorkloads() {
  const members = ['KHAIRUL', 'AZLAN', 'IZYANI'] as TeamMember[]

  const workloads = await Promise.all(members.map(async (member) => {
    const [tasks, initiatives, supportTasks] = await Promise.all([
      // Active tasks assigned to member
      prisma.task.groupBy({
        by: ['status'],
        where: { assignee: member, parentId: null },
        _count: true,
      }),

      // Active initiatives where member is PIC
      prisma.initiative.groupBy({
        by: ['status'],
        where: { personInCharge: member },
        _count: true,
      }),

      // Support tasks owned by member (string match)
      prisma.supportTask.count({
        where: { owner: { contains: formatTeamMember(member) } },
      }),
    ])

    return {
      member,
      tasks: {
        todo: tasks.find(t => t.status === 'TODO')?._count ?? 0,
        inProgress: tasks.find(t => t.status === 'IN_PROGRESS')?._count ?? 0,
        done: tasks.find(t => t.status === 'DONE')?._count ?? 0,
      },
      initiatives: {
        notStarted: initiatives.find(i => i.status === 'NOT_STARTED')?._count ?? 0,
        inProgress: initiatives.find(i => i.status === 'IN_PROGRESS')?._count ?? 0,
        atRisk: initiatives.find(i => i.status === 'AT_RISK')?._count ?? 0,
        completed: initiatives.find(i => i.status === 'COMPLETED')?._count ?? 0,
      },
      supportTaskCount: supportTasks,
    }
  }))

  return workloads
}
```

### 3.3 Member Detail Page

**Route:** `src/app/(dashboard)/members/[member]/page.tsx`

Shows all work items for a specific team member, organized by type:

| Section | Data Source | Display |
|---------|------------|---------|
| **Tasks** | `prisma.task.findMany({ where: { assignee: member } })` | Grouped by project, status badges |
| **Initiatives** | `prisma.initiative.findMany({ where: { personInCharge: member } })` | Status/department badges, timeline |
| **Key Results** | `prisma.keyResult.findMany({ where: { owner: { contains: name } } })` | Progress bars, target/actual |
| **Support Tasks** | `prisma.supportTask.findMany({ where: { owner: { contains: name } } })` | Category badges, priority |

#### URL Parameter Design

Use the `TeamMember` enum value as the URL segment:

```
/members/KHAIRUL  (not /members/khairul or /members/1)
```

This keeps URLs consistent with how `TeamMember` is stored in the database and avoids a lookup step. Validate the param against the enum in the Server Component:

```typescript
// src/app/(dashboard)/members/[member]/page.tsx
import { TeamMember } from '@prisma/client'

export default async function MemberDetailPage({
  params,
}: {
  params: Promise<{ member: string }>
}) {
  const { member } = await params

  // Validate member is a valid TeamMember
  if (!Object.values(TeamMember).includes(member as TeamMember)) {
    notFound()
  }

  const memberEnum = member as TeamMember
  // ... fetch workload data
}
```

### 3.4 Component Boundaries

| Component | File | Responsibility |
|-----------|------|----------------|
| `MemberOverview` | `src/components/members/member-overview.tsx` | Grid of member cards with stats |
| `MemberCard` | `src/components/members/member-card.tsx` | Single member summary card |
| `MemberWorkload` | `src/components/members/member-workload.tsx` | Detail view: all work items for one member |
| `MemberTaskList` | `src/components/members/member-task-list.tsx` | Tasks section in member detail |
| `MemberInitiativeList` | `src/components/members/member-initiative-list.tsx` | Initiatives section |
| `MemberSupportList` | `src/components/members/member-support-list.tsx` | Support tasks section |
| `resolveOwnerToMember` | `src/lib/member-utils.ts` | Owner string -> TeamMember mapping |

### 3.5 Data Flow

```
members/page.tsx (Server Component)
  |
  +---> Promise.all: tasks + initiatives + supportTasks per member
  |
  +---> MemberOverview (Client Component)
          |
          +---> MemberCard (per member)
                  |
                  +---> Link to /members/[member]

members/[member]/page.tsx (Server Component)
  |
  +---> Parallel queries: tasks, initiatives, keyResults, supportTasks
  |
  +---> MemberWorkload (Client Component)
          |
          +---> MemberTaskList
          +---> MemberInitiativeList
          +---> MemberSupportList
```

---

## 4. Patterns to Follow

### Pattern 1: Server Component Page + Client View Component

Every existing page follows this pattern:

```typescript
// page.tsx (Server Component)
export const dynamic = 'force-dynamic'

async function getData() {
  const data = await prisma.xxx.findMany({ ... })
  return data.map(serializeForClient)
}

export default async function XxxPage() {
  const data = await getData()
  return (
    <div className="min-h-screen bg-gray-50">
      <Header title="..." description="..." />
      <div className="p-6">
        <ClientView initialData={data} />
      </div>
    </div>
  )
}
```

The new pages (Tasks, Members, Member Detail) MUST follow this exact pattern.

### Pattern 2: Optimistic UI Updates

The kanban board (`kanban-board.tsx`) demonstrates the optimistic update pattern:

1. Update local state immediately (`setInitiatives(prev => ...)`)
2. Fire API call in background
3. Log errors but do not revert (acceptable for 3-user internal tool)

The task kanban MUST follow the same pattern.

### Pattern 3: Filter State in Client Component

Filters are managed in client-side state, not URL search params:

```typescript
const [searchQuery, setSearchQuery] = useState('')
const [selectedPerson, setSelectedPerson] = useState<string | null>(null)

const filteredData = useMemo(() => {
  return data.filter(item => {
    if (searchQuery && !item.title.toLowerCase().includes(searchQuery.toLowerCase())) return false
    if (selectedPerson && item.assignee !== selectedPerson) return false
    return true
  })
}, [data, searchQuery, selectedPerson])
```

This pattern is used in `kanban-board.tsx` and should be followed for the task view. Exception: the member detail page should use the URL segment for member identity (it IS a route parameter, not a filter).

### Pattern 4: View Mode Toggle with Tabs

The kanban page has board/by-person toggle. The task page should use the same UI pattern:

```typescript
<Tabs value={viewMode} onValueChange={v => setViewMode(v as ViewMode)}>
  <TabsList>
    <TabsTrigger value="table">Table</TabsTrigger>
    <TabsTrigger value="kanban">Kanban</TabsTrigger>
  </TabsList>
</Tabs>
```

---

## 5. Anti-Patterns to Avoid

### Anti-Pattern 1: Fetching full task trees cross-project

**What:** Loading all tasks including subtask hierarchies for the cross-project view.

**Why bad:** Task depth goes to 5 levels. Loading full trees across N projects creates an N * depth explosion. Most cross-project views only need root-level tasks with subtask counts.

**Instead:** Query `WHERE parentId IS NULL` with `_count: { select: { children: true } }`. Drill into subtask trees only on task detail sheet open.

### Anti-Pattern 2: Adding `@tanstack/react-table` for a single table

**What:** Installing a headless table library for the task table.

**Why bad:** Adds ~30KB gzipped, requires learning its API, and the task table has at most 7 columns with simple sort/filter. The existing codebase has zero table library usage.

**Instead:** Plain `<table>` with manual column header click handlers for sorting. If future pages also need complex tables, revisit then.

### Anti-Pattern 3: Building a sidebar component library

**What:** Creating an elaborate sidebar system with resize handles, dock/undock, icon-only mode, nested sub-navigation, etc.

**Why bad:** This is a 3-person internal tool. Complex sidebar UX adds no value and significant maintenance burden.

**Instead:** Collapsible groups using Radix Collapsible. Fixed 256px width. No fancy animations beyond the collapse/expand.

### Anti-Pattern 4: Duplicating existing task components for cross-project use

**What:** Creating entirely new `TaskCard`, `TaskForm`, `TaskDetailSheet` components for the cross-project view.

**Why bad:** The existing `src/components/projects/task-*` components already handle task display, editing, and detail views. Duplicating them means double maintenance.

**Instead:** Reuse existing components. The main change is adding `project` context display (project name badge) to the card and making `TaskDetailSheet` work when opened from outside a project detail page.

### Anti-Pattern 5: Real-time workload with websockets

**What:** Building a real-time member workload dashboard that updates when tasks change.

**Why bad:** 3 users, internal tool. Server-sent events or websockets add deployment complexity (long-lived connections) for near-zero benefit.

**Instead:** Static server-rendered page with `force-dynamic`. Data is fresh on each navigation. Add a "Refresh" button if needed.

---

## 6. Dependency Graph and Build Order

### 6.1 Dependency Map

```
[1] Navigation Config (navigation.ts)
     |
     +---> [2a] SidebarGroup component
     |      |
     |      +---> [3a] Sidebar rewrite (desktop)
     |      |
     |      +---> [3b] MobileSidebar rewrite (sheet)
     |
     +---> [2b] MobileNav update (bottom bar)

[4] Cross-Project Task API (/api/tasks)
     |
     +---> [5a] TaskTable component
     |      |
     |      +---> [6] CrossProjectTaskView (tab container)
     |
     +---> [5b] TaskKanbanBoard component (adapt from kanban-board.tsx)
     |      |
     |      +---> [6] CrossProjectTaskView (tab container)
     |
     +---> [7] /tasks page (Server Component)

[8] Top-level task PATCH API (/api/tasks/[taskId])
     |
     +---> Used by [5b] TaskKanbanBoard

[9] Member Utils (member-utils.ts)
     |
     +---> [10a] MemberOverview + MemberCard
     |      |
     |      +---> [11] /members page
     |
     +---> [10b] MemberWorkload + sub-lists
            |
            +---> [12] /members/[member] page
```

### 6.2 Recommended Build Order

**Phase A: Navigation (no data model changes)**

| Step | Task | Dependencies | Files |
|------|------|-------------|-------|
| A1 | Create `navigation.ts` config | None | `src/lib/navigation.ts` |
| A2 | Create `SidebarGroup` + `SidebarLink` | A1 | `src/components/layout/sidebar-group.tsx`, `sidebar-link.tsx` |
| A3 | Create `useSidebarState` hook | None | `src/lib/hooks/use-sidebar-state.ts` |
| A4 | Rewrite `Sidebar` to use groups | A1, A2, A3 | `src/components/layout/sidebar.tsx` |
| A5 | Rewrite `MobileSidebar` to use groups | A1, A2 | `src/components/layout/mobile-sidebar.tsx` |
| A6 | Update `MobileNav` to use config | A1 | `src/components/layout/mobile-nav.tsx` |

**Phase B: Cross-Project Task View**

| Step | Task | Dependencies | Files |
|------|------|-------------|-------|
| B1 | Create `/api/tasks` GET endpoint | None (Prisma schema unchanged) | `src/app/api/tasks/route.ts` |
| B2 | Create `/api/tasks/[taskId]` PATCH | None | `src/app/api/tasks/[taskId]/route.ts` |
| B3 | Create `TaskFilterBar` | None | `src/components/tasks/task-filter-bar.tsx` |
| B4 | Create `TaskTable` | B1 (data shape) | `src/components/tasks/task-table.tsx` |
| B5 | Create `TaskKanbanCard` | None | `src/components/tasks/task-kanban-card.tsx` |
| B6 | Create `TaskKanbanBoard` | B2, B5, existing @dnd-kit | `src/components/tasks/task-kanban-board.tsx` |
| B7 | Create `CrossProjectTaskView` | B3, B4, B6 | `src/components/tasks/cross-project-task-view.tsx` |
| B8 | Create `/tasks` page | B7 | `src/app/(dashboard)/tasks/page.tsx` |

**Phase C: Member Workload**

| Step | Task | Dependencies | Files |
|------|------|-------------|-------|
| C1 | Create `member-utils.ts` | None | `src/lib/member-utils.ts` |
| C2 | Create `MemberCard` | C1 | `src/components/members/member-card.tsx` |
| C3 | Create `MemberOverview` | C2 | `src/components/members/member-overview.tsx` |
| C4 | Create `/members` page | C3 | `src/app/(dashboard)/members/page.tsx` |
| C5 | Create member detail sub-components | C1, existing task/initiative components | `src/components/members/member-*.tsx` |
| C6 | Create `MemberWorkload` | C5 | `src/components/members/member-workload.tsx` |
| C7 | Create `/members/[member]` page | C6 | `src/app/(dashboard)/members/[member]/page.tsx` |

### 6.3 Phase Ordering Rationale

**A before B/C:** Navigation changes are foundational -- the Tasks and Members links need somewhere to live. Also, navigation refactoring is low-risk (no data model changes) and provides immediate visible improvement.

**B before C:** Member workload depends on understanding the task data shape. Building the cross-project task view first establishes the API pattern and component structure that the member detail page reuses (member task list is essentially a filtered cross-project task view).

**B and C are independent in implementation** but share the concept of cross-entity aggregation. A developer could work on both in parallel after A is complete, but for a single-developer workflow, B-then-C is recommended because C can reuse B's components.

---

## 7. File Inventory

### New Files (17 files)

| File | Purpose | Phase |
|------|---------|-------|
| `src/lib/navigation.ts` | Shared nav config | A |
| `src/components/layout/sidebar-group.tsx` | Collapsible group wrapper | A |
| `src/components/layout/sidebar-link.tsx` | Single nav link | A |
| `src/lib/hooks/use-sidebar-state.ts` | Persist group collapse state | A |
| `src/app/api/tasks/route.ts` | Cross-project task GET | B |
| `src/app/api/tasks/[taskId]/route.ts` | Top-level task PATCH | B |
| `src/components/tasks/cross-project-task-view.tsx` | View container (table + kanban) | B |
| `src/components/tasks/task-table.tsx` | Table view | B |
| `src/components/tasks/task-kanban-board.tsx` | Kanban view | B |
| `src/components/tasks/task-kanban-card.tsx` | Kanban card | B |
| `src/components/tasks/task-filter-bar.tsx` | Filter bar | B |
| `src/app/(dashboard)/tasks/page.tsx` | Tasks page | B |
| `src/lib/member-utils.ts` | Owner -> TeamMember mapping | C |
| `src/components/members/member-overview.tsx` | Member grid | C |
| `src/components/members/member-card.tsx` | Member summary card | C |
| `src/components/members/member-workload.tsx` | Detail workload view | C |
| `src/app/(dashboard)/members/page.tsx` | Members overview page | C |
| `src/app/(dashboard)/members/[member]/page.tsx` | Member detail page | C |

### Modified Files (4 files)

| File | Change | Phase |
|------|--------|-------|
| `src/components/layout/sidebar.tsx` | Rewrite to use `NAV_GROUPS` + `SidebarGroup` | A |
| `src/components/layout/mobile-sidebar.tsx` | Rewrite to use `NAV_GROUPS` + `SidebarGroup` | A |
| `src/components/layout/mobile-nav.tsx` | Use `BOTTOM_NAV_ITEMS` from config | A |
| `src/components/projects/task-detail-sheet.tsx` | Minor: handle cross-project context (optional project info display) | B |

### Schema Changes

**None.** v2.1 introduces no Prisma schema changes. All data models already exist. The cross-project task view queries existing Task records. The member workload page queries existing data across models. No migration needed.

---

## 8. Scalability Considerations

| Concern | Current (3 users, ~10 projects) | At 50 projects | At 500 projects |
|---------|--------------------------------|----------------|-----------------|
| Cross-project task query | Fine (<200 root tasks) | May need pagination | Needs server-side pagination + cursor |
| Member workload aggregation | Fine (3 members, ~100 items total) | Add caching | Add caching + background computation |
| Sidebar render | Fine (16 items) | Fine even with 30 items | Consider virtual scroll |
| Task kanban columns | Fine (<50 cards per column) | Fine (<200 total) | Virtual scroll kanban columns |

**For v2.1:** No performance optimizations needed. The data scale is small. Client-side filtering and sorting are adequate.

---

## 9. Sources

- **Codebase analysis (HIGH confidence):** Direct reading of all files referenced above
- **@radix-ui/react-collapsible:** Already installed and available at `src/components/ui/collapsible.tsx`
- **@dnd-kit/core + @dnd-kit/sortable:** Already installed, used in `kanban-board.tsx`
- **Prisma Task model:** Schema at `prisma/schema.prisma` lines 707-741
- **TeamMember enum:** Used by Task.assignee, Initiative.personInCharge, Initiative.accountable
- **Owner string fields:** KeyResult.owner and SupportTask.owner are `String` type (not enum)
