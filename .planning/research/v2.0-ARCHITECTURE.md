# Architecture: v2.0 OKR Restructure Integration

**Domain:** OKR hierarchy refactor, support task model, seed migration, revenue dashboard
**Researched:** 2026-01-27
**Confidence:** HIGH (based on direct codebase analysis of all affected files)

---

## Executive Summary

v2.0 transforms the OKR data model from a flat Initiative-centric structure (KR is a string field on Initiative) to a proper relational hierarchy (KeyResult is a first-class model with metrics). This is a **breaking schema change** that requires careful migration: the `keyResult` string field becomes a foreign key to a new `KeyResult` model, the initiative-level KPI fields are removed (replaced by KR-level metrics), and a new `SupportTask` model is introduced with many-to-many KR linkage.

The impact radiates outward from the schema change:
- **Data layer**: 2 new models (KeyResult, SupportTask), 1 join table, Initiative field changes
- **Grouping utilities**: Rewrite from string-based grouping to relation-based
- **UI components**: KeyResultGroup shows real metrics instead of aggregated initiative KPIs
- **Dashboard**: New revenue-target widget, dashboard stats API overhaul
- **Seed script**: Complete rewrite to handle 4 sheets (KRs, Initiatives, SupportTasks, EventsToAttend)

---

## 1. Prisma Schema Changes

### 1.1 New Models

#### KeyResult Model
```prisma
model KeyResult {
  id          String          @id @default(cuid())
  krId        String          @unique @db.VarChar(20) // "KR1.1", "KR2.3", etc.
  objective   Objective
  description String          @db.VarChar(500)
  metricType  MetricType      // Revenue or Count
  target      Decimal         @db.Decimal(12, 2)
  actual      Decimal         @default(0) @db.Decimal(12, 2)
  unit        String          @db.VarChar(50) // "RM", "clients", "programs", etc.
  progress    Decimal         @default(0) @db.Decimal(5, 2) // 0-100 percentage
  deadline    String          @db.VarChar(50) // "Q4 2026", "Dec 2026", etc.
  status      InitiativeStatus @default(NOT_STARTED)
  owner       TeamMember?
  howWeMeasure String?        @map("how_we_measure") @db.Text
  notes       String?         @db.Text
  weight      Decimal?        @db.Decimal(5, 2) // weighting for objective-level rollup

  initiatives Initiative[]
  supportTaskLinks SupportTaskKeyResult[]

  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([objective])
  @@index([status])
  @@index([owner])
  @@map("key_results")
}
```

#### SupportTask Model
```prisma
model SupportTask {
  id          String           @id @default(cuid())
  category    SupportTaskCategory
  task        String           @db.VarChar(500)
  owner       TeamMember?
  frequency   String?          @db.VarChar(100) // "Weekly", "Monthly", "Ongoing", etc.
  priority    TaskPriority     @default(MEDIUM)
  notes       String?          @db.Text

  keyResultLinks SupportTaskKeyResult[]

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([category])
  @@index([owner])
  @@map("support_tasks")
}
```

#### Join Table: SupportTask <-> KeyResult (Many-to-Many)
```prisma
model SupportTaskKeyResult {
  id            String      @id @default(cuid())

  supportTaskId String      @map("support_task_id")
  supportTask   SupportTask @relation(fields: [supportTaskId], references: [id], onDelete: Cascade)

  keyResultId   String      @map("key_result_id")
  keyResult     KeyResult   @relation(fields: [keyResultId], references: [id], onDelete: Cascade)

  createdAt     DateTime    @default(now())

  @@unique([supportTaskId, keyResultId])
  @@index([supportTaskId])
  @@index([keyResultId])
  @@map("support_task_key_results")
}
```

### 1.2 New Enums

```prisma
enum MetricType {
  REVENUE
  COUNT
}

enum SupportTaskCategory {
  ADMIN_OPS
  MARKETING_COMMS
  LEARNING_DEV
  FINANCIAL_TRACKING
}
```

**Rationale for SupportTaskCategory values:** The Excel defines 4 categories: "Admin & Ops", "Marketing & Comms", "Learning & Dev", "Financial Tracking". These become enum values. Using underscores and abbreviations matches existing enum conventions in the codebase (e.g., `BIZ_DEV`, `OBJ1_SCALE_EVENTS`).

### 1.3 Initiative Model Changes

**Fields to ADD:**
```prisma
  // Replace string keyResult with FK relation
  keyResultId       String?       @map("key_result_id")
  keyResultRef      KeyResult?    @relation(fields: [keyResultId], references: [id])

  // New fields from v2 Excel
  budget            Decimal?      @db.Decimal(12, 2)  // Replaces resourcesFinancial (clearer name)
  resources         String?       @db.Text             // Replaces resourcesNonFinancial (clearer name)
```

**Fields to REMOVE:**
```
  keyResult         String        @db.VarChar(20)     // -> keyResultId FK
  monthlyObjective  String?       @db.Text            // Not in v2 Excel
  weeklyTasks       String?       @db.Text            // Not in v2 Excel
  resourcesFinancial    Decimal?  @db.Decimal(12, 2)  // -> budget
  resourcesNonFinancial String?   @db.Text            // -> resources

  // KPI fields (moved to KeyResult level)
  kpiLabel          String?
  kpiTarget         Decimal?
  kpiActual         Decimal?
  kpiUnit           String?
  kpiManualOverride Boolean
```

**Fields to ADD (from v2 Excel context):**
```prisma
  accountable       TeamMember?   // Already exists! Keep as-is
```

**Important: `accountable` already exists on Initiative.** No change needed there.

### 1.4 Full Impact on Existing Initiative Fields

| Current Field | v2.0 Action | Rationale |
|---|---|---|
| `id` | Keep | Primary key |
| `sequenceNumber` | Keep | Ordering |
| `objective` | Keep | Still on Initiative (matches KR's objective) |
| `keyResult` (String) | **REMOVE** | Replaced by `keyResultId` FK |
| `department` | Keep | Still relevant |
| `title` | Keep | Core field |
| `monthlyObjective` | **REMOVE** | Not in v2 Excel structure |
| `weeklyTasks` | **REMOVE** | Not in v2 Excel structure |
| `startDate` | Keep | Core field |
| `endDate` | Keep | Core field |
| `resourcesFinancial` | **RENAME** to `budget` | Clearer naming in v2 |
| `resourcesNonFinancial` | **RENAME** to `resources` | Clearer naming in v2 |
| `personInCharge` | Keep | Core field |
| `accountable` | Keep | Already exists |
| `status` | Keep | Core field |
| `remarks` | Keep | Core field |
| `position` | Keep | Kanban ordering |
| `kpiLabel` | **REMOVE** | Metrics now on KeyResult |
| `kpiTarget` | **REMOVE** | Metrics now on KeyResult |
| `kpiActual` | **REMOVE** | Metrics now on KeyResult |
| `kpiUnit` | **REMOVE** | Metrics now on KeyResult |
| `kpiManualOverride` | **REMOVE** | Metrics now on KeyResult |
| `comments` | Keep | Relation |
| `projects` | Keep | Relation |

### 1.5 Index Changes

```prisma
// Add to Initiative
@@index([keyResultId])

// The existing keyResult string index becomes unnecessary
// Remove: no existing index on keyResult string (confirmed - not indexed)
```

---

## 2. Component Hierarchy Changes

### 2.1 Current Hierarchy (v1.5)

```
ObjectivesPage (Server Component)
  -> getInitiatives() - Prisma query, serializes
  -> ObjectiveHierarchy (Client Component)
       -> groupInitiativesByObjective() - groups by string keyResult
       -> ObjectiveGroup (per objective enum)
            -> KeyResultGroup (per unique keyResult string)
                 -> aggregateKpiTotals() from initiative KPI fields
                 -> InitiativeRow (per initiative)
                      -> calculateKpi() from initiative KPI fields + linked projects
                      -> KpiProgressBar
```

### 2.2 Target Hierarchy (v2.0)

```
ObjectivesPage (Server Component)
  -> getObjectiveData() - Prisma query with KR includes
  -> ObjectiveHierarchy (Client Component)
       -> Data already structured by KR relations (no string grouping needed)
       -> ObjectiveGroup (per objective enum)
            -> KeyResultGroup (per KeyResult model)
                 -> KR-level metrics: target, actual, progress, unit
                 -> KR progress bar (from KR model fields directly)
                 -> InitiativeRow (per initiative via KR relation)
                      -> No KPI calculation (removed from initiative)
                      -> Shows status, dates, budget, assignees
       -> SupportTaskSection (new, below objectives)
            -> SupportTaskGroup (per category)
                 -> SupportTaskRow (per task, shows linked KR badges)
```

### 2.3 Files That Change

| File | Change Type | What Changes |
|---|---|---|
| `prisma/schema.prisma` | **Major rewrite** | New models, enum changes, Initiative field changes |
| `prisma/seed.ts` | **Complete rewrite** | Parse 4 sheets, new wipe order, new model creation |
| `src/lib/initiative-group-utils.ts` | **Major rewrite** | No more string grouping; data comes pre-grouped from KR relations |
| `src/lib/initiative-kpi-utils.ts` | **Remove or repurpose** | KPI logic moves to KR model; initiative-level KPI gone |
| `src/app/(dashboard)/objectives/page.tsx` | **Rewrite query** | Query KeyResults with initiatives, not initiatives with string KR |
| `src/components/objectives/objective-hierarchy.tsx` | **Update types + structure** | New Initiative type (no KPI fields), new data shape |
| `src/components/objectives/objective-group.tsx` | **Update** | KPI aggregation changes to KR-model metrics |
| `src/components/objectives/key-result-group.tsx` | **Major update** | Display KR model metrics (target/actual/progress/unit) |
| `src/components/objectives/initiative-row.tsx` | **Simplify** | Remove KpiProgressBar, show budget/resources |
| `src/components/objectives/kpi-progress-bar.tsx` | **Repurpose** | Used at KR level, not initiative level |
| `src/app/api/initiatives/route.ts` | **Update** | Remove KPI fields from create/list, add keyResultId |
| `src/app/api/initiatives/[id]/route.ts` | **Update** | Remove KPI PATCH fields, add keyResultId/budget/resources |
| `src/app/api/dashboard/stats/route.ts` | **Update** | Revenue calculation from KR actual fields |
| `src/components/dashboard/kpi-cards.tsx` | **Update** | Revenue comes from KR model, not initiative completion proxy |
| `src/lib/utils.ts` | **Add** | New formatters for MetricType, SupportTaskCategory |
| `src/lib/widgets/registry.ts` | **Add** | New 'revenue-target' widget definition |
| `src/components/dashboard/dashboard-client.tsx` | **Add** | New widget render case |

### 2.4 New Files to Create

| File | Purpose |
|---|---|
| `src/app/api/key-results/route.ts` | CRUD for KeyResult model |
| `src/app/api/key-results/[id]/route.ts` | Single KR operations |
| `src/app/api/support-tasks/route.ts` | CRUD for SupportTask model |
| `src/app/api/support-tasks/[id]/route.ts` | Single SupportTask operations |
| `src/components/objectives/kr-metrics-display.tsx` | KR-level metrics bar (target/actual/progress) |
| `src/components/objectives/support-task-section.tsx` | SupportTask list grouped by category |
| `src/components/objectives/support-task-row.tsx` | Individual support task with KR badges |
| `src/components/dashboard/revenue-target-widget.tsx` | Revenue target dashboard widget |

---

## 3. Data Flow for KR Metrics

### 3.1 Current Flow (v1.5)

```
Dashboard Stats API:
  revenue = (completedInitiatives / totalInitiatives) * hardcoded_1M_target
  // This is a PROXY calculation, not actual revenue tracking

Objectives Page:
  KPI per initiative = manual kpiActual/kpiTarget OR sum of linked project revenue
  KPI per KR = aggregation of initiative KPIs (same unit only)
  KPI per Objective = aggregation of all initiative KPIs
```

**Problem:** Revenue is calculated as a proportion of completed initiatives to a hardcoded target. This has no relationship to actual revenue.

### 3.2 Target Flow (v2.0)

```
KeyResult Model (source of truth):
  KR.target = from Excel (e.g., 800000 for KR1.1 "Event Revenue")
  KR.actual = updatable (manual entry or future: computed from project revenue)
  KR.progress = (actual / target) * 100

Objectives Page:
  KR metrics displayed directly from KeyResult model fields
  No aggregation needed -- each KR has its own target/actual/progress
  Objective-level rollup = weighted average of KR progress values

Revenue Target Widget:
  Query all Revenue-type KRs
  total_target = sum(KR.target WHERE KR.metricType = REVENUE) = RM 1,000,000
  total_actual = sum(KR.actual WHERE KR.metricType = REVENUE)
  Breakdown: KR1.1 Events RM800K + KR2.2 Training RM200K

Dashboard Stats API:
  revenue_target = sum of Revenue-type KR targets
  revenue_actual = sum of Revenue-type KR actuals
  // REAL revenue tracking, not proxy
```

### 3.3 KR Progress Calculation Strategy

**Option A (recommended): Store progress on KR model, update on actual change.**
- `progress` field on KeyResult updated whenever `actual` changes
- Simple `(actual / target * 100)` calculation
- Update via API PATCH endpoint
- Pros: Fast reads, no computation on every page load
- Cons: Denormalized (must keep in sync)

**Option B: Compute progress on read.**
- No `progress` field, calculate in query or component
- Pros: Always accurate
- Cons: Repeated computation, harder to sort/filter by progress

**Recommendation: Option A.** Store `progress` on the model. The calculation is trivial and deterministic. Update it in the PATCH handler for KeyResult whenever `actual` or `target` changes. This matches the codebase pattern of pre-computing display values (see: `revenueProgress` in dashboard stats).

### 3.4 Objective-Level Rollup

Each objective has multiple KRs. Objective progress = weighted average of KR progress:

```typescript
function calculateObjectiveProgress(keyResults: KeyResult[]): number {
  const totalWeight = keyResults.reduce((sum, kr) => sum + (kr.weight || 1), 0)
  const weightedSum = keyResults.reduce(
    (sum, kr) => sum + (kr.progress * (kr.weight || 1)),
    0
  )
  return totalWeight > 0 ? weightedSum / totalWeight : 0
}
```

If weights are null, treat as equal (weight = 1). This is computed on read since it aggregates multiple KRs and doesn't need to be stored.

---

## 4. Seed Migration Strategy

### 4.1 Current Seed Structure

```
prisma/seed.ts reads:
  - Sheet 1 (Initiatives): Rows 7+ with columns A-O
  - Sheet "Events to Attend": Rows 4+ with columns A-J

Wipe order:
  1. initiative.deleteMany()
  2. eventToAttend.deleteMany()

Create order:
  1. Create initiatives (1 by 1 with sequenceNumber)
  2. Create eventsToAttend (1 by 1)
```

### 4.2 v2.0 Seed Structure

The v2 Excel (`MotionVii_SAAP_2026_v2.xlsx`) has these sheets:
- **Key Results** sheet (new)
- **Initiatives** sheet (restructured columns)
- **Support Tasks** sheet (new)
- **Events to Attend** sheet (unchanged)

### 4.3 Wipe Order (CRITICAL)

Must respect foreign key constraints. Delete in reverse-dependency order:

```typescript
// Phase 1: Delete leaf-level entities (no dependents)
await prisma.supportTaskKeyResult.deleteMany()  // Join table first
await prisma.comment.deleteMany()                // FK to Initiative
// Note: Do NOT delete projects, costs, documents, etc.
// Those are production data separate from OKR seed

// Phase 2: Delete entities with dependents already cleared
await prisma.supportTask.deleteMany()
await prisma.initiative.deleteMany()

// Phase 3: Delete parent entities
await prisma.keyResult.deleteMany()

// Phase 4: Independent entities
await prisma.eventToAttend.deleteMany()
```

**CRITICAL WARNING:** The current seed deletes `initiative.deleteMany()` directly. Since Initiative has `comments` and `projects` relations, and `comments` has `onDelete: Cascade` but `projects` does NOT have cascade delete (Project.initiativeId is optional FK), the existing approach works. However, v2.0 must also handle the new `KeyResult.initiatives` relation. Since Initiative.keyResultId will be nullable (for migration safety), `keyResult.deleteMany()` won't cascade-delete initiatives. The order above is safe.

### 4.4 Create Order

Must create parent entities before children (FK constraints):

```typescript
// Phase 1: Create KeyResults first (no FK dependencies)
for (const kr of keyResultRows) {
  await prisma.keyResult.create({ data: { ... } })
}

// Phase 2: Create Initiatives with keyResultId FK
for (const init of initiativeRows) {
  const kr = await prisma.keyResult.findUnique({ where: { krId: init.krRef } })
  await prisma.initiative.create({
    data: {
      ...init,
      keyResultId: kr?.id || null,  // Link to KR by krId lookup
    }
  })
}

// Phase 3: Create SupportTasks with KR links
for (const task of supportTaskRows) {
  const supportTask = await prisma.supportTask.create({ data: { ... } })

  // Parse comma-separated KR refs: "KR1.1, KR2.1"
  const krRefs = task.supports.split(',').map(s => s.trim())
  for (const krRef of krRefs) {
    const kr = await prisma.keyResult.findUnique({ where: { krId: krRef } })
    if (kr) {
      await prisma.supportTaskKeyResult.create({
        data: { supportTaskId: supportTask.id, keyResultId: kr.id }
      })
    }
  }
}

// Phase 4: Create EventsToAttend (independent, unchanged)
```

### 4.5 Excel Column Mapping (v2)

**Key Results sheet columns (estimated from context):**
```
A(0): krId        -> "KR1.1"
B(1): objective   -> "Obj 1: Scale Events"
C(2): description -> "Generate RM800K..."
D(3): metricType  -> "Revenue" | "Count"
E(4): target      -> 800000
F(5): actual      -> 0
G(6): unit        -> "RM"
H(7): progress    -> 0 (percentage)
I(8): deadline    -> "Q4 2026"
J(9): status      -> "Not Started"
K(10): owner      -> "Khairul"
L(11): howWeMeasure -> "Total invoiced..."
M(12): notes      -> ""
N(13): weight     -> 40
```

**Initiatives sheet columns (v2 restructured):**
```
A(0): id/seq      -> 1
B(1): krRef       -> "KR1.1" (lookup to KeyResult.krId)
C(2): objective   -> "Obj 1: Scale Events"
D(3): title       -> "Launch Event..."
E(4): department  -> "Biz Dev"
F(5): startDate   -> date
G(6): endDate     -> date
H(7): budget      -> 5000
I(8): resources   -> "Team, venue"
J(9): personInCharge -> "Khairul"
K(10): accountable -> "Azlan"
L(11): status     -> "Not Started"
M(12): progress   -> 0
N(13): remarks    -> ""
```

**Support Tasks sheet columns:**
```
A(0): id/seq      -> 1
B(1): category    -> "Admin & Ops"
C(2): task        -> "Update CRM weekly"
D(3): supports    -> "KR1.1, KR2.1" (comma-separated)
E(4): owner       -> "Izyani"
F(5): frequency   -> "Weekly"
G(6): priority    -> "Medium"
H(7): notes       -> ""
```

**IMPORTANT:** These column mappings are estimates based on the project context description. The actual Excel structure must be verified by reading the v2 Excel file headers during implementation. The seed script should include header validation.

---

## 5. Revenue Target Dashboard Widget

### 5.1 Widget Registry Entry

```typescript
// Add to src/lib/widgets/registry.ts
'revenue-target': {
  id: 'revenue-target',
  title: 'Revenue Targets',
  description: 'Revenue KR progress with Events/Training breakdown',
  defaultSize: { w: 12, h: 3 },
  minRole: UserRole.VIEWER,  // Revenue targets are part of OKR, visible to all
  category: 'kri',
  dataKey: 'revenueTargets',
},
```

### 5.2 Data Source

New API endpoint or extend existing dashboard stats:

```typescript
// GET /api/dashboard/revenue-targets
// OR extend /api/dashboard/stats with revenueTargets section

const revenueKRs = await prisma.keyResult.findMany({
  where: { metricType: 'REVENUE' },
  select: {
    krId: true,
    description: true,
    target: true,
    actual: true,
    progress: true,
    unit: true,
    objective: true,
  },
})

// Expected output:
// {
//   totalTarget: 1000000,  // KR1.1(800K) + KR2.2(200K)
//   totalActual: 150000,
//   totalProgress: 15,
//   breakdown: [
//     { krId: "KR1.1", label: "Events Revenue", target: 800000, actual: 120000, progress: 15 },
//     { krId: "KR2.2", label: "Training Revenue", target: 200000, actual: 30000, progress: 15 },
//   ]
// }
```

### 5.3 Widget Component Design

```
RevenueTargetWidget
  |-- Total: RM 150,000 / RM 1,000,000 (15%)
  |-- Progress bar (full width)
  |-- Breakdown row: KR1.1 Events RM120K/RM800K [====    ] 15%
  |-- Breakdown row: KR2.2 Training RM30K/RM200K [====    ] 15%
```

### 5.4 Impact on Existing KPI Cards

The existing `kpi-cards.tsx` has a `revenueProgress` field calculated as `(completedCount / totalInitiatives) * 1M`. In v2.0:

**Option A:** Replace the proxy calculation in `kpi-cards` with real KR revenue data.
**Option B:** Keep `kpi-cards` as initiative-focused, add separate revenue widget.

**Recommendation: Option B.** Keep KPI cards focused on initiative execution metrics (total, completed, upcoming, at-risk). Move revenue tracking entirely to the new `revenue-target` widget. Remove the misleading `revenueProgress` section from KPI cards. This separation of concerns is cleaner.

---

## 6. Suggested Build Order

Based on dependency analysis:

### Phase 1: Schema + Migration (Foundation)

**Must be first.** Everything else depends on the new models.

1. Update `prisma/schema.prisma` with new models + enums
2. Add KeyResult model, SupportTask model, join table
3. Modify Initiative model (add keyResultId, remove KPI fields, rename budget/resources)
4. Run `prisma migrate dev` to generate migration
5. Verify migration applies cleanly

**Dependencies:** None
**Risk:** Medium (breaking change to Initiative model)

### Phase 2: Seed Script Rewrite

**Must be second.** Without data, nothing can be tested.

1. Rewrite `prisma/seed.ts` for v2 Excel structure
2. Parse all 4 sheets with proper column mappings
3. Implement wipe-and-reseed with correct FK ordering
4. Add normalizer functions for new enums (MetricType, SupportTaskCategory)
5. Add KR lookup for Initiative.keyResultId and SupportTask KR links
6. Run seed and verify data integrity

**Dependencies:** Phase 1 (schema)
**Risk:** Medium (Excel column mapping must match actual file)

### Phase 3: API Layer

**Must come before UI.** UI components need endpoints.

1. Create `/api/key-results/route.ts` (GET list, POST create)
2. Create `/api/key-results/[id]/route.ts` (GET, PATCH, DELETE)
3. Update `/api/initiatives/route.ts` (remove KPI fields, add keyResultId)
4. Update `/api/initiatives/[id]/route.ts` (remove KPI PATCH, add budget/resources)
5. Create `/api/support-tasks/route.ts` (GET, POST)
6. Create `/api/support-tasks/[id]/route.ts` (GET, PATCH, DELETE)
7. Update `/api/dashboard/stats/route.ts` (revenue from KRs, not proxy)

**Dependencies:** Phase 1 (schema), Phase 2 (seed for testing)
**Risk:** Low (standard CRUD patterns, follows existing codebase conventions)

### Phase 4: Utility Layer Updates

**Must come before UI, after API.**

1. Rewrite `src/lib/initiative-group-utils.ts` for KR-relation-based grouping
2. Remove or deprecate `src/lib/initiative-kpi-utils.ts` (KPI logic now in KR model)
3. Add formatters to `src/lib/utils.ts` for MetricType, SupportTaskCategory
4. Add KR-level progress calculation utility

**Dependencies:** Phase 1 (types)
**Risk:** Low

### Phase 5: OKR Hierarchy UI Updates

**Core UI changes.**

1. Update `objectives/page.tsx` query to fetch KRs with initiatives
2. Update `ObjectiveHierarchy` types and data shape
3. Update `ObjectiveGroup` to use KR-model metrics for rollup
4. Rewrite `KeyResultGroup` to display KR metrics (target/actual/progress/unit)
5. Simplify `InitiativeRow` (remove KPI bar, show budget/assignees)
6. Create `kr-metrics-display.tsx` for KR-level progress visualization
7. Remove or repurpose `kpi-progress-bar.tsx`

**Dependencies:** Phases 1-4
**Risk:** Medium (most visible change, affects primary OKR view)

### Phase 6: Support Tasks UI

**Independent of OKR hierarchy changes (can parallelize with Phase 5).**

1. Create `support-task-section.tsx` component
2. Create `support-task-row.tsx` with KR badge links
3. Add support tasks section to objectives page (below OKR hierarchy)
4. Wire to API endpoints

**Dependencies:** Phases 1-3
**Risk:** Low (additive, no existing code changes)

### Phase 7: Revenue Target Dashboard Widget

**Independent of OKR hierarchy UI (can parallelize with Phase 5).**

1. Add `revenue-target` to widget registry
2. Create `revenue-target-widget.tsx` component
3. Add API endpoint for revenue KR data
4. Add render case in `dashboard-client.tsx`
5. Update default dashboard layout to include widget
6. Remove misleading revenue proxy from KPI cards

**Dependencies:** Phases 1-3
**Risk:** Low (additive widget, follows existing widget patterns)

---

## 7. Anti-Patterns to Avoid

### 7.1 Do NOT Keep Dual Data Paths

The v1.5 system has two KPI data sources: manual override (initiative fields) and auto-calculated (project revenue). v2.0 moves metrics to the KR level. Do NOT keep the old initiative-level KPI fields "just in case." This creates confusing dual-source-of-truth. Remove them cleanly.

### 7.2 Do NOT Use Implicit Many-to-Many

Prisma supports implicit many-to-many relations (no explicit join table), but the codebase uses explicit join tables (see TaskTag pattern). Follow the existing convention with `SupportTaskKeyResult` as an explicit model. This allows adding metadata to the join (e.g., if you later need to track "primary" vs "secondary" KR support).

### 7.3 Do NOT Compute Revenue in Dashboard Stats From Initiative Count

The current `revenueProgress = (completed/total) * target` is a meaningless proxy. v2.0 has real KR actual values. Use them. Do not fall back to the proxy calculation.

### 7.4 Do NOT Parse KR References at Runtime

The current system groups by normalizing `keyResult` strings at runtime. v2.0 should use FK relations. Do not build a system that parses `"KR1.1"` strings from Initiative to find the matching KeyResult. The FK `keyResultId` handles this.

### 7.5 Do NOT Delete Production Data in Seed

The seed wipes OKR-related tables (KeyResults, Initiatives, SupportTasks, EventsToAttend). It must NOT touch production data tables: Project, Cost, Company, Contact, Deal, etc. The current seed already follows this pattern correctly.

---

## 8. Migration Safety Considerations

### 8.1 keyResultId Should Be Nullable Initially

Make `keyResultId` on Initiative nullable (`String?`). This allows:
- Running migration without data (empty keyResultId)
- Seeding KRs first, then updating initiatives
- Backward compatibility during development

After seed runs, all initiatives should have keyResultId populated, but the nullable constraint prevents migration failures.

### 8.2 Drop Columns After Seed Verification

Recommend a two-step migration:

**Migration 1:** Add new fields (keyResultId, budget, resources, new models)
**Migration 2:** Remove old fields (keyResult string, KPI fields, monthlyObjective, weeklyTasks)

This allows testing with both old and new fields present. If something goes wrong, old data is still accessible.

**Alternatively (simpler):** Since this is a wipe-and-reseed operation on a small team tool, a single migration that adds new and removes old is acceptable. The old data is in the Excel file and can be restored.

**Recommendation:** Single migration for simplicity. This is an internal tool with 3 users, not a production SaaS with data migration concerns.

### 8.3 Prisma Migration Command

```bash
# Create migration
npx prisma migrate dev --name v2_okr_restructure

# If migration fails due to data (non-nullable columns with existing data):
# Option 1: Wipe DB first, then migrate
npx prisma migrate reset  # Wipes all data, runs all migrations, runs seed

# Option 2: Use --create-only, edit migration SQL, then apply
npx prisma migrate dev --create-only --name v2_okr_restructure
# Edit generated SQL to add DEFAULT values or make nullable
npx prisma migrate dev
```

**Recommendation:** Use `prisma migrate reset` since the seed will repopulate all OKR data from the v2 Excel. This is the cleanest approach for a restructure.

---

## 9. TypeScript Type Changes

### 9.1 Initiative Interface (Client-Side)

```typescript
// BEFORE (v1.5 - in objective-hierarchy.tsx)
export interface Initiative {
  id: string
  sequenceNumber: number
  title: string
  objective: string
  keyResult: string          // STRING
  department: string
  status: string
  personInCharge: string | null
  startDate: string
  endDate: string
  position: number
  kpiLabel?: string | null   // KPI fields on initiative
  kpiTarget?: number | null
  kpiActual?: number | null
  kpiUnit?: string | null
  kpiManualOverride?: boolean
  projects?: Array<{...}>
}

// AFTER (v2.0)
export interface Initiative {
  id: string
  sequenceNumber: number
  title: string
  objective: string
  keyResultId: string | null  // FK to KeyResult
  department: string
  status: string
  personInCharge: string | null
  accountable: string | null
  startDate: string
  endDate: string
  budget: number | null       // Renamed from resourcesFinancial
  resources: string | null    // Renamed from resourcesNonFinancial
  position: number
  remarks: string | null
  projects?: Array<{...}>
  // NO KPI fields
}
```

### 9.2 New KeyResult Interface (Client-Side)

```typescript
export interface KeyResult {
  id: string
  krId: string               // "KR1.1"
  objective: string
  description: string
  metricType: 'REVENUE' | 'COUNT'
  target: number
  actual: number
  unit: string
  progress: number           // 0-100
  deadline: string
  status: string
  owner: string | null
  howWeMeasure: string | null
  notes: string | null
  weight: number | null
  initiatives: Initiative[]
}
```

### 9.3 GroupedObjective Type Update

```typescript
// BEFORE (v1.5)
export interface GroupedKeyResult {
  keyResult: string           // The KR string label
  initiatives: InitiativeForGrouping[]
  totalInitiatives: number
  completedCount: number
}

// AFTER (v2.0)
export interface GroupedKeyResult {
  keyResult: KeyResult        // Full KR model with metrics
  initiatives: Initiative[]
  totalInitiatives: number
  completedCount: number
}
```

---

## 10. Detailed Query Changes

### 10.1 Objectives Page Query (BEFORE)

```typescript
// src/app/(dashboard)/objectives/page.tsx
const initiatives = await prisma.initiative.findMany({
  orderBy: [
    { objective: 'asc' },
    { keyResult: 'asc' },         // String sort
    { sequenceNumber: 'asc' },
  ],
  select: {
    // ... all initiative fields + KPI fields
    kpiLabel: true,
    kpiTarget: true,
    kpiActual: true,
    kpiUnit: true,
    kpiManualOverride: true,
    projects: { ... },
  },
})
```

### 10.2 Objectives Page Query (AFTER)

```typescript
// Option A: Query from KeyResult side (RECOMMENDED)
async function getObjectiveData() {
  const keyResults = await prisma.keyResult.findMany({
    orderBy: [
      { objective: 'asc' },
      { krId: 'asc' },
    ],
    include: {
      initiatives: {
        orderBy: { sequenceNumber: 'asc' },
        select: {
          id: true,
          sequenceNumber: true,
          title: true,
          objective: true,
          department: true,
          status: true,
          personInCharge: true,
          accountable: true,
          startDate: true,
          endDate: true,
          budget: true,
          resources: true,
          position: true,
          remarks: true,
          projects: {
            select: {
              id: true,
              title: true,
              status: true,
              revenue: true,
              company: { select: { name: true } },
            },
          },
        },
      },
    },
  })

  // Group by objective on the server
  const byObjective = new Map<string, typeof keyResults>()
  for (const kr of keyResults) {
    const group = byObjective.get(kr.objective) || []
    group.push(kr)
    byObjective.set(kr.objective, group)
  }

  return Array.from(byObjective.entries()).map(([objective, krs]) => ({
    objective,
    keyResults: krs.map(kr => ({
      ...kr,
      target: Number(kr.target),
      actual: Number(kr.actual),
      progress: Number(kr.progress),
      weight: kr.weight ? Number(kr.weight) : null,
      initiatives: kr.initiatives.map(i => ({
        ...i,
        startDate: i.startDate.toISOString(),
        endDate: i.endDate.toISOString(),
        budget: i.budget ? Number(i.budget) : null,
        projects: i.projects.map(p => ({
          ...p,
          revenue: p.revenue ? Number(p.revenue) : null,
          companyName: p.company?.name || null,
        })),
      })),
    })),
  }))
}
```

**Rationale for querying from KeyResult side:** The hierarchy is Objective > KeyResult > Initiative. Querying from KR gives us the natural grouping structure. The old approach queried Initiatives and grouped by a string field -- that workaround is no longer needed with proper FK relations.

---

## 11. Support Tasks UI Integration

### 11.1 Where in the Page

Support tasks should appear **below the OKR hierarchy** on the objectives page, in their own section:

```
ObjectivesPage
  |-- ViewModeToggle
  |-- ObjectiveGroup (OBJ1)
  |     |-- KeyResultGroup (KR1.1)
  |     |-- KeyResultGroup (KR1.2)
  |-- ObjectiveGroup (OBJ2)
  |     |-- KeyResultGroup (KR2.1)
  |     |-- KeyResultGroup (KR2.2)
  |-- SupportTaskSection         <-- NEW
        |-- SupportTaskCategory ("Admin & Ops")
        |     |-- SupportTaskRow
        |     |-- SupportTaskRow
        |-- SupportTaskCategory ("Marketing & Comms")
        |     |-- SupportTaskRow
```

### 11.2 KR Badge Design

Each support task shows which KRs it supports:

```
[Weekly] Update CRM pipeline data                    Izyani    Medium
  Supports: [KR1.1] [KR1.2] [KR2.1]
```

Badges should be clickable, scrolling to the relevant KR in the hierarchy above.

### 11.3 Query

```typescript
const supportTasks = await prisma.supportTask.findMany({
  orderBy: [{ category: 'asc' }, { priority: 'desc' }],
  include: {
    keyResultLinks: {
      include: {
        keyResult: { select: { krId: true, description: true } },
      },
    },
  },
})
```

---

## 12. Confidence Assessment

| Area | Confidence | Reason |
|---|---|---|
| Schema design | HIGH | Based on direct analysis of existing schema + Excel structure from context |
| Wipe/seed order | HIGH | FK constraints analyzed from current schema relations |
| UI hierarchy changes | HIGH | All component files read and analyzed |
| Widget integration | HIGH | Widget registry pattern fully understood from source |
| Excel column mapping | MEDIUM | Based on context description, not actual Excel file analysis |
| Build order | HIGH | Dependency analysis from code structure |

---

## 13. Open Questions

1. **Excel column mapping verification:** The exact column positions for the v2 Excel need verification by reading the actual file headers. The seed script should validate headers before parsing.

2. **KR actual value update mechanism:** How will KR.actual be updated? Options:
   - Manual entry only (simplest, recommended for v2.0)
   - Auto-computed from linked Project revenue (future enhancement)
   - Hybrid (auto-compute with manual override, similar to v1.5 KPI)

3. **Progress field on Initiative:** The v2 Excel mentions an initiative `progress` column. Should Initiative have its own progress field (separate from status)? If so, add `progress Decimal? @db.Decimal(5, 2)` to Initiative. This is independent of KR progress.

4. **Existing projects linked to initiatives:** Projects have `initiativeId` FK. After migration, these links remain intact since Initiative.id (cuid) does not change. However, if seed wipes and recreates initiatives, the IDs will change and project links will break. **Mitigation:** If there are existing project-initiative links, the seed should either preserve initiative IDs or clear the links. For an internal tool with seed-based data, this is acceptable.

5. **Comment history preservation:** Comments have FK to Initiative. If initiatives are wiped and recreated, comments are cascade-deleted. This is acceptable for a seed operation but should be noted.
