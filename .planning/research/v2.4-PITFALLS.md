# Pitfalls Research: v2.4 Settings, Sidebar & Bug Fixes

**Domain:** Sidebar navigation behavior, drag-and-drop reordering, nested nav, field visibility config, revenue accuracy
**Researched:** 2026-01-28
**Confidence:** HIGH (all findings derived from direct codebase analysis)

---

## Critical Pitfalls

### Pitfall 1: autoReveal Matching Is Too Broad (startsWith)

**Severity:** CRITICAL

**What goes wrong:**
The current `autoReveal` function in `use-nav-visibility.ts` (line 79-81) matches hidden items using `pathname.startsWith(href)`. This means ANY pathname that begins with a hidden item's href triggers an unhide. For example:
- Hidden href `/companies` matches `/companies`, but also matches sub-routes like when URL changes happen from tab clicks within the Companies detail view.
- The bug is confirmed: in-page tab switches that update the URL (via `router.push` or `searchParams`) cause `pathname` to change, which triggers `autoReveal` via the `useEffect` in `sidebar.tsx` (line 21-23), re-showing items the user explicitly hid.

**Why it happens:**
The `useEffect` in sidebar.tsx fires on every `pathname` change. There is no mechanism to distinguish between:
1. Direct URL navigation (typing URL, clicking bookmark, deep link) -- should auto-reveal
2. In-page tab/filter changes that modify the URL -- should NOT auto-reveal
3. Sidebar link clicks -- already visible, no reveal needed

The `lastRevealedRef` only prevents repeated reveals of the same pathname, not repeated reveals triggered by different sub-paths of the same base href.

**How to avoid:**
- Change matching to exact-match-only: `pathname === href` instead of `pathname.startsWith(href)`. The auto-reveal only needs to fire when the user lands exactly on a hidden nav item's URL, not on any sub-path.
- Alternatively, add a `navigationSource` signal: track whether navigation came from sidebar clicks (no reveal needed), in-page interactions (no reveal needed), or direct URL entry (reveal needed). This can be done by comparing `document.referrer` or using a ref flag set during sidebar link clicks.
- The simplest fix: only auto-reveal on the exact href match. If a nav item has `href="/companies"`, only auto-reveal when `pathname === "/companies"`, not when `pathname === "/companies/abc123"`.

**Warning signs:**
- Users report hidden sidebar items reappearing unexpectedly
- Hidden nav items come back when clicking tabs within detail pages
- `lastRevealedRef` keeps getting set to new values as user navigates sub-routes

**Phase to address:**
Sidebar autoReveal fix phase (should be first -- it is a bug fix for existing functionality)

---

### Pitfall 2: Race Condition in Fire-and-Forget Preference Saves

**Severity:** CRITICAL

**What goes wrong:**
The `toggleItem` function in `use-nav-visibility.ts` (line 57-61) uses fire-and-forget `fetch` to persist hidden items. The `autoReveal` function (line 89-93) does the same. Both read from and write to `hiddenNavItems` without any concurrency protection. If the user toggles an item in Settings while `autoReveal` fires simultaneously, they can overwrite each other:

1. User hides item A (sends `[A]` to API)
2. Before API responds, autoReveal fires and sends `[]` to API (removing A)
3. User's hidden preference is lost

This is especially dangerous with drag-and-drop reorder, which will add a `navOrder` field -- rapid drag operations could cause lost writes.

**Why it happens:**
Optimistic state updates with async persistence and no queue/mutex. The `setHiddenItems` callback uses the previous state correctly locally, but each API call captures the state at call time, not the state after all queued updates.

**How to avoid:**
- Implement a save queue or debounced save: collect all pending changes and send them in a single API call after a short debounce (200-500ms).
- Use a ref to track the "latest intended state" and only send that, not intermediate values.
- For drag-and-drop specifically, batch the final order into one save call (save on drop, not during drag).
- Consider optimistic updates with rollback: save the previous state, attempt the API call, restore on failure.

**Warning signs:**
- User preferences randomly reverting
- Console shows multiple simultaneous PATCH calls to `/api/user/preferences`
- hiddenNavItems in database does not match what the user sees

**Phase to address:**
Sidebar autoReveal fix phase AND Drag-and-drop reorder phase (must be solved before adding more concurrent writes)

---

### Pitfall 3: Nested Sidebar Links Break href-Based Visibility System

**Severity:** CRITICAL

**What goes wrong:**
The entire nav visibility system is built around flat `href` strings. The `NavItem` interface (nav-config.ts line 25-29) has `name`, `href`, `icon` -- no `children` property. The `hiddenNavItems` stored in `UserPreferences` is a flat JSON array of href strings. Adding nested links (e.g., "Company" expanding to show "Departments" and "Contacts") requires:

1. A new `children?: NavItem[]` field on `NavItem`
2. Deciding what happens when parent is hidden vs child is hidden
3. Updating `isVisible`, `toggleItem`, `autoReveal` to handle hierarchy
4. Updating `findGroupForPath` to traverse nested items
5. Updating `getAllNavHrefs` to include nested hrefs
6. Updating Settings page to show nested toggles

If you just add children without updating all these touch points, hidden items will leak through, auto-reveal will break for children, and the Settings page will not show child toggles.

**Why it happens:**
The nav system was designed for a flat list. Nesting is a structural change that touches every consumer of `nav-config.ts`.

**How to avoid:**
- Audit every consumer of `navGroups`, `topLevelItems`, `NavItem`, `NavGroup` before changing the types. Currently used in:
  - `sidebar.tsx` (rendering + visibility filtering)
  - `nav-group.tsx` (rendering group items)
  - `use-nav-visibility.ts` (auto-reveal matching)
  - `use-nav-collapse-state.ts` (group expand/collapse)
  - `settings/page.tsx` (toggle switches)
  - `nav-config.ts` (type definitions, `findGroupForPath`, `getAllNavHrefs`, `isAlwaysVisible`)
- Design the parent-child visibility semantics first: hiding a parent hides all children (simplest). Hiding a child is independent. Un-hiding a child auto-shows the parent.
- Make it a separate expandable section within the existing group, not a deeply nested tree. Two levels max (parent + children).

**Warning signs:**
- TypeScript errors after adding `children` to `NavItem`
- Children of hidden parents still appearing in sidebar
- Settings page crashes or shows flat list without nested toggles
- `findGroupForPath` returning wrong group for nested paths

**Phase to address:**
Nested sidebar links phase (must come before drag-and-drop, because drag-and-drop operates on the full nav tree)

---

### Pitfall 4: Drag-and-Drop Reorder Interfering with Click Navigation

**Severity:** HIGH

**What goes wrong:**
Using `@dnd-kit/core` for sidebar link reordering means wrapping `<Link>` elements in sortable containers. A common failure: the drag sensor activates on regular clicks, preventing navigation. The existing codebase uses `MouseSensor` and `TouchSensor` with `@dnd-kit/core` (see `kanban-board.tsx` line 9-12), but sidebar links have a much smaller drag target than kanban cards. Users will try to click a link and accidentally start a drag, or try to drag and accidentally navigate.

**Why it happens:**
`@dnd-kit` sensors default to zero activation distance. A click is a drag that ends immediately at the same position. Without proper activation constraints (distance threshold or delay), every interaction is ambiguous.

**How to avoid:**
- Set activation constraints on sensors: `MouseSensor` with `activationConstraint: { distance: 8 }` (8px minimum drag distance before activating). This is already partially done in kanban-board.tsx but must be carefully tuned for smaller sidebar items.
- Consider `useSensor(PointerSensor, { activationConstraint: { delay: 200, tolerance: 5 } })` -- requires holding for 200ms before drag activates, which makes clicks feel instant.
- Only enable drag handles (a grip icon) rather than making the entire link draggable. This eliminates click/drag ambiguity entirely.
- Separate edit mode: only allow reordering in Settings page or when an "Edit Sidebar" mode is active, never during normal navigation.

**Warning signs:**
- Users cannot click sidebar links without triggering drag
- Sidebar navigation feels sluggish or unresponsive
- Links scroll/jump when clicked instead of navigating

**Phase to address:**
Drag-and-drop reorder phase

---

### Pitfall 5: Dashboard Revenue Calculation Is Split Across Two Separate Code Paths

**Severity:** HIGH

**What goes wrong:**
The dashboard has TWO independent revenue displays that calculate revenue differently:

1. **Revenue Target widget** (`page.tsx` line 39-55): Reads from `KeyResult` model where `metricType === 'REVENUE'`. This is OKR-level revenue tracking (KR targets vs actuals). It does NOT include `potentialRevenue` from projects.

2. **CRM KPI Cards** (`page.tsx` line 183-195): Calculates `totalRevenue` from `Project.revenue` where `status === 'COMPLETED'`. This only counts `revenue` (from AI invoices) on completed projects. It does NOT include `potentialRevenue`.

The milestone requirement says "Dashboard revenue includes potentialRevenue." But adding `potentialRevenue` to one widget without the other creates an inconsistency. And adding it to the Revenue Target widget makes no sense because that tracks OKR Key Results, not project-level revenue.

**Why it happens:**
Revenue is modeled at two levels: OKR Key Results (aggregate targets) and individual Projects (revenue + potentialRevenue). The dashboard was built to show OKR progress, not project-level revenue aggregation.

**How to avoid:**
- Clarify which widget should include `potentialRevenue`. The CRM KPI Cards `totalRevenue` is the most likely candidate -- change the query from `_sum: { revenue: true }` to include both `revenue` and `potentialRevenue`, with clear labeling (e.g., "Revenue (incl. potential)").
- Do NOT add potentialRevenue to the Revenue Target widget -- that tracks KR-level actuals which are manually updated, not auto-calculated from projects.
- Consider showing both values: "Actual: RM X / Total (incl. potential): RM Y" to avoid confusion about what the number means.
- Ensure the project detail page calculation (`project-detail-page-client.tsx` line 140: `project.revenue ?? project.potentialRevenue ?? 0`) remains consistent: actual revenue takes priority over potential.

**Warning signs:**
- Dashboard shows different revenue numbers in different widgets
- Users confused about which revenue is "real"
- Revenue numbers do not match when comparing dashboard to project list totals

**Phase to address:**
Revenue accuracy phase

---

### Pitfall 6: Removing Status-Based Read-Only Without Audit Trail Creates Data Integrity Risk

**Severity:** HIGH

**What goes wrong:**
The milestone says "Completed projects editable (removing status-based read-only checks)." Currently, the `canEdit` function in `permissions.ts` checks user role only (ADMIN/EDITOR). There is NO explicit status-based read-only logic on projects. The grep for `readOnly`, `isReadOnly`, `COMPLETED.*readonly` in the projects directory returned zero matches.

However, `isReadOnly` IS used in `deal-detail-sheet.tsx` (line 261: `const isReadOnly = isConverted || isLost`) and `potential-detail-sheet.tsx` (line 257: `const isReadOnly = isConverted`). These prevent editing converted/lost deals.

If the assumption is that project editing is currently blocked for completed projects, but the code shows no such guard, then the "fix" could be a no-op -- or worse, the team might add unnecessary logic thinking they need to "enable" something that is already enabled. The real risk: if editing completed projects IS currently possible and the team does not realize it, they might not add the audit trail or confirmation dialog that SHOULD accompany edits to completed projects.

**Why it happens:**
Assumptions about existing behavior without verifying the code. The project detail sheet (`project-detail-sheet.tsx`) renders all form fields without any status-based disabled check.

**How to avoid:**
- Verify the actual current behavior first: open a COMPLETED project in the app and attempt to edit. The code does not show any status guard.
- If editing is already possible, the real work is: (a) adding an audit log entry when completed projects are modified, (b) adding a confirmation dialog ("This project is marked complete. Are you sure you want to edit?"), (c) deciding if the status should auto-revert to ACTIVE on edit.
- If there IS a status guard somewhere not found in this research (e.g., API-level validation in the PUT route), find and remove it, but add the audit trail.

**Warning signs:**
- PR that claims to "enable editing" but actually changes nothing
- Completed project data changed without any record of who changed it or when
- No confirmation dialog when editing a completed project

**Phase to address:**
Completed projects editable phase

---

### Pitfall 7: navOrder Persistence Schema Conflict with Existing UserPreferences

**Severity:** HIGH

**What goes wrong:**
The `UserPreferences` model already stores `hiddenNavItems` as a `Json` field. Adding drag-and-drop reorder requires storing a `navOrder` (array of href strings in custom order). If this is added as another Json field on `UserPreferences`, the PATCH endpoint (`/api/user/preferences/route.ts`) must be updated to handle it. The current endpoint uses a simple field-merge pattern (lines 53-65), which works but has no validation.

The risk: if `navOrder` and `hiddenNavItems` get out of sync (e.g., user hides an item but its href remains in `navOrder`, or a new nav item is added to `nav-config.ts` but not to `navOrder`), the sidebar will have ghost entries or missing items.

**Why it happens:**
Two separate arrays (`hiddenNavItems` and `navOrder`) that must stay synchronized with the canonical nav config in `nav-config.ts`. No single source of truth.

**How to avoid:**
- Design the merge logic upfront: `navOrder` defines custom order; items not in `navOrder` appear at the end in default order; items in `navOrder` but not in `nav-config.ts` are silently dropped.
- Add a reconciliation function that runs on sidebar load: take `navOrder` from DB, filter to only include items that exist in current `nav-config.ts`, append any new items not in `navOrder`.
- Store only the order (array of hrefs), not full nav item data. The canonical item data (name, icon) always comes from `nav-config.ts`.
- Consider storing `hiddenNavItems` and `navOrder` as a single unified structure: `{ items: [{ href, visible, order }] }`. This eliminates sync issues.

**Warning signs:**
- After deploying a new nav item, it does not appear for users who have custom order
- Sidebar shows items in wrong order or with duplicate entries
- Removing a nav item from config causes errors for users who had it in their order

**Phase to address:**
Drag-and-drop reorder phase

---

## Moderate Pitfalls

### Pitfall 8: Nested Nav Collapse State Conflict with Group Collapse

**Severity:** MEDIUM

**What goes wrong:**
The existing sidebar has two levels of collapsibility: (1) NavGroup collapse (SAAP/CRM/Admin sections via `useNavCollapseState`), and (2) the new nested item expansion (Company expanding to show Departments/Contacts). If both use the same state mechanism or the same UI pattern (chevron icon), users will be confused about which level they are expanding/collapsing.

**Why it happens:**
The current `useNavCollapseState` hook tracks `expandedGroups` by group key. Adding a nested expand for individual items requires a separate mechanism (e.g., `expandedItems` by href). If not clearly separated, clicking a nested chevron might be mistaken for a group collapse action.

**How to avoid:**
- Use visually distinct expand indicators: groups use a section header with chevron, nested items use an inline expand arrow or indentation.
- Store nested expansion state separately from group expansion state.
- Consider not making nested items collapsible at all -- just show them indented under the parent with no toggle. For the "Company" use case (3 items: Companies, Departments, Contacts), always-visible nested items may be cleaner than a collapsible tree.

**Warning signs:**
- Users collapsing a group when they meant to expand a nested item
- Double-chevron UI confusion
- State stored in wrong hook

**Phase to address:**
Nested sidebar links phase

---

### Pitfall 9: Internal Project Field Visibility Config Without Defaults Migration

**Severity:** MEDIUM

**What goes wrong:**
The milestone calls for "Internal project field visibility config (admin-configurable defaults)." The `AdminDefaults` model already exists (schema line 629-640) with `dashboardLayout` and `widgetRoles` fields. Adding field visibility config means either extending `AdminDefaults` with a new JSON field or creating a new model.

The pitfall: existing users have no `AdminDefaults` rows with field visibility config. If the code expects this config to exist and it does not, the app will crash or show no fields for internal projects.

**Why it happens:**
New configuration requires a sensible default when the DB has no value. The `getAdminDefaults` function (referenced in `page.tsx` line 271) must handle the case where the new field is null/missing.

**How to avoid:**
- Define hardcoded fallback defaults in code (e.g., `DEFAULT_INTERNAL_FIELD_VISIBILITY = { showRevenue: false, showCompany: false, ... }`).
- Use the same pattern as `DEFAULT_DASHBOARD_LAYOUT` -- a code-level constant that is used when the DB value is null.
- Add a database migration that sets a default value for the new field on existing `AdminDefaults` rows.
- Test with a fresh database (no AdminDefaults rows) and with existing databases.

**Warning signs:**
- "Cannot read property 'X' of null" errors on internal project pages
- Internal projects showing no fields or all fields when admin has not configured anything
- Admin settings page blank or erroring on first load

**Phase to address:**
Field visibility config phase

---

### Pitfall 10: @dnd-kit Accessibility Regression in Sidebar

**Severity:** MEDIUM

**What goes wrong:**
The existing kanban boards use `@dnd-kit` with keyboard sensors (`KeyboardSensor` with `sortableKeyboardCoordinates` in kanban-board.tsx line 10-11). The sidebar, however, is navigation -- keyboard users navigate with Tab and Enter. Adding `@dnd-kit` to sidebar items can steal keyboard focus from navigation, making the sidebar inaccessible to keyboard-only users.

**Why it happens:**
`@dnd-kit`'s keyboard sensor captures arrow key events for drag reordering, which conflicts with standard list navigation keyboard patterns.

**How to avoid:**
- Do NOT add keyboard drag support to the sidebar. Only support mouse/touch drag.
- If keyboard reorder is needed, implement it in the Settings page sidebar configuration section, not in the live sidebar.
- Use `aria-roledescription` and screen reader announcements so assistive technology understands the sidebar is a navigation, not a drag list.

**Warning signs:**
- Tab key no longer moves between sidebar links
- Arrow keys do unexpected things in sidebar
- Screen reader announces "draggable" for every nav link

**Phase to address:**
Drag-and-drop reorder phase

---

### Pitfall 11: Revenue Double-Counting When Including potentialRevenue

**Severity:** MEDIUM

**What goes wrong:**
For projects that have BOTH `revenue` (from AI invoice import) AND `potentialRevenue` (from deal/potential conversion), the dashboard could double-count if it sums both fields. The project detail page already handles this correctly (line 140: `project.revenue ?? project.potentialRevenue ?? 0` -- prefers actual over potential). But the dashboard CRM query (line 185) only sums `revenue`. If the fix naively adds `+ SUM(potentialRevenue)`, projects with both values will be double-counted.

**Why it happens:**
The two revenue fields serve different purposes: `potentialRevenue` is the estimate at deal conversion time, `revenue` is the actual from invoices. For financial reporting, you want the "best available" revenue per project, not the sum of both.

**How to avoid:**
- Use SQL-level COALESCE: `SUM(COALESCE(revenue, potentialRevenue, 0))` instead of `SUM(revenue) + SUM(potentialRevenue)`.
- In Prisma, this requires a raw query or computing it in application code: fetch all projects with both fields, then sum `revenue ?? potentialRevenue ?? 0` per project.
- Document clearly which number is shown: "Revenue (actual where available, estimated otherwise)."
- Add a tooltip or breakdown showing how many projects use actual vs potential figures.

**Warning signs:**
- Dashboard revenue is significantly higher than expected (double-counting)
- Revenue figure does not match sum of individual project revenues
- Confusion in team about what "total revenue" means

**Phase to address:**
Revenue accuracy phase

---

## Technical Debt Patterns

| Shortcut | Immediate Benefit | Long-term Cost | When Acceptable |
|----------|-------------------|----------------|-----------------|
| Storing navOrder as separate Json field alongside hiddenNavItems | Quick to implement, no schema redesign | Two arrays to keep in sync, reconciliation bugs | Only if a unified structure adds too much migration complexity |
| Fire-and-forget preference saves without queue | Simple code, instant UI feedback | Lost writes under concurrent updates | Never once drag-and-drop is added (too many rapid writes) |
| Exact-match-only autoReveal (dropping startsWith) | Fixes the bug immediately | Sub-paths of hidden items never auto-reveal (edge case: user bookmarks /companies/abc123 with /companies hidden) | Acceptable -- the edge case is rare and the fix is correct |
| Skipping audit trail for completed project edits | Faster to ship | No record of who changed completed project data, potential disputes | Never -- completed project edits should always be logged |

## Performance Traps

| Trap | Symptoms | Prevention | When It Breaks |
|------|----------|------------|----------------|
| Fetching full UserPreferences on every sidebar render | Sidebar feels slow, unnecessary API calls | Already mitigated by fetching once on mount in `useNavVisibility`. But adding navOrder as a separate fetch could double the requests. | At 10+ sidebar config fields fetched separately |
| Drag-and-drop saving on every position change during drag | API hammered with PATCH calls, DB writes on every pixel movement | Save only on drop (onDragEnd), not on intermediate positions | Immediately if saving during drag |
| Raw SQL for COALESCE revenue calculation | N/A (not a trap) | Use application-level calculation with Prisma, which the codebase already does | N/A |

## UX Pitfalls

| Pitfall | User Impact | Better Approach |
|---------|-------------|-----------------|
| Making the entire sidebar draggable without an edit mode | Users accidentally reorder nav when trying to click links | Add a dedicated "Customize Sidebar" mode or grip handles |
| Nested nav items with no visual hierarchy | Users cannot distinguish parent from child items | Use indentation (pl-8 on children) and smaller text/icons for children |
| Removing "completed" read-only without any visual warning | Users accidentally edit finalized project data | Add a yellow banner: "This project is marked Complete. Changes will be logged." |
| Showing potentialRevenue in dashboard without labeling | Users think it is confirmed revenue | Always label: "Includes estimated revenue" with a distinct color or icon |
| Drag handle too small on mobile sidebar | Touch users cannot grab the drag handle | Minimum 44x44px touch target for drag handles per WCAG |

## "Looks Done But Isn't" Checklist

- [ ] **autoReveal fix:** Verify the fix works when navigating FROM a hidden item's sub-route (e.g., /companies/abc to /companies) -- ensure it does not re-trigger unhide
- [ ] **Nested nav:** Verify `findGroupForPath` returns correct group for nested items (currently only checks `group.items`, not children)
- [ ] **Nested nav:** Verify `getAllNavHrefs()` includes nested item hrefs (used by Settings page)
- [ ] **Drag-and-drop:** Verify nav order persists across page refreshes (not just in React state)
- [ ] **Drag-and-drop:** Verify new nav items added in future deploys appear for users with custom order
- [ ] **Completed projects:** Verify API route `/api/projects/[id]` does not have a hidden status check that blocks PATCH on completed projects
- [ ] **Field visibility:** Verify internal project forms respect admin config (not just detail views)
- [ ] **Revenue:** Verify dashboard revenue matches the sum of individual project "best available" revenues
- [ ] **Revenue:** Verify the Revenue Target widget (OKR-level) is NOT changed -- only the CRM KPI card
- [ ] **Mobile:** Verify drag-and-drop works on the mobile sidebar (if mobile sidebar exists -- currently `hidden md:fixed`)

## Recovery Strategies

| Pitfall | Recovery Cost | Recovery Steps |
|---------|---------------|----------------|
| autoReveal unhides items unexpectedly | LOW | Deploy the exact-match fix; user preferences in DB are already correct (items are hidden), the bug just removes them |
| Preference race condition loses data | LOW | Re-save preferences from Settings page; no permanent damage since preferences are user-facing only |
| Nested nav breaks visibility for children | MEDIUM | Revert nav-config.ts change; all consumers fall back to flat list |
| Drag-and-drop order lost/corrupted | LOW | Delete navOrder from UserPreferences; sidebar falls back to default order from nav-config.ts |
| Revenue double-counting | MEDIUM | Fix the aggregation query; no data is corrupted, only the display is wrong |
| Completed project data edited without audit | HIGH | Cannot undo -- no record of original values. Must implement audit logging before enabling edits |

## Pitfall-to-Phase Mapping

| Pitfall | Prevention Phase | Verification |
|---------|------------------|--------------|
| autoReveal too broad (P1) | Sidebar autoReveal fix | Toggle items hidden, click tabs within pages, verify items stay hidden |
| Race condition in saves (P2) | Sidebar autoReveal fix + DnD reorder | Rapidly toggle items in Settings while navigating; verify final state matches intent |
| Nested breaks flat system (P3) | Nested sidebar links | TypeScript compiles clean; Settings page shows nested toggles; findGroupForPath works for children |
| Drag interferes with click (P4) | DnD reorder | Click every sidebar link with drag enabled; verify navigation works on first click |
| Revenue split code paths (P5) | Revenue accuracy | Compare dashboard revenue to manual sum of all projects; they must match |
| No status guard exists (P6) | Completed projects editable | Attempt to edit completed project before any code change; document actual current behavior |
| navOrder sync with config (P7) | DnD reorder | Add a new nav item to config; deploy; verify it appears for users with custom order |
| Collapse state conflict (P8) | Nested sidebar links | Expand a group, then expand a nested item; collapse the group; re-expand; verify nested state preserved |
| AdminDefaults missing (P9) | Field visibility config | Test with fresh DB (no AdminDefaults row); verify sensible defaults shown |
| Accessibility regression (P10) | DnD reorder | Tab through sidebar with keyboard; verify all links reachable |
| Revenue double-counting (P11) | Revenue accuracy | Check projects with both revenue and potentialRevenue; verify dashboard counts each project once |

## Sources

- Direct codebase analysis of `src/lib/hooks/use-nav-visibility.ts` (autoReveal logic, lines 73-100)
- Direct codebase analysis of `src/components/layout/sidebar.tsx` (useEffect on pathname, line 21-23)
- Direct codebase analysis of `src/lib/nav-config.ts` (NavItem type, flat structure, findGroupForPath)
- Direct codebase analysis of `src/components/layout/nav-group.tsx` (group rendering, no children support)
- Direct codebase analysis of `src/app/(dashboard)/settings/page.tsx` (flat nav toggle UI)
- Direct codebase analysis of `src/app/api/user/preferences/route.ts` (PATCH handler, fire-and-forget pattern)
- Direct codebase analysis of `src/components/kanban/kanban-board.tsx` (existing @dnd-kit usage patterns)
- Direct codebase analysis of `src/app/(dashboard)/page.tsx` (dashboard revenue queries, lines 39-55 and 183-195)
- Direct codebase analysis of `src/components/dashboard/crm-kpi-cards.tsx` (totalRevenue display)
- Direct codebase analysis of `src/components/dashboard/revenue-target.tsx` (OKR-level revenue)
- Direct codebase analysis of `src/components/projects/project-detail-page-client.tsx` (revenue fallback logic, line 140)
- Direct codebase analysis of `prisma/schema.prisma` (UserPreferences model, Project model, AdminDefaults model)
- Direct codebase analysis of `src/lib/permissions.ts` (canEdit checks role only, no status check)
- Grep for `readOnly|isReadOnly` in projects directory returned zero matches (confirming no status-based guard)

---
*Pitfalls research for: SAAP 2026 v2.4 -- Settings, Sidebar & Bug Fixes*
*Researched: 2026-01-28*
