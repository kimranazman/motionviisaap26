# Architecture Patterns: v2.3 CRM & UX Improvements

**Domain:** Internal business platform - CRM entities, task management, sidebar customization, modal fixes, pricing history
**Researched:** 2026-01-28
**Confidence:** HIGH (based on direct codebase analysis)

## Executive Summary

v2.3 introduces six integration points into the existing SAAP architecture. Each has been analyzed against the current codebase to identify the precise components, APIs, schema changes, and build order required. The architecture preserves existing patterns -- server component pages with client-side interactive wrappers, Prisma for data access, Radix-based UI primitives -- while extending them for new capabilities.

The most architecturally significant change is **internal projects** (making `companyId` optional on `Project`), because it touches the core entity model and ripples through API routes, forms, list filters, and pipeline conversions. The safest integration order starts with isolated UI fixes (modal scroll), progresses through additive features (standalone CRM pages, task creation), and ends with schema-altering changes (internal projects, line item pricing).

---

## Current Architecture Overview

### Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| `src/app/(dashboard)/*/page.tsx` | Server Components: fetch data from Prisma, pass to client | Prisma ORM, client components |
| `src/components/*/` | Client Components: interactive UI, API calls for mutations | API routes via `fetch()` |
| `src/app/api/*/route.ts` | API Routes: CRUD operations, auth checks | Prisma ORM, auth utilities |
| `src/lib/nav-config.ts` | Sidebar navigation structure: groups, items, roles | Sidebar component |
| `src/lib/hooks/use-nav-collapse-state.ts` | localStorage-persisted sidebar group expand/collapse | Sidebar component |
| `src/components/ui/detail-view.tsx` | Detail panel wrapper: Dialog or Drawer mode | Radix Dialog/Sheet, ScrollArea |
| `src/components/ui/dialog.tsx` | Base dialog primitive: Radix-based with mobile slide-up | All modal consumers |
| `src/types/ai-extraction.ts` | AI extraction type definitions | AI import routes, review sheets |
| `prisma/schema.prisma` | Database schema: all models, enums, relations | All server-side code |

### Data Flow Pattern (Standard)

```
Server Component (page.tsx)
  --> Prisma query (server-side)
  --> Serialize Decimal/Date fields
  --> Pass as props to Client Component (*-page-client.tsx or *-list.tsx)

Client Component
  --> Local state management (useState)
  --> Mutations via fetch() to /api/* routes
  --> router.refresh() or local state update after mutation
```

### Current Schema Key Points

- **Project.companyId** is `String` (required, NOT optional) with `@map("company_id")`
- **Department** belongs to Company (companyId required, with unique compound `[companyId, name]`)
- **Contact** belongs to Company (companyId required), optional departmentId
- **Task** belongs to Project (projectId required), has self-referencing parentId for subtasks
- **Cost** has description, amount (Decimal), optional supplierId, optional normalizedItem
- **InvoiceLineItem** type has optional `quantity` and `unitPrice` fields (already in TypeScript types, but NOT persisted to DB -- only `amount` is stored in Cost model)

---

## Feature-by-Feature Architecture Integration

### 1. Standalone Departments Page (`/departments`)

**Current state:** Departments are managed inside `CompanyDetailModal` via `DepartmentSection` component. They are scoped to a specific company (API: `GET /api/companies/[id]/departments`).

**Integration approach:**

```
New Files:
  src/app/(dashboard)/departments/page.tsx          -- Server Component
  src/components/departments/departments-page-client.tsx  -- Client Component

Reuse:
  src/components/companies/department-card.tsx       -- Already exists
  src/components/companies/department-form.tsx       -- Already exists (needs companyId prop)
```

**Data flow:**

```
/departments page.tsx
  --> Prisma: department.findMany({ include: { company, _count: { contacts, deals, potentials } } })
  --> Pass to DepartmentsPageClient

DepartmentsPageClient
  --> Search/filter bar (by company, by name)
  --> Table view listing all departments across companies
  --> Click row --> open department detail (reuse DepartmentSection pattern)
  --> "Add Department" button --> modal with company select + department form
```

**API changes:**

```
New: GET /api/departments                -- List all departments across companies
     POST /api/departments               -- Create department (companyId in body)
Existing: PATCH/DELETE remain at /api/companies/[id]/departments/[deptId]
```

**Nav config change:**

```typescript
// In navGroups CRM section, add:
{ name: 'Departments', href: '/departments', icon: Building }
```

**Schema changes:** None. Department model already has all needed fields.

**Risk:** LOW. Purely additive -- new page, new list API. Existing company detail modal continues to work unchanged.

---

### 2. Standalone Contacts Page (`/contacts`)

**Current state:** Contacts are managed inside `CompanyDetailModal` via `ContactCard` components. They are scoped to a specific company (API: `GET /api/companies/[id]/contacts`).

**Integration approach:**

```
New Files:
  src/app/(dashboard)/contacts/page.tsx             -- Server Component
  src/components/contacts/contacts-page-client.tsx   -- Client Component

Reuse:
  src/components/companies/contact-card.tsx          -- Already exists
  src/components/companies/contact-form.tsx          -- Already exists (needs companyId)
```

**Data flow:**

```
/contacts page.tsx
  --> Prisma: contact.findMany({
        include: { company: { select: { id, name } },
                   department: { select: { id, name } } },
        orderBy: { name: 'asc' }
      })
  --> Pass to ContactsPageClient

ContactsPageClient
  --> Search bar + filters (company, department, role)
  --> Table view: Name | Company | Department | Role | Email | Phone
  --> Click row --> open contact detail (inline edit like ContactCard)
  --> "Add Contact" button --> modal with company select, then contact form
```

**API changes:**

```
New: GET /api/contacts                   -- List all contacts across companies
     POST /api/contacts                  -- Create contact (companyId in body)
Existing: PATCH/DELETE remain at /api/companies/[id]/contacts/[contactId]
```

**Nav config change:**

```typescript
// In navGroups CRM section, add:
{ name: 'Contacts', href: '/contacts', icon: UserRound }
```

**Schema changes:** None. Contact model already has all needed fields.

**Risk:** LOW. Same pattern as Departments -- additive page with new list endpoint.

---

### 3. Task Creation on `/tasks` Page

**Current state:** The `/tasks` page (`tasks-page-client.tsx`) has a 6-filter bar, table/kanban views, and a detail sheet. But there is NO "Add Task" button. The existing `TaskForm` component requires a `projectId` prop because tasks belong to projects. The `getProjects()` function in the server component only fetches projects that already have tasks.

**Integration approach:**

```
Modified Files:
  src/app/(dashboard)/tasks/page.tsx                 -- Fetch ALL active projects (not just those with tasks)
  src/components/tasks/tasks-page-client.tsx          -- Add "Add Task" button + modal state

New Files:
  src/components/tasks/add-task-modal.tsx             -- Modal wrapping task form + project select

Reuse:
  src/components/projects/task-form.tsx               -- Existing form (already accepts projectId)
```

**Data flow:**

```
tasks/page.tsx (modified)
  --> getProjects() changed to: prisma.project.findMany({
        where: { isArchived: false },   // ALL active projects, not just those with tasks
        select: { id, title },
        orderBy: { title: 'asc' }
      })

AddTaskModal
  --> Step 1: Select project (project combobox/select)
  --> Step 2: TaskForm appears with selected projectId
  --> On success: router.refresh() to reload server data

TasksPageClient (modified)
  --> Add "Add Task" button next to view toggle
  --> allProjects prop (all active projects for the modal)
  --> projects prop remains (for filter bar -- projects with tasks)
```

**API changes:** None. Task creation already works via `POST /api/projects/[id]/tasks`.

**Schema changes:** None.

**Key decisions:**
- The project selection should be a searchable combobox (reuse `CompanySelect` pattern with Command component)
- After creating a task, call `router.refresh()` to re-fetch server data (existing pattern)
- The "Add Task" button appears in the header area, next to the view toggle

**Risk:** LOW. Uses existing API and form. Only adds a modal wrapper with project selection.

---

### 4. Internal Project Flag

**Current state:** `Project.companyId` is a required `String` field in the schema. The `POST /api/projects` route validates `companyId` is present. The `ProjectFormModal` requires company selection. All project listings include `company` relation.

**Integration approach:**

This is the most impactful change because `companyId` is currently required everywhere.

**Schema changes:**

```prisma
model Project {
  // Change companyId from required to optional
  companyId    String?  @map("company_id")   // Was: String (required)
  company      Company? @relation(...)        // Was: Company (required)

  // Add internal flag
  isInternal   Boolean  @default(false) @map("is_internal")
}
```

**Migration strategy:**

```sql
-- 1. Make companyId nullable
ALTER TABLE projects MODIFY COLUMN company_id VARCHAR(191) NULL;

-- 2. Add isInternal column
ALTER TABLE projects ADD COLUMN is_internal BOOLEAN NOT NULL DEFAULT FALSE;

-- 3. No data migration needed -- existing projects keep their companyId
```

**API changes:**

```typescript
// POST /api/projects (modified)
// companyId is no longer required IF isInternal is true
if (!body.isInternal && !body.companyId) {
  return NextResponse.json({ error: 'Company is required for external projects' }, { status: 400 })
}

// For internal projects, auto-set company to null
data: {
  title: body.title.trim(),
  companyId: body.isInternal ? null : body.companyId,
  isInternal: body.isInternal || false,
  // ...rest
}
```

**Component changes:**

```
Modified:
  src/components/projects/project-form-modal.tsx
    --> Add "Internal Project" toggle (Switch component)
    --> When toggled ON: hide company select, set companyId = null
    --> When toggled OFF: show company select (required)
    --> Pre-populate switch based on context

  src/app/(dashboard)/projects/page.tsx
    --> Add "Internal" filter option

  src/app/api/projects/route.ts
    --> Relax companyId validation when isInternal=true

  All project list components:
    --> Display "Internal" badge when isInternal=true and company is null
    --> company.name display should handle null: company?.name || 'Internal'
```

**Ripple effects to check:**

| Location | Impact | Fix |
|----------|--------|-----|
| `GET /api/projects` | `include: { company }` returns null | Already handles with `select` |
| Project detail page | Shows company info | Conditional render: company section or "Internal" badge |
| Deal/Potential conversion | Sets companyId from source | No change -- converted projects always have company |
| Dashboard stats | Revenue queries may group by company | Add `isInternal` filter/group |
| Project card | Shows company name | Handle `company?.name \|\| 'Internal'` |

**Risk:** MEDIUM. Schema change is backward-compatible (nullable column). But every component displaying project.company must handle null. Recommend thorough review of all project-related components.

---

### 5. Customizable Sidebar

**Current state:**
- `src/lib/nav-config.ts` defines `navGroups` (SAAP, CRM, Admin) and `topLevelItems` (Tasks, Members)
- `NavGroup` interface: `{ key, label, items, requireRole? }`
- `Sidebar` component renders groups with `NavGroupComponent` (collapsible), top-level items, and settings link
- `useNavCollapseState` hook persists expand/collapse in localStorage
- Groups are hardcoded in the config file -- no per-user customization

**Integration approach -- Two levels of customization:**

**Level 1 (Recommended for v2.3): Item visibility and ordering**

```
New:
  src/lib/hooks/use-sidebar-config.ts     -- Hook for loading/saving sidebar prefs

Modified:
  src/lib/nav-config.ts                   -- Add item IDs for persistence
  src/components/layout/sidebar.tsx        -- Apply user overrides
  src/app/(dashboard)/settings/page.tsx    -- Add sidebar customization section
  src/app/api/user/preferences/route.ts   -- Handle sidebarConfig in preferences
```

**Schema changes:**

```prisma
model UserPreferences {
  // Add to existing model:
  sidebarConfig  Json?  @db.Json  @map("sidebar_config")
  // Shape: { hiddenItems: string[], groupOrder: string[] }
}
```

**Data flow:**

```
Settings page
  --> Render nav groups with checkboxes for each item
  --> Drag-to-reorder groups (optional, can defer)
  --> Save to PATCH /api/user/preferences { sidebarConfig: { hiddenItems, groupOrder } }

Sidebar component (modified)
  --> Load user preferences via useSidebarConfig() hook
  --> Filter out hiddenItems from navGroups
  --> Reorder groups per groupOrder
  --> Fall back to default config if no preferences
```

**Level 2 (Future): Full drag-drop reorder**

Defer to v2.4+. Requires more complex state management and potentially a dedicated sidebar editor UI.

**Key decision:** Use `UserPreferences.sidebarConfig` (JSON field) rather than a new table. This follows the existing pattern where `dashboardLayout` and `dateFilter` are stored as JSON in UserPreferences.

**Nav config changes for v2.3 new pages:**

```typescript
// Updated CRM group
{
  key: 'crm',
  label: 'CRM',
  items: [
    { name: 'Companies', href: '/companies', icon: Building2 },
    { name: 'Departments', href: '/departments', icon: Building },       // NEW
    { name: 'Contacts', href: '/contacts', icon: UserRound },            // NEW
    { name: 'Pipeline', href: '/pipeline', icon: Funnel },
    { name: 'Potential Projects', href: '/potential-projects', icon: FolderKanban },
    { name: 'Projects', href: '/projects', icon: Briefcase },
    { name: 'Suppliers', href: '/suppliers', icon: Truck },
    { name: 'Price Comparison', href: '/supplier-items', icon: Scale },
  ],
},
```

**Risk:** LOW-MEDIUM. The item visibility approach is simple and reversible. Group reorder adds complexity but is optional. The key risk is ensuring the sidebar always shows at least the Dashboard item (prevent user from hiding everything).

---

### 6. Modal Scroll Fix

**Current state:**
- `DetailView` component already wraps content in `ScrollArea` for both dialog and drawer modes
- Base `DialogContent` (in `dialog.tsx`) has `overflow-y-auto` and `md:max-h-[85vh]`
- Some modals that DON'T use `DetailView` but use raw `Dialog` + `DialogContent` may have scroll issues

**Root cause analysis:**

The `DialogContent` primitive has `overflow-y-auto` which should enable scrolling. However, it also has `flex flex-col` AND a mobile `h-[calc(100vh-2rem)]` with desktop `md:h-auto md:max-h-[85vh]`. The issue occurs when:

1. **Content exceeds max-height but inner elements don't have proper flex layout**: The `p-6` padding and `gap-4` are on the content container, but children may push beyond without scrolling if they have fixed heights or their own overflow handling.

2. **Nested scroll contexts**: When a modal's body has its own ScrollArea but the dialog also has overflow-y-auto, they can conflict.

3. **Missing `min-h-0` on flex children**: In flexbox layouts, children default to `min-height: auto` which prevents shrinking below content size. The `DetailView` already applies `min-h-0` to its ScrollArea, but raw Dialog users don't.

**Fix approach -- Two-part:**

**Part A: Fix base DialogContent** (addresses all dialogs globally)

```typescript
// dialog.tsx DialogContent -- ensure flex children can shrink
// Current: "overflow-y-auto" on the content itself
// Problem: Children don't shrink properly

// Fix: Add flex layout with proper min-height on mobile
"fixed z-50 w-full gap-4 border bg-background shadow-lg duration-200",
// Mobile
"inset-x-0 bottom-0 h-[calc(100vh-2rem)] rounded-t-2xl flex flex-col",
// Desktop
"md:inset-auto md:left-[50%] md:top-[50%] md:translate-x-[-50%] md:translate-y-[-50%] md:h-auto md:max-h-[85vh] md:max-w-lg md:rounded-lg",
// KEY CHANGE: Remove p-6 from container (let children pad themselves)
// and ensure overflow is on flex-1 child, not container
```

**Part B: Audit specific modals**

Modals that don't use `DetailView` need ScrollArea wrapping for their body content:

| Modal | File | Uses DetailView? | Needs Fix? |
|-------|------|------------------|------------|
| CompanyDetailModal | `companies/company-detail-modal.tsx` | YES | NO (already scrolls) |
| AIReviewSheet | `ai/ai-review-sheet.tsx` | NO (raw Dialog) | Possibly -- has ScrollArea but manual layout |
| ProjectFormModal | `projects/project-form-modal.tsx` | NO (raw Dialog) | YES -- no ScrollArea, relies on dialog overflow |
| Add Company dialog | `companies/company-list.tsx` | NO (inline Dialog) | Possibly -- small form, unlikely to overflow |
| Cost form | `projects/cost-form.tsx` | Inline form, not modal | N/A |
| Task form | `projects/task-form.tsx` | Inline form, not modal | N/A |

**Recommended fix pattern for non-DetailView modals:**

```tsx
<DialogContent className="sm:max-w-md p-0 flex flex-col">
  <DialogHeader className="p-6 pb-4 shrink-0">
    <DialogTitle>...</DialogTitle>
  </DialogHeader>
  <ScrollArea className="flex-1 min-h-0 px-6">
    {/* form / content here */}
  </ScrollArea>
  <DialogFooter className="p-6 pt-4 shrink-0 border-t">
    {/* buttons */}
  </DialogFooter>
</DialogContent>
```

This mirrors the pattern already used by `DetailView` in dialog mode.

**Risk:** LOW. The DialogContent fix is a CSS change. Individual modal audits are low-risk refactors.

---

### 7. Line Item Pricing History

**Current state:**
- `InvoiceLineItem` TypeScript type already has `quantity?: number` and `unitPrice?: number`
- AI invoice instruction (`document-invoice.md`) already extracts quantity and unitPrice
- BUT: When invoices are imported, only `Cost.amount` is saved to DB (the total line amount)
- `Cost` model has no `quantity` or `unitPrice` fields
- The supplier-items price comparison page (`/supplier-items`) shows `normalizedItem` + `amount` per cost entry -- no quantity/unit price breakdown

**Schema changes:**

```prisma
model Cost {
  // Add new fields (all optional for backward compatibility)
  quantity    Decimal?  @db.Decimal(12, 4)  // Allow fractional qty (e.g., 0.5 days)
  unitPrice   Decimal?  @map("unit_price") @db.Decimal(12, 2)

  // Existing amount field remains as the line total (quantity * unitPrice)
  // For manually-entered costs, amount is entered directly (qty/unitPrice remain null)
}
```

**Migration:**

```sql
ALTER TABLE costs ADD COLUMN quantity DECIMAL(12,4) NULL;
ALTER TABLE costs ADD COLUMN unit_price DECIMAL(12,2) NULL;
-- No data migration -- existing costs keep null for these fields
```

**API changes:**

```typescript
// POST /api/projects/[id]/costs (modified)
// Accept optional quantity and unitPrice
data: {
  description,
  amount,
  quantity: body.quantity ? parseFloat(body.quantity) : null,
  unitPrice: body.unitPrice ? parseFloat(body.unitPrice) : null,
  // ...rest
}

// POST /api/ai/import/invoice (modified)
// When creating costs from AI extraction, include quantity and unitPrice
// Currently invoice import only sets project.revenue -- it does NOT create individual Cost entries
// This is a GAP: invoice line items are NOT persisted as costs today
```

**Critical finding:** The current invoice import flow (`/api/ai/import/invoice`) does NOT create individual `Cost` entries from line items. It only:
1. Updates `project.revenue` with the extraction total
2. Marks the document as IMPORTED

Receipt import (`/api/ai/import/receipt`) DOES create individual cost entries. This is an important distinction.

**For line item pricing history to work, the invoice import must also create Cost entries.** This is a significant addition beyond just adding fields.

**Component changes:**

```
Modified:
  src/components/projects/cost-form.tsx
    --> Add optional quantity and unitPrice fields
    --> Auto-calculate: if both provided, amount = quantity * unitPrice
    --> If amount entered directly, qty/unitPrice stay null

  src/components/projects/cost-card.tsx
    --> Display quantity and unitPrice when present
    --> Format: "100 x RM 5.00 = RM 500.00"

  src/components/supplier-items/supplier-items-table.tsx
    --> Add Qty and Unit Price columns (hidden on mobile)
    --> Enable price comparison on unitPrice basis (not just total amount)

  src/app/api/ai/import/invoice/route.ts
    --> Create Cost entries for each selected line item (like receipt import does)
    --> Set quantity, unitPrice, amount from extraction data
    --> Set aiImported = true

  src/components/ai/ai-review-sheet.tsx
    --> Already shows quantity/unitPrice in extraction table
    --> No changes needed for display
    --> Ensure import payload includes qty/unitPrice
```

**Data flow for pricing history:**

```
Invoice uploaded
  --> AI extracts line items with quantity, unitPrice, amount
  --> User reviews in AIReviewSheet (already shows qty/unitPrice)
  --> User clicks "Import"
  --> API creates Cost entries WITH quantity + unitPrice (NEW behavior)
  --> Cost entries appear in project detail and supplier-items page
  --> Supplier-items page shows unit price for comparison across projects
```

**Risk:** MEDIUM-HIGH. This involves:
1. Schema migration (adding columns -- low risk)
2. Changing invoice import behavior to create Cost entries (medium risk -- must not double-count with revenue)
3. Updating cost forms and displays (low risk)
4. The revenue calculation must remain correct: `project.revenue` from invoice total, individual `Cost` entries for line items (costs are expenses, not revenue)

**Important clarification:** Looking at the data model more carefully: Costs are **expenses** (money going out), while invoice import sets **revenue** (money coming in). Invoices issued BY Motionvii/Talenta to clients represent revenue. Receipts/invoices FROM suppliers represent costs. The line item pricing history applies primarily to supplier invoices (costs), not client invoices (revenue).

The existing architecture already distinguishes:
- `project.revenue` -- set by AI invoice import (client invoices)
- `Cost` entries -- created by AI receipt import (supplier receipts)

For pricing history, the focus should be on **receipt import** (which already creates Cost entries) and **manual cost entry** (via CostForm). The receipt import should persist quantity/unitPrice when extractable.

---

## Recommended Architecture

### Component Diagram

```
                    +-----------------+
                    |  nav-config.ts  |  <-- Add Departments, Contacts items
                    +--------+--------+
                             |
                    +--------v--------+
                    |   sidebar.tsx   |  <-- Apply user sidebar prefs
                    +--------+--------+
                             |
        +--------------------+--------------------+
        |                    |                    |
+-------v------+    +-------v------+    +--------v------+
| /departments |    |  /contacts   |    |    /tasks     |
|  (NEW page)  |    |  (NEW page)  |    | (ADD button)  |
+--------------+    +--------------+    +-------+-------+
                                                |
                                        +-------v-------+
                                        | AddTaskModal  |
                                        | (project sel) |
                                        +-------+-------+
                                                |
                                    +-----------v-----------+
                                    | TaskForm (existing)   |
                                    | projectId from modal  |
                                    +-----------------------+

+-------------------+           +-------------------+
| project-form-modal|  <------- | Internal toggle   |
| (MODIFIED)        |           | (companyId optional|
+-------------------+           +-------------------+

+-------------------+           +-------------------+
| dialog.tsx        |  <------- | Scroll fix        |
| (MODIFIED)        |           | (CSS + layout)    |
+-------------------+           +-------------------+

+-------------------+           +-------------------+
| Cost model        |  <------- | qty + unitPrice   |
| (SCHEMA CHANGE)   |           | fields added      |
+-------------------+           +-------------------+
```

### Data Flow

**New standalone pages (Departments, Contacts):**

```
Page (server) --> Prisma findMany (all records) --> Client List Component
  --> Search/filter (client-side)
  --> Row click --> Detail modal (fetch single record)
  --> Mutations --> API routes --> Prisma --> router.refresh()
```

**Task creation from /tasks:**

```
"Add Task" button --> AddTaskModal opens
  --> User selects project (searchable combobox)
  --> TaskForm renders with selected projectId
  --> POST /api/projects/[id]/tasks
  --> router.refresh() reloads all tasks
```

**Internal projects:**

```
ProjectFormModal
  --> "Internal Project" Switch
  --> ON: hide company select, isInternal=true, companyId=null
  --> OFF: show company select (required), isInternal=false
  --> POST /api/projects { isInternal, companyId?, ... }
  --> Schema: companyId? (nullable), isInternal Boolean
```

**Pricing history:**

```
Cost entry (manual or AI):
  --> CostForm: optional qty + unitPrice --> auto-calc amount
  --> Receipt import: AI extraction includes qty/unitPrice --> persist to Cost
  --> SupplierItems page: show unitPrice column for comparison
```

---

## Schema Changes Summary

```prisma
// === Project model ===
model Project {
  companyId    String?  @map("company_id")    // CHANGED: String? (was String)
  company      Company? @relation(...)         // CHANGED: Company? (was Company)
  isInternal   Boolean  @default(false) @map("is_internal")  // NEW
}

// === Cost model ===
model Cost {
  quantity    Decimal?  @db.Decimal(12, 4)     // NEW
  unitPrice   Decimal?  @map("unit_price") @db.Decimal(12, 2)  // NEW
}

// === UserPreferences model ===
model UserPreferences {
  sidebarConfig  Json?  @db.Json @map("sidebar_config")  // NEW
}
```

**Migration count:** 1 migration with 3 ALTER TABLE statements (can be combined).

---

## Patterns to Follow

### Pattern 1: Standalone Entity Page (for Departments, Contacts)

Follow the exact pattern used by Companies and Suppliers pages:

```typescript
// page.tsx (server component)
export default async function EntityPage({ searchParams }) {
  const items = await prisma.entity.findMany({
    include: { /* relations */ },
    orderBy: { name: 'asc' },
  })
  return <EntityList initialData={items} />
}

// entity-list.tsx (client component)
export function EntityList({ initialData }) {
  const [items, setItems] = useState(initialData)
  const [search, setSearch] = useState('')
  // ... filters, table, detail modal
}
```

### Pattern 2: Modal with Project Selection (for Task creation)

Follow the CompanySelect pattern already used in pipeline forms:

```typescript
// Searchable combobox for project selection
<ProjectSelect value={projectId} onValueChange={setProjectId} />
// Then render existing form with selected ID
{projectId && <TaskForm projectId={projectId} onSuccess={handleSuccess} />}
```

### Pattern 3: Optional Relation with Flag (for Internal Projects)

```typescript
// Conditional validation in API
if (!body.isInternal && !body.companyId) {
  return error('Company required for external projects')
}
// Display fallback in UI
{project.company?.name || (project.isInternal ? 'Internal' : 'No company')}
```

### Pattern 4: ScrollArea in Modal Bodies (for scroll fix)

```tsx
// Standard scrollable modal layout
<DialogContent className="p-0 flex flex-col">
  <DialogHeader className="p-6 pb-4 shrink-0">{/* ... */}</DialogHeader>
  <ScrollArea className="flex-1 min-h-0">
    <div className="px-6 py-4">{/* content */}</div>
  </ScrollArea>
  <DialogFooter className="p-6 pt-4 shrink-0 border-t">{/* ... */}</DialogFooter>
</DialogContent>
```

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Duplicating CRM Components

**What:** Creating entirely new department/contact components for standalone pages instead of reusing existing ones.
**Why bad:** Code duplication, divergent behavior between company detail modal and standalone pages.
**Instead:** Extract shared components. The existing `DepartmentCard`, `DepartmentForm`, `ContactCard`, `ContactForm` should be reused. Only create new list/table wrappers.

### Anti-Pattern 2: Making companyId Optional Without Null Guards

**What:** Changing `Project.companyId` to optional in schema but not auditing every `project.company.name` access.
**Why bad:** Runtime crashes when accessing `.name` on null company.
**Instead:** Grep for all `project.company` usages and add null guards before deploying the migration.

### Anti-Pattern 3: Creating Sidebar Config as Separate Table

**What:** Creating a new `SidebarConfig` model for user sidebar preferences.
**Why bad:** Over-engineering. The existing `UserPreferences.Json` pattern works perfectly for this.
**Instead:** Add `sidebarConfig Json?` to the existing `UserPreferences` model.

### Anti-Pattern 4: Storing Line Item Details Separately from Cost

**What:** Creating a new `LineItem` model to store quantity/unitPrice separately from `Cost`.
**Why bad:** Unnecessary complexity. A Cost IS a line item. Adding optional fields to Cost is simpler and maintains the existing data model.
**Instead:** Add `quantity` and `unitPrice` as optional Decimal fields on the existing `Cost` model.

---

## Build Order (Dependencies)

```
Phase order based on dependencies:

1. Modal Scroll Fix
   Dependencies: None
   Blocked by: Nothing
   Blocks: Nothing (but improves UX for all subsequent features)

2. Standalone Departments Page
   Dependencies: None (schema already supports it)
   Blocked by: Nothing
   Blocks: Nothing

3. Standalone Contacts Page
   Dependencies: None
   Blocked by: Nothing (can parallel with Departments)
   Blocks: Nothing

4. Nav Config Update (add Departments, Contacts to sidebar)
   Dependencies: Departments and Contacts pages must exist
   Blocked by: #2, #3

5. Task Creation on /tasks
   Dependencies: None
   Blocked by: Nothing
   Blocks: Nothing

6. Internal Project Flag
   Dependencies: None technically, but impacts many components
   Blocked by: Nothing
   Blocks: Nothing
   NOTE: Schedule last among features due to broad impact

7. Customizable Sidebar (Settings UI)
   Dependencies: Nav config must be stable (all new items added)
   Blocked by: #4 (nav config update)
   Blocks: Nothing

8. Line Item Pricing History
   Dependencies: None technically
   Blocked by: Nothing
   Blocks: Nothing
   NOTE: Most complex feature -- schema change + API behavior change + UI updates
```

**Recommended grouping:**

```
Batch 1 (Quick wins, no schema changes):
  - Modal scroll fix
  - Task creation on /tasks

Batch 2 (Additive pages, no schema changes):
  - Standalone Departments page
  - Standalone Contacts page
  - Nav config update (add new items)

Batch 3 (Schema changes, careful rollout):
  - Internal project flag (schema + broad UI audit)
  - Customizable sidebar (schema + settings UI)

Batch 4 (Complex integration):
  - Line item pricing history (schema + API behavior + forms + display)
```

---

## Scalability Considerations

| Concern | Current Scale | v2.3 Impact |
|---------|---------------|-------------|
| Departments count | ~20-50 across companies | Standalone page loads all -- fine at this scale |
| Contacts count | ~50-200 across companies | Standalone page loads all -- fine; add pagination if >500 |
| Tasks across projects | ~100-500 | Task creation adds more tasks; existing table handles well |
| Sidebar config | Per-user JSON | Minimal storage, loaded once per session |
| Cost entries | ~200-1000 | Adding qty/unitPrice is 2 nullable columns -- no perf impact |
| Company-less projects | 0 currently | Internal projects are a small fraction; null companyId is fine |

---

## Sources

- Direct codebase analysis (HIGH confidence): All findings based on reading actual source files
- `prisma/schema.prisma` -- Full schema with all models and relations
- `src/lib/nav-config.ts` -- Navigation structure
- `src/components/ui/detail-view.tsx` -- DetailView wrapper component
- `src/components/ui/dialog.tsx` -- Base dialog primitive
- `src/components/tasks/tasks-page-client.tsx` -- Tasks page client component
- `src/components/companies/company-detail-modal.tsx` -- Company detail with departments/contacts
- `src/components/projects/project-form-modal.tsx` -- Project creation form
- `src/components/projects/cost-form.tsx` -- Cost entry form
- `src/components/ai/ai-review-sheet.tsx` -- AI extraction review
- `src/types/ai-extraction.ts` -- InvoiceLineItem with quantity/unitPrice
- `src/app/api/ai/import/invoice/route.ts` -- Invoice import (revenue only, no Cost creation)
- `.claude/skills/ai-analyze/instructions/document-invoice.md` -- AI extraction instructions
