# Feature Landscape

**Domain:** Internal business platform -- Settings, Sidebar & Bug Fixes (v2.4)
**Researched:** 2026-01-28
**Confidence:** HIGH (all findings derived from direct codebase analysis)

---

## Table Stakes

Features users expect. Missing = product feels incomplete or buggy.

### F-01: Sidebar Settings Persistence Fix (autoReveal too aggressive)

| Aspect | Detail |
|--------|--------|
| Why Expected | When a user hides a nav item, navigating to that URL via bookmark/deep link re-shows it permanently. This defeats the purpose of hiding items. |
| Complexity | Low |
| Current Behavior | `useNavVisibility.autoReveal()` fires on every pathname change. If a hidden item's href matches the current pathname, it is immediately un-hidden and persisted to the API. The user never intended to re-show it -- they just followed a link. |
| Root Cause | `autoReveal` in `src/lib/hooks/use-nav-visibility.ts` lines 73-99 automatically removes matching hidden items and persists via PATCH to `/api/user/preferences`. There is no user intent signal -- it always fires. |

**Expected Behaviors:**
1. Hidden nav items stay hidden regardless of which URL the user navigates to.
2. The only way to un-hide an item is through the Settings page toggle.
3. Remove the `autoReveal` function entirely, or make it opt-in via a separate user preference.

**Edge Cases:**
- User bookmarks `/departments` but has hidden "Departments" from sidebar. Current: item reappears. Expected: item stays hidden, page still accessible.
- User shares a link to `/contacts`. Recipient has it hidden. Current: it gets un-hidden for recipient. Expected: stays hidden, page works fine.

**Implementation Notes:**
- Remove the `useEffect` calling `autoReveal(pathname)` in `src/components/layout/sidebar.tsx` line 21-23.
- Remove or deprecate `autoReveal` from the hook, or gate it behind a preference (`autoRevealHiddenNav: boolean` in UserPreferences).
- The `isVisible` filter on the sidebar is correct and should remain -- it just should not auto-mutate.

---

### F-02: Sidebar Settings Save Button (explicit save vs fire-and-forget)

| Aspect | Detail |
|--------|--------|
| Why Expected | Currently each toggle fires an immediate PATCH to `/api/user/preferences` (fire-and-forget in `toggleItem`). Users toggling multiple items rapidly generate multiple API calls. A "Save" button provides clear user intent and reduces API chatter. |
| Complexity | Low-Medium |
| Current Behavior | `toggleItem` in `use-nav-visibility.ts` lines 48-67 optimistically updates state and immediately persists. No batch, no save button. |

**Expected Behaviors:**
1. Settings page shows toggle switches with local-only state changes (no API call on toggle).
2. A "Save" button appears (or becomes enabled) when local state differs from persisted state.
3. Clicking Save persists all changes in a single PATCH call.
4. A "Reset" or "Cancel" option reverts to the last saved state.
5. Navigating away with unsaved changes shows a confirmation prompt.

**Edge Cases:**
- User toggles 5 items, then navigates away without saving -- should prompt "Unsaved changes".
- User toggles an item off then on again (net zero change) -- Save button should not appear (state matches persisted).
- Browser crash during editing -- acceptable to lose unsaved changes.

**Implementation Notes:**
- Modify the Settings page (`src/app/(dashboard)/settings/page.tsx`) to maintain local `pendingHiddenItems` state separate from the hook's `hiddenItems`.
- Add dirty-checking: compare `pendingHiddenItems` with `hiddenItems` from the hook.
- Add a `saveHiddenItems(items: string[])` function to the hook that batches the PATCH.
- Use `beforeunload` event or Next.js router events for unsaved-changes warning.

---

### F-03: Completed Projects Remain Fully Editable

| Aspect | Detail |
|--------|--------|
| Why Expected | In a 3-person team, "Completed" is a status marker, not a permission lock. Team members need to add costs, update revenue, upload documents, and correct data after marking a project as completed. Read-only locks would create friction. |
| Complexity | Low |
| Current Behavior | **No read-only restrictions exist.** The project form modal (`project-form-modal.tsx`) is create-only. The detail sheet (`project-detail-sheet.tsx`) handles editing for all statuses. The API routes (`/api/projects/[id]`) do not check status before allowing updates. Projects of any status are fully editable already. |

**Expected Behaviors:**
1. All project fields remain editable regardless of status (DRAFT, ACTIVE, COMPLETED, CANCELLED).
2. Costs can be added/edited on completed projects.
3. Documents can be uploaded/analyzed on completed projects.
4. Tasks can be created/updated on completed projects.
5. Status can be changed back from COMPLETED to ACTIVE if needed.
6. The Edit button on the detail page (`project-detail-page-client.tsx` line 365-369) works for all statuses.

**Edge Cases:**
- Archived projects (`isArchived: true`) -- these currently have no edit restrictions either but logically could. v2.4 scope: keep current behavior (fully editable), defer archive restrictions to a future milestone if desired.
- Bulk status change -- not currently implemented, out of scope.

**Implementation Notes:**
- This is essentially a "confirm current behavior is intentional" feature. No code changes needed.
- If the team wants a visual indicator (e.g., "This project is completed" banner on the edit form), that's a nice-to-have polish.
- Document this as an intentional design decision: status is informational, not a permission gate.

---

### F-04: Dashboard Revenue Widget Accuracy (include potentialRevenue)

| Aspect | Detail |
|--------|--------|
| Why Expected | The CRM KPI "Revenue" card shows RM 0 for projects that have `potentialRevenue` but no AI-imported `revenue` yet. Since most projects start with potentialRevenue (from deal/potential conversion) and only get actual revenue after invoice import, the dashboard understates revenue during active project lifecycle. |
| Complexity | Low |
| Current Bug Location | `src/app/(dashboard)/page.tsx` lines 182-186 in `getCRMDashboardData()` |

**Current Query (buggy):**
```typescript
const revenueResult = await prisma.project.aggregate({
  where: { status: 'COMPLETED' },
  _sum: { revenue: true }  // Only sums 'revenue', ignores 'potentialRevenue'
})
```

**Problems Identified:**
1. Only sums `revenue` field (from AI invoice import), ignoring `potentialRevenue` (from deal/potential conversion).
2. Only includes COMPLETED projects. Active projects with revenue/potentialRevenue are excluded.
3. The Revenue Target widget (`revenue-target.tsx`) uses a completely different data source -- `keyResult.actual` for REVENUE-type key results. These are two separate revenue concepts.

**Expected Behaviors:**
1. CRM KPI "Revenue" card should use `COALESCE(revenue, potentialRevenue, 0)` logic per project -- prefer actual revenue when available, fall back to potential revenue.
2. Include projects with status ACTIVE and COMPLETED (not just COMPLETED).
3. The Revenue Target widget should remain as-is (it tracks KR-level revenue metrics, not project-level).
4. The CRM KPI card subtitle should clarify what it shows (e.g., "Active + Completed" instead of just "Completed").

**Proposed Query Fix:**
```typescript
// Fetch all non-draft, non-cancelled projects with either revenue field
const projects = await prisma.project.findMany({
  where: {
    status: { in: ['ACTIVE', 'COMPLETED'] },
    OR: [
      { revenue: { not: null } },
      { potentialRevenue: { not: null } },
    ],
  },
  select: { revenue: true, potentialRevenue: true },
})

const totalRevenue = projects.reduce((sum, p) => {
  const rev = Number(p.revenue) || Number(p.potentialRevenue) || 0
  return sum + rev
}, 0)
```

**Edge Cases:**
- Project with both `revenue: 50000` and `potentialRevenue: 40000` -- should use `revenue` (50000), not sum both.
- Project with only `potentialRevenue: 30000` and no `revenue` -- should count 30000.
- Internal projects (`isInternal: true`) -- should be included in revenue if they have values.
- Draft projects -- should NOT be included (no committed revenue).
- Cancelled projects -- should NOT be included (deal fell through).

**Profit Calculation Impact:**
The profit calculation on line 195 (`profit = totalRevenue - totalCosts`) should also update since totalRevenue changes. Costs are already aggregated across all projects (not filtered by status), so fixing revenue to include more projects creates a more accurate picture.

---

## Differentiators

Features that set product apart. Not expected, but valued.

### F-05: Nested Sidebar Links (Company -> Departments/Contacts)

| Aspect | Detail |
|--------|--------|
| Value Proposition | Groups related CRM navigation items under a parent, reducing sidebar clutter. Companies, Departments, and Contacts are logically related (Departments belong to Companies, Contacts belong to Companies/Departments). Nesting them communicates hierarchy. |
| Complexity | Medium |
| Current Structure | All 8 CRM items are flat siblings under the "CRM" collapsible group. Departments and Contacts appear at the same level as Companies, Pipeline, Projects, etc. |

**Expected Behaviors:**
1. The "CRM" group continues to be a top-level collapsible section.
2. Within CRM, "Companies" becomes a parent item with a chevron/expand indicator.
3. Expanding "Companies" reveals indented sub-items: "Departments" and "Contacts".
4. Clicking "Companies" navigates to `/companies`. The expand/collapse is triggered by clicking the chevron, not the label.
5. "Companies" is highlighted when the user is on `/companies`, `/departments`, or `/contacts`.
6. Sub-items can individually be hidden via Settings.
7. If all sub-items are hidden, the parent "Companies" still shows but without the expand chevron.

**Data Model Changes:**
```typescript
// In nav-config.ts, extend NavItem:
export interface NavItem {
  name: string
  href: string
  icon: LucideIcon
  children?: NavItem[]  // New: nested sub-items
}

// CRM group items would become:
{
  name: 'Companies',
  href: '/companies',
  icon: Building2,
  children: [
    { name: 'Departments', href: '/departments', icon: Building },
    { name: 'Contacts', href: '/contacts', icon: Contact },
  ],
},
// Pipeline, Potential Projects, Projects, Suppliers, Pricing History remain flat
```

**UI Pattern:**
- Parent item: full-width row with icon, label, and small chevron on the right.
- Sub-items: indented ~24px from parent, slightly smaller font or lighter color.
- Collapse state stored in localStorage alongside group collapse state.
- Active state: parent highlighted when any child route is active.

**Edge Cases:**
- User hides "Companies" parent -- should sub-items also hide? Recommendation: Yes, hiding parent hides children.
- User hides all children but not parent -- parent shows without expand affordance.
- URL `/departments/abc123` -- should highlight both "Companies" parent and "Departments" child.
- Mobile sidebar (`mobile-sidebar.tsx`) must also support nested items.
- Settings page must show nested items with proper indentation and parent-child relationship.

---

### F-06: Sidebar Drag-and-Drop Reordering in Settings

| Aspect | Detail |
|--------|--------|
| Value Proposition | Lets each user customize nav item order to match their workflow. Khairul might want Projects first, Azlan might want Pipeline first. |
| Complexity | Medium-High |
| Existing DnD Infrastructure | Project already uses `@dnd-kit/core` ^6.3.1 and `@dnd-kit/sortable` ^10.0.0 for kanban boards. Can reuse the same library. |

**Expected Behaviors:**
1. Settings page shows nav items with drag handles.
2. Users can reorder items within a group (e.g., reorder CRM items).
3. Users can NOT move items between groups (keeps groups meaningful).
4. Order is persisted per-user in UserPreferences.
5. The sidebar renders items in the user's custom order.
6. A "Reset Order" button restores the default order from `nav-config.ts`.

**Data Model Changes:**
```typescript
// In UserPreferences (Prisma schema):
model UserPreferences {
  // ... existing fields ...
  navItemOrder  Json?  @map("nav_item_order") @db.Json
  // Format: { "saap": ["/", "/objectives", ...], "crm": [...], ... }
}

// In nav-config.ts, add ordering support:
export function getOrderedItems(
  group: NavGroup,
  customOrder?: string[]
): NavItem[] {
  if (!customOrder) return group.items
  const ordered = customOrder
    .map(href => group.items.find(item => item.href === href))
    .filter(Boolean) as NavItem[]
  // Add any new items not in custom order (future-proofing)
  const remaining = group.items.filter(
    item => !customOrder.includes(item.href)
  )
  return [...ordered, ...remaining]
}
```

**Implementation Pattern:**
- Use `@dnd-kit/sortable` with `SortableContext` wrapping each group's items in Settings.
- Each item gets a `useSortable` hook with `id = item.href`.
- On drag end, compute new order array and update local state.
- Save alongside hidden items using the batch Save button (from F-02).
- Sidebar reads `navItemOrder` from UserPreferences and applies ordering.

**Edge Cases:**
- New nav items added in future updates that aren't in the user's saved order -- append at end.
- Nav items removed in future updates -- filter them out silently.
- Drag reorder + visibility toggle interaction: hidden items maintain their position in the order for when they're re-shown.
- Top-level items (Tasks, Members) -- should these be reorderable? Recommendation: Yes, treat them as their own group "General".

---

### F-07: Admin-Configurable Field Visibility for Internal Projects

| Aspect | Detail |
|--------|--------|
| Value Proposition | Internal projects (isInternal=true) don't need company/contact fields but might need different fields. Admin can configure which fields show for internal vs external projects. |
| Complexity | Medium-High |
| Current Behavior | Internal projects hide company/contact selectors in the form modal and show internalEntity selector instead. This is hardcoded in `project-form-modal.tsx` and `project-detail-sheet.tsx`. |

**Expected Behaviors:**
1. Admin settings page (or section in existing settings) lets admin configure visible fields per project type.
2. Field categories: "Always show", "External only", "Internal only", "Optional".
3. Fields that can be configured: company, contact, initiative link, revenue, potentialRevenue, startDate, endDate, description.
4. The project form dynamically shows/hides fields based on configuration.
5. The project detail view follows the same field visibility rules.

**Data Model Changes:**
```typescript
// New field in AdminDefaults or new model:
// Option A: Extend AdminDefaults
model AdminDefaults {
  // ... existing fields ...
  fieldVisibility  Json?  @map("field_visibility") @db.Json
  // Format: {
  //   internal: { contact: false, company: false, initiative: true, ... },
  //   external: { internalEntity: false, company: true, ... }
  // }
}
```

**Edge Cases:**
- Admin hides "revenue" field for internal projects, but existing internal projects have revenue data -- data persists, just not shown in form.
- Non-admin users see the field visibility effects but cannot change the configuration.
- New fields added in future -- default to "Always show" if not in configuration.
- Field visibility vs field requirement: hiding a field should also make it non-required.

---

## Anti-Features

Features to explicitly NOT build. Common mistakes in this domain.

### AF-01: Full RBAC on Project Status Transitions

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| Status-based edit locking (e.g., "Completed projects are read-only") | 3-person team. Permission complexity creates friction without security benefit. Everyone trusts everyone. | Keep status purely informational. Any user can edit any project regardless of status. |

### AF-02: Complex Sidebar Configuration UI (tree editor, preview pane)

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| Building a full sidebar configuration tool with live preview, theme customization, icon selection | Massively over-engineered for 3 users. The current toggle-switch UI is the right level of complexity. | Add drag-to-reorder and nested items support, but keep the UI simple: switches + drag handles. |

### AF-03: Per-Widget Revenue Configuration

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| Letting users configure what "revenue" means per widget (include/exclude potentialRevenue, filter by status, etc.) | Creates confusion about what numbers mean. Revenue should have one consistent definition across the dashboard. | Fix the revenue calculation once (F-04) with clear COALESCE logic. All widgets use the same definition. |

### AF-04: Multi-Level Sidebar Nesting (3+ levels)

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| Supporting deeply nested sidebar navigation (e.g., Company -> Department -> Contacts -> Contact Detail) | Navigation becomes hard to scan. Deep nesting in sidebars is a UX anti-pattern -- each click to expand adds friction. | Support exactly two levels: group items and one level of children. Anything deeper uses page-level navigation. |

### AF-05: User-Configurable Sidebar Groups

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| Letting users create/rename/delete sidebar groups (SAAP, CRM, Admin) | Groups provide stable organizational structure. Customizable groups create confusion when team discusses features ("Is Pipeline under CRM or your custom group?"). | Keep groups fixed in code. Allow item reordering and visibility within groups only. |

### AF-06: Unsaved Changes Auto-Save Timer

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| Auto-saving settings changes on a timer (e.g., save after 3 seconds of inactivity) | Contradicts the explicit Save button pattern (F-02). Auto-save was the problem with the current toggleItem fire-and-forget. | Explicit Save button. Clear user intent. |

---

## Feature Dependencies

```
F-01 (autoReveal fix) ─────> F-02 (Save button)
  Remove auto-mutation         Batch persistence replaces fire-and-forget

F-02 (Save button) ─────────> F-06 (DnD reorder)
  Batch save infrastructure     Reorder uses same save mechanism

F-05 (Nested links) ────────> F-06 (DnD reorder)
  NavItem.children defined      Reorder must handle nested structure

F-03 (Completed editable) ──> (no dependencies, confirm-only)

F-04 (Revenue fix) ─────────> (no dependencies, standalone query fix)

F-07 (Field visibility) ────> (no dependencies, but benefits from
                                AdminDefaults model already existing)
```

**Dependency chain for sidebar work:** F-01 -> F-02 -> F-05 -> F-06

This means sidebar features should be built in this order:
1. Fix autoReveal bug (F-01)
2. Add Save button pattern (F-02)
3. Add nested nav items (F-05)
4. Add drag-to-reorder (F-06)

---

## MVP Recommendation

For v2.4 MVP, prioritize all table stakes plus one differentiator:

### Must Ship (Table Stakes)
1. **F-01: autoReveal fix** -- Bug fix, Low complexity. Removes user frustration.
2. **F-02: Save button** -- Completes the settings UX. Low-Medium complexity.
3. **F-03: Completed projects editable** -- Confirm/document existing behavior. Zero code changes.
4. **F-04: Revenue widget fix** -- Bug fix, Low complexity. Dashboard shows correct numbers.

### Should Ship (High-Value Differentiators)
5. **F-05: Nested sidebar links** -- Medium complexity. Reduces sidebar clutter meaningfully.

### Defer to Post-v2.4
- **F-06: DnD reorder** -- Medium-High complexity. Nice-to-have but not blocking anyone. The 3 users can tolerate default ordering.
- **F-07: Field visibility** -- Medium-High complexity. Current hardcoded internal/external field logic works fine. Only needed if team starts creating many internal projects with different field needs.

---

## Sources

All findings derived from direct codebase analysis:
- `src/lib/hooks/use-nav-visibility.ts` -- autoReveal behavior
- `src/lib/nav-config.ts` -- current flat navigation structure
- `src/app/(dashboard)/settings/page.tsx` -- current settings UI
- `src/app/(dashboard)/page.tsx` lines 182-195 -- CRM revenue calculation bug
- `src/components/dashboard/crm-kpi-cards.tsx` -- Revenue KPI display
- `src/components/dashboard/revenue-target.tsx` -- Revenue Target widget (separate from CRM KPIs)
- `src/app/(dashboard)/projects/[id]/project-detail-page-client.tsx` -- project detail, no read-only checks
- `src/components/projects/project-detail-sheet.tsx` -- project edit sheet, no status-based restrictions
- `prisma/schema.prisma` -- UserPreferences model, Project model fields
- `package.json` -- `@dnd-kit/sortable` ^10.0.0 already installed
