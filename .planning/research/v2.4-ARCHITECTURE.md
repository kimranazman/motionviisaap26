# Architecture Patterns: v2.4 Settings, Sidebar & Bug Fixes

**Domain:** Internal business platform - Sidebar navigation behavior, drag-and-drop reordering, nested nav links, completed project editing, field visibility admin config, dashboard revenue accuracy
**Researched:** 2026-01-28
**Confidence:** HIGH (based on direct codebase analysis of all relevant files)

## Executive Summary

v2.4 integrates six features into the existing SAAP architecture. Four of them touch the sidebar subsystem (`sidebar.tsx`, `mobile-sidebar.tsx`, `nav-config.ts`, `use-nav-visibility.ts`, `nav-group.tsx`), one removes a project editing restriction, one adds an admin config layer for internal project fields, and one fixes a dashboard revenue aggregation bug. None require schema migrations except the field visibility config (new JSON column on `AdminDefaults` or `UserPreferences`).

The sidebar subsystem is the highest-risk integration area. It currently operates with a clean separation: `nav-config.ts` defines static structure, `use-nav-visibility.ts` manages show/hide state, `use-nav-collapse-state.ts` manages group expand/collapse, and `nav-group.tsx` renders items as flat Link lists. Four of the six v2.4 features modify this subsystem, which means they must be sequenced carefully to avoid conflicting changes. The recommended build order starts with the autoReveal bug fix (pure logic change, no UI), then nested nav (structural change to NavItem type and rendering), then drag-and-drop reordering (builds on the new structure), and finally the independent features (completed project editing, field visibility, revenue fix).

---

## Current Architecture Overview

### Sidebar Subsystem Component Map

```
nav-config.ts (STATIC)
  Defines: NavItem {name, href, icon}, NavGroup {key, label, items[], requireRole?}
  Exports: navGroups[], topLevelItems[], settingsItem, ALWAYS_VISIBLE_HREFS
  Functions: isAlwaysVisible(), getAllNavHrefs(), findGroupForPath()

use-nav-visibility.ts (DYNAMIC - API-backed)
  State: hiddenItems[] (string hrefs)
  Source: GET /api/user/preferences -> hiddenNavItems
  Persist: PATCH /api/user/preferences -> { hiddenNavItems }
  Functions: isVisible(href), toggleItem(href), autoReveal(pathname)

use-nav-collapse-state.ts (DYNAMIC - localStorage)
  State: expandedGroups (Record<string, boolean>)
  Source: localStorage "sidebar-collapse-state"
  Functions: toggleGroup(key)

sidebar.tsx (DESKTOP RENDERER)
  Reads: navGroups, topLevelItems, settingsItem
  Uses: useNavCollapseState, useNavVisibility
  Renders: NavGroupComponent for each group, flat links for topLevel, settings link

mobile-sidebar.tsx (MOBILE RENDERER)
  Same logic as sidebar.tsx, wrapped in Sheet component
  Additionally auto-closes on link click

nav-group.tsx (GROUP RENDERER)
  Props: group, isExpanded, onToggle, pathname, filterVisible
  Renders: Collapsible header + flat list of Link items
  No sub-item concept currently exists

settings/page.tsx (CONFIG UI)
  Uses: useNavVisibility, useDetailViewMode
  Renders: Switch toggles for each nav item's visibility
  No drag-and-drop or ordering UI currently exists
```

### Data Flow: Sidebar Rendering

```
1. Page load:
   sidebar.tsx mounts
   -> useNavVisibility fetches GET /api/user/preferences
   -> useNavCollapseState reads localStorage
   -> visibleGroups computed: navGroups filtered by role and visibility
   -> Each NavGroupComponent renders with Collapsible + flat Links

2. Navigation:
   User clicks link -> Next.js client navigation -> pathname changes
   -> useEffect in sidebar.tsx calls autoReveal(pathname)
   -> autoReveal checks if pathname matches any hiddenItems href
   -> If match: removes from hiddenItems, PATCHes API
   -> lastRevealedRef prevents re-triggering for same pathname

3. Settings change:
   User toggles Switch on settings page
   -> toggleItem(href) updates hiddenItems state
   -> Fire-and-forget PATCH /api/user/preferences
   -> sidebar.tsx re-renders (shared hook state via separate instance)
   NOTE: Settings page and sidebar use SEPARATE instances of useNavVisibility
```

### Data Flow: Project Editing

```
1. Project list page (server-rendered):
   -> Prisma query fetches projects
   -> Passes to ProjectList client component
   -> canEdit(role) checks if user has ADMIN or EDITOR role
   -> No status-based restriction at component level

2. Project detail sheet (client-side):
   -> All form fields are always editable regardless of status
   -> handleSave PATCHes /api/projects/[id] with all fields
   -> API route has no status-based guard either

3. Project detail page (full page):
   -> Read-only display, Edit button links to /projects?open={id}
   -> Opens the detail sheet for editing

KEY FINDING: There is NO status-based read-only restriction in the
current codebase. The canEdit() function in permissions.ts only checks
user ROLE (ADMIN/EDITOR), not project STATUS. The "completed projects
editable" feature may already be satisfied, or the restriction exists
in a different form (e.g., just the UX expectation).
```

### Data Flow: Dashboard Revenue

```
1. Server-side data fetching (page.tsx):
   -> prisma.project.aggregate({ where: { status: 'COMPLETED' }, _sum: { revenue: true } })
   -> Only sums `revenue` field (actual from AI invoices)
   -> Only includes COMPLETED projects
   -> Does NOT include `potentialRevenue` at all

2. CRM KPI Cards:
   -> Receives totalRevenue from server
   -> Displays as "Revenue" with subtitle "Completed"

3. Revenue Target Widget:
   -> Separate data flow: queries KeyResult model for REVENUE metric type
   -> Shows KR target vs actual (not project revenue)
   -> Uses revenueKRs from /api/dashboard/stats route

BUG: Dashboard revenue calculation at line 183-186 of page.tsx:
  - Only sums `revenue` (actual from invoices)
  - Ignores `potentialRevenue` (from deal/potential conversion)
  - For projects with potentialRevenue but no actual revenue yet,
    their revenue contribution is zero on the dashboard
  - This underreports total revenue picture
```

### UserPreferences Schema

```prisma
model UserPreferences {
  id     String @id @default(cuid())
  userId String @unique @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  dashboardLayout Json?  @db.Json
  dateFilter      Json?  @db.Json
  detailViewMode  String @default("dialog") @map("detail_view_mode") @db.VarChar(20)
  hiddenNavItems  Json?  @map("hidden_nav_items") @db.Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

Current `hiddenNavItems` shape: `string[]` of hrefs (e.g., `["/timeline", "/events"]`)

### AdminDefaults Schema

```prisma
model AdminDefaults {
  id String @id @default(cuid())
  dashboardLayout Json @db.Json
  widgetRoles     Json @db.Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

---

## Feature-by-Feature Architecture Integration

### 1. Fix Sidebar autoReveal Bug

**Problem:** When a user hides a nav item (e.g., `/departments`) via Settings, then navigates within a page whose pathname starts with a visible item's href, the `autoReveal` logic incorrectly unhides the hidden item.

**Root cause analysis (lines 73-100 of `use-nav-visibility.ts`):**

```typescript
const autoReveal = useCallback(
  (pathname: string) => {
    if (isLoading) return
    if (lastRevealedRef.current === pathname) return  // <-- guard

    const matchedHref = hiddenItems.find((href) => {
      if (href === '/') return pathname === '/'
      return pathname === href || pathname.startsWith(href)  // <-- broad match
    })

    if (matchedHref) {
      lastRevealedRef.current = pathname  // <-- saves pathname, not href
      // ... unhides the item
    }
  },
  [hiddenItems, isLoading]
)
```

The `lastRevealedRef` guards against re-triggering for the **same pathname**, but different pathnames under the same href prefix can still trigger. For example:
- User hides `/companies`
- User visits `/companies/abc` -> autoReveal fires, unhides `/companies`
- But this is actually **correct** behavior (user typed URL directly)

**Actual bug scenario:** The bug is that clicking tabs or sub-navigation within a page that is already visible causes `pathname` to change (e.g., from `/companies` to `/companies?tab=contacts`), but `pathname` does NOT change in Next.js for query params. So the real bug is likely:
- The sidebar component re-renders when internal page navigation happens
- This causes useEffect to re-fire even though pathname hasn't changed
- The `hiddenItems` dependency in the `autoReveal` callback changes the callback identity

**Precise fix approach:**
1. Move `lastRevealedRef` to track the **href** that was auto-revealed, not the pathname
2. Or: Compare against a Set of already-revealed hrefs instead of a single pathname
3. Or: Only auto-reveal on actual browser navigation (external/URL-bar), not on internal Next.js navigation

**Files to modify:**
- `src/lib/hooks/use-nav-visibility.ts` - Fix autoReveal logic

**Component boundary:** Pure logic change in the hook. No rendering changes needed. Both sidebar.tsx and mobile-sidebar.tsx consume this hook and will automatically get the fix.

**Dependencies:** None. This is an isolated bug fix.

---

### 2. Nested Sidebar Links (Company -> Departments/Contacts)

**Current state:** All nav items are flat. The CRM group has Companies, Departments, Contacts as sibling items at the same level.

**Target state:** Company is a parent item with Departments and Contacts as expandable sub-items indented beneath it.

**Architecture approach:**

**Option A: Extend NavItem with optional `children` field**

```typescript
// nav-config.ts
export interface NavItem {
  name: string
  href: string
  icon: LucideIcon
  children?: NavItem[]  // NEW: optional sub-items
}
```

This is the cleanest approach because:
- Static config change, no runtime overhead
- navGroups structure stays the same
- Only nav-group.tsx rendering needs to handle depth
- Settings page toggle list naturally reflects hierarchy

**Option B: Create a separate NavSubGroup concept**

Over-engineered for one nesting level. Reject.

**Recommended: Option A.**

**nav-config.ts changes:**

```typescript
// CRM group becomes:
{
  key: 'crm',
  label: 'CRM',
  items: [
    { name: 'Companies', href: '/companies', icon: Building2, children: [
      { name: 'Departments', href: '/departments', icon: Building },
      { name: 'Contacts', href: '/contacts', icon: Contact },
    ]},
    { name: 'Pipeline', href: '/pipeline', icon: Funnel },
    // ... rest unchanged
  ],
},
```

**nav-group.tsx changes:**
- Render children as indented sub-links (pl-8 or pl-10)
- Support expand/collapse for parent items with children
- Parent item remains clickable (navigates to /companies)
- Chevron icon toggles children visibility
- Active state: parent OR any child matching pathname

**use-nav-visibility.ts changes:**
- `isVisible(href)` must handle children: if parent is hidden, children are hidden
- `toggleItem(href)` on a parent should hide/show children too (or treat independently)
- `autoReveal(pathname)` must check children hrefs too
- `getAllNavHrefs()` in nav-config must include children hrefs

**settings/page.tsx changes:**
- Render children as indented switches beneath parent
- When parent is toggled off, children switches become disabled/hidden

**sidebar.tsx and mobile-sidebar.tsx:**
- The `filterVisible` function passed to NavGroupComponent already handles visibility
- NavGroupComponent needs to render children; both sidebars consume it identically

**Files to modify:**
- `src/lib/nav-config.ts` - Add children to NavItem, restructure CRM group
- `src/components/layout/nav-group.tsx` - Render nested items with expand/collapse
- `src/lib/hooks/use-nav-visibility.ts` - Handle children in visibility checks
- `src/app/(dashboard)/settings/page.tsx` - Render hierarchical toggle list

**Dependencies:** Should be built AFTER autoReveal fix (feature 1) since both modify `use-nav-visibility.ts`.

---

### 3. Sidebar Drag-and-Drop Reordering

**Current state:** Nav item order is hardcoded in `nav-config.ts`. No reordering capability.

**Available tools:** `@dnd-kit/core@6.3.1` and `@dnd-kit/sortable@10.0.0` are already installed and used extensively in kanban boards.

**Architecture approach:**

**Data model for persisted order:**

Add `navItemOrder` to UserPreferences:

```typescript
// Shape: Record<groupKey, string[]> mapping group keys to ordered hrefs
// Example: { "crm": ["/pipeline", "/companies", "/projects", ...] }
navItemOrder?: Record<string, string[]>
```

**Schema change:**

```prisma
model UserPreferences {
  // ... existing fields
  navItemOrder    Json?  @map("nav_item_order") @db.Json  // NEW
}
```

**Runtime ordering logic:**

```typescript
// New function in nav-config.ts or a new hook
function getOrderedItems(group: NavGroup, customOrder?: string[]): NavItem[] {
  if (!customOrder) return group.items

  const orderMap = new Map(customOrder.map((href, i) => [href, i]))
  return [...group.items].sort((a, b) => {
    const aIdx = orderMap.get(a.href) ?? Infinity
    const bIdx = orderMap.get(b.href) ?? Infinity
    return aIdx - bIdx
  })
}
```

**Settings page DnD integration:**

The Settings page already renders nav items in a list. Add DnD using `@dnd-kit/sortable`:

```typescript
// Each nav group's item list becomes a SortableContext
// Each item gets a drag handle (GripVertical icon)
// On drag end: compute new order, save to preferences
```

**Sidebar rendering with custom order:**

Create a new hook `use-nav-order.ts` or extend `use-nav-visibility.ts`:

```typescript
// Fetches navItemOrder from preferences
// Provides getOrderedItems(group) function
// Sidebar and mobile-sidebar both consume this
```

**Component boundary:**

```
Settings page (DnD UI)
  -> PATCH /api/user/preferences { navItemOrder: { crm: [...], saap: [...] } }

Sidebar (both desktop and mobile)
  -> GET /api/user/preferences -> navItemOrder
  -> Apply order when rendering group items
  -> Falls back to nav-config.ts order if no custom order
```

**Files to modify:**
- `prisma/schema.prisma` - Add navItemOrder field to UserPreferences
- `src/app/api/user/preferences/route.ts` - Handle navItemOrder in GET/PATCH
- `src/lib/hooks/use-nav-visibility.ts` or new `use-nav-order.ts` - Order state management
- `src/app/(dashboard)/settings/page.tsx` - Add DnD reordering UI
- `src/components/layout/sidebar.tsx` - Apply custom order to rendered items
- `src/components/layout/mobile-sidebar.tsx` - Same ordering logic

**Dependencies:** Should be built AFTER nested nav (feature 2) because:
- Nested items need to be reorderable too
- The NavItem children must be excluded from DnD (children follow parent)
- Or children are independently reorderable within their parent

---

### 4. Completed Projects Editable

**Current state analysis:**

After thorough code review, there is **no status-based editing restriction** in the current codebase:

1. `src/lib/permissions.ts` - `canEdit(role)` checks ROLE only, not status
2. `src/components/projects/project-detail-sheet.tsx` - All form fields are always editable, no status check
3. `src/app/api/projects/[id]/route.ts` - PATCH handler has no status guard
4. `src/components/projects/project-list.tsx` - Uses `canEdit(role)` for role-based access only

**Possible interpretation:** The requirement may stem from:
- A planned restriction that was never implemented
- A UX perception issue (completed projects "feel" final)
- A restriction in the project card that prevents opening the detail sheet

Let me verify the project card:

The ProjectCard component and list render the same Edit button regardless of status. The detail sheet opens for any project.

**Conclusion:** This feature may be a no-op if the restriction doesn't actually exist. The roadmap should include a verification step. If it turns out there IS a restriction (perhaps in a recent commit not yet reviewed), the fix is:

**If restriction exists in API:**
- `src/app/api/projects/[id]/route.ts` - Remove `status !== 'COMPLETED'` guard from PATCH handler

**If restriction exists in UI:**
- Remove `disabled` or `readOnly` props conditioned on `project.status === 'COMPLETED'`

**If it's a UX change needed:**
- Add a visual indicator that completed projects CAN be edited (e.g., no greyed-out styling)

**Files potentially modified:**
- `src/app/api/projects/[id]/route.ts` - Remove status guard if present
- `src/components/projects/project-detail-sheet.tsx` - Remove disabled state if present
- `src/components/projects/project-card.tsx` - Ensure edit action is always available

**Dependencies:** None. Completely independent feature.

---

### 5. Internal Project Field Visibility Config

**Current state:** Internal projects (isInternal=true) show different fields than client projects. When `isInternal` is true:
- Company select is hidden, Entity select is shown
- Contact select is hidden
- InternalEntity field is shown

There is no admin-configurable way to control which fields are visible for internal projects.

**Architecture approach:**

**Config model:**

Add a field visibility config to AdminDefaults (admin-controlled, system-wide):

```typescript
// Shape: Record<fieldName, boolean>
// Example: { description: true, startDate: true, initiative: false, contact: false }
internalFieldVisibility?: Record<string, boolean>
```

**Schema change:**

```prisma
model AdminDefaults {
  // ... existing fields
  internalFieldVisibility Json? @map("internal_field_visibility") @db.Json  // NEW
}
```

**OR** add to UserPreferences if per-user control is desired. Given the requirement says "admin controls," AdminDefaults is correct.

**Admin settings UI:**

Add a new card on the admin settings page (or create one if it doesn't exist as a standalone page):

```
Settings page > new "Internal Project Fields" card (admin-only)
  -> List of field toggles: Description, Start Date, End Date, Initiative Link, Revenue, etc.
  -> Toggle on/off determines if field is shown for internal projects
  -> Saves to AdminDefaults.internalFieldVisibility
```

**Consuming components:**

1. `src/components/projects/project-detail-sheet.tsx` - Conditionally render fields based on config
2. `src/components/projects/project-form-modal.tsx` - Same conditional rendering
3. `src/app/(dashboard)/projects/[id]/project-detail-page-client.tsx` - Same for read-only view

**Data flow:**

```
Admin Settings page
  -> PATCH /api/admin/field-visibility { internalFieldVisibility: {...} }
  -> Stores in AdminDefaults model

Project form/detail components
  -> Fetch field visibility config (new API or include in existing data flow)
  -> Conditionally render fields: if (project.isInternal && !config[fieldName]) hide field
```

**Implementation options:**

**Option A: Fetch config client-side (separate API call)**
- New hook: `useFieldVisibility()` that fetches from `/api/admin/field-visibility`
- Each component conditionally renders fields
- Simple but adds another API call on every project view

**Option B: Include config in server-rendered page props**
- Server component fetches AdminDefaults and passes to client
- No additional API call
- Better performance, follows existing pattern

**Recommended: Option B.** Match the existing pattern where server components fetch data and pass as props.

**Files to modify:**
- `prisma/schema.prisma` - Add internalFieldVisibility to AdminDefaults
- `src/app/api/admin/field-visibility/route.ts` - NEW: GET/PATCH for config
- `src/app/(dashboard)/settings/page.tsx` - Add admin-only field visibility card
- `src/components/projects/project-detail-sheet.tsx` - Conditional field rendering
- `src/components/projects/project-form-modal.tsx` - Same
- `src/app/(dashboard)/projects/[id]/project-detail-page-client.tsx` - Same
- `src/app/(dashboard)/projects/[id]/page.tsx` - Fetch and pass config

**Dependencies:** Independent. Can be built in parallel with sidebar features.

---

### 6. Dashboard Revenue Includes potentialRevenue

**Current state (line 183-186 of page.tsx):**

```typescript
const revenueResult = await prisma.project.aggregate({
  where: { status: 'COMPLETED' },
  _sum: { revenue: true }
})
const totalRevenue = Number(revenueResult._sum.revenue) || 0
```

This only sums `revenue` (actual from AI invoice imports) for COMPLETED projects. Projects that have `potentialRevenue` set (from deal/potential conversion) but no actual `revenue` yet are counted as zero.

**Required fix:**

Use a combined revenue calculation that falls back to `potentialRevenue` when `revenue` is null:

```typescript
// Option A: Two aggregates (simple, clear)
const revenueResult = await prisma.project.aggregate({
  where: { status: 'COMPLETED' },
  _sum: { revenue: true, potentialRevenue: true }
})
const actualRevenue = Number(revenueResult._sum.revenue) || 0
const potentialRevenue = Number(revenueResult._sum.potentialRevenue) || 0

// For CRM KPI: show actual revenue where available, potential as fallback
// Need per-project logic, not just aggregate

// Option B: Fetch individual projects and compute (precise)
const completedProjects = await prisma.project.findMany({
  where: { status: 'COMPLETED' },
  select: { revenue: true, potentialRevenue: true }
})
const totalRevenue = completedProjects.reduce((sum, p) => {
  const rev = Number(p.revenue) || Number(p.potentialRevenue) || 0
  return sum + rev
}, 0)
```

**Recommended: Option B** because it matches the per-project logic used everywhere else in the app (e.g., `project-detail-page-client.tsx` line 140: `const revenue = project.revenue ?? project.potentialRevenue ?? 0`).

**Scope consideration:** Should this also include non-COMPLETED projects? The current filter is `status: 'COMPLETED'`. If potentialRevenue is being included, should ACTIVE projects with potentialRevenue also count? This is a product decision that should be confirmed. The safest initial change is to keep the COMPLETED filter but use `revenue ?? potentialRevenue` fallback.

**Files to modify:**
- `src/app/(dashboard)/page.tsx` - Fix the revenue aggregation in `getCRMData()` function (~line 183)
- Potentially `src/app/api/dashboard/stats/route.ts` if the Revenue Target widget should also reflect this

**Dependencies:** None. Completely independent, can be first or last.

---

## Component Boundaries Summary

| Component | Talks To | Modified By Features |
|-----------|----------|---------------------|
| `nav-config.ts` | sidebar, mobile-sidebar, settings, hooks | 2 (nested nav), 3 (ordering) |
| `use-nav-visibility.ts` | sidebar, mobile-sidebar, settings | 1 (autoReveal fix), 2 (children), 3 (ordering) |
| `use-nav-collapse-state.ts` | sidebar, mobile-sidebar | None (unchanged) |
| `nav-group.tsx` | sidebar, mobile-sidebar | 2 (nested rendering) |
| `sidebar.tsx` | nav-config, hooks, nav-group | 2 (nested), 3 (ordering) |
| `mobile-sidebar.tsx` | nav-config, hooks, nav-group | 2 (nested), 3 (ordering) |
| `settings/page.tsx` | nav-config, hooks | 2 (nested toggles), 3 (DnD reordering), 5 (field visibility) |
| `project-detail-sheet.tsx` | API routes, permissions | 4 (edit restrictions), 5 (field visibility) |
| `project-form-modal.tsx` | API routes | 5 (field visibility) |
| `page.tsx` (dashboard) | Prisma, CRM data | 6 (revenue fix) |
| `UserPreferences` model | preferences API | 3 (navItemOrder) |
| `AdminDefaults` model | admin API | 5 (internalFieldVisibility) |

---

## Suggested Build Order

```
Phase 1: Bug Fix (autoReveal)
  Files: use-nav-visibility.ts
  Risk: Low (isolated logic change)
  Dependency: None

Phase 2: Nested Sidebar Links
  Files: nav-config.ts, nav-group.tsx, use-nav-visibility.ts, settings/page.tsx
  Risk: Medium (structural change to NavItem, touches rendering)
  Dependency: Phase 1 (same file: use-nav-visibility.ts)

Phase 3: Drag-and-Drop Reordering
  Files: schema.prisma, preferences/route.ts, settings/page.tsx, sidebar.tsx, mobile-sidebar.tsx
  Risk: Medium (schema migration, DnD complexity, but @dnd-kit already proven in codebase)
  Dependency: Phase 2 (nav structure must be stable before adding ordering)

Phase 4: Completed Projects Editable
  Files: Verify first, then project API/components if needed
  Risk: Low (may be no-op)
  Dependency: None (can run in parallel with Phase 2-3)

Phase 5: Internal Project Field Visibility Config
  Files: schema.prisma, admin API, settings/page.tsx, project components
  Risk: Medium (new admin feature, conditional rendering across components)
  Dependency: None (independent)

Phase 6: Dashboard Revenue Fix
  Files: page.tsx (dashboard)
  Risk: Low (single query change)
  Dependency: None (can be first or last)
```

**Rationale for ordering:**
- Phases 1-3 are **sequentially dependent** (all touch sidebar subsystem, each builds on previous)
- Phases 4-6 are **independent** and can be interleaved or parallelized
- Phase 1 first because it's a bug fix (immediate value, minimal risk)
- Phase 6 could also be first (5-minute fix, immediate dashboard accuracy improvement)

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Shared Hook State Assumption

**What:** Assuming `useNavVisibility()` shares state between sidebar and settings page.
**Why bad:** Each component creates its own hook instance. If settings page toggles an item, sidebar's state doesn't update until next API fetch or page reload.
**Instead:** After settings changes, either:
- Use a React Context provider wrapping both sidebar and settings
- Use an event-based approach (BroadcastChannel, custom event)
- Accept the current behavior (sidebar refreshes on next page load)

**Current behavior:** The existing toggle works because settings changes are fire-and-forget PATCHes, and the sidebar re-fetches on mount. This is acceptable for 3 users.

### Anti-Pattern 2: Drag-and-Drop in Nav Groups Without Constraints

**What:** Allowing items to be dragged between groups (SAAP -> CRM).
**Why bad:** Groups have semantic meaning and role requirements. Cross-group dragging breaks the conceptual model.
**Instead:** Use `SortableContext` per group, not a single context for the entire sidebar.

### Anti-Pattern 3: Field Visibility as Component-Level Hardcoding

**What:** Adding `if (isInternal) { hideField('contact') }` directly in each component.
**Why bad:** Duplicated logic, impossible to change without code deployment.
**Instead:** Config-driven approach where AdminDefaults stores the visibility map and components read it.

### Anti-Pattern 4: Revenue Calculation Inconsistency

**What:** Using different revenue logic in dashboard vs. project detail.
**Why bad:** Dashboard shows one number, project detail shows another. Users lose trust.
**Instead:** Create a shared utility: `getEffectiveRevenue(project) => revenue ?? potentialRevenue ?? 0` and use it everywhere.

---

## Scalability Considerations

| Concern | Current (3 users) | At 20 users | Recommendation |
|---------|-------------------|-------------|----------------|
| Nav preferences API calls | Each sidebar mount = 1 GET | 20 GETs on each page load | Acceptable. Could cache in sessionStorage. |
| DnD order persistence | Per-user JSON in DB | 20 rows with JSON | Fine. JSON is small (~500 bytes). |
| Field visibility config | Single AdminDefaults row | Same | Fine. One row, read occasionally. |
| Revenue aggregation | One aggregate query | Same | Fine. Index on status exists. |

No scalability concerns for this milestone's features at the expected user count.

---

## Key Architecture Decisions

### Decision 1: Extend NavItem vs. Create NavSubItem

**Chosen:** Extend NavItem with optional `children?: NavItem[]`
**Rationale:** One nesting level is sufficient. Keeps the type system simple. New renderers can check `item.children?.length` to decide rendering strategy.

### Decision 2: Nav order in UserPreferences vs. separate model

**Chosen:** UserPreferences.navItemOrder (Json)
**Rationale:** Follows the established pattern where all user-specific sidebar config lives in UserPreferences. hiddenNavItems is already there. Adding navItemOrder keeps them co-located.

### Decision 3: Field visibility in AdminDefaults vs. UserPreferences

**Chosen:** AdminDefaults.internalFieldVisibility
**Rationale:** The requirement says "admin controls which fields show." This is a system-wide setting, not per-user. AdminDefaults already exists for system-wide dashboard config.

### Decision 4: Revenue fix scope (COMPLETED only vs. all statuses)

**Chosen:** Keep COMPLETED filter, use `revenue ?? potentialRevenue` fallback
**Rationale:** Including ACTIVE projects' potentialRevenue in the dashboard total would conflate "earned" with "expected." The current COMPLETED filter represents realized business. The fix just ensures potentialRevenue is counted when actual revenue hasn't been extracted yet.

---

## Sources

All findings based on direct codebase analysis of:
- `src/lib/nav-config.ts` (129 lines)
- `src/components/layout/sidebar.tsx` (115 lines)
- `src/components/layout/mobile-sidebar.tsx` (125 lines)
- `src/components/layout/nav-group.tsx` (83 lines)
- `src/lib/hooks/use-nav-visibility.ts` (103 lines)
- `src/lib/hooks/use-nav-collapse-state.ts` (67 lines)
- `src/app/(dashboard)/settings/page.tsx` (193 lines)
- `src/app/api/user/preferences/route.ts` (78 lines)
- `src/lib/permissions.ts` (17 lines)
- `src/components/projects/project-detail-sheet.tsx` (1453 lines)
- `src/components/projects/project-form-modal.tsx` (332 lines)
- `src/app/(dashboard)/projects/[id]/project-detail-page-client.tsx` (862 lines)
- `src/app/(dashboard)/page.tsx` (lines 170-248 - revenue aggregation)
- `src/components/dashboard/revenue-target.tsx` (83 lines)
- `src/components/dashboard/crm-kpi-cards.tsx` (86 lines)
- `src/lib/widgets/registry.ts` (104 lines)
- `prisma/schema.prisma` (901 lines)
- `package.json` (@dnd-kit versions confirmed)
- `src/components/kanban/kanban-board.tsx` (DnD usage pattern reference)
