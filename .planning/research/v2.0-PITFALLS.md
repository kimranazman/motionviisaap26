# Domain Pitfalls: v2.0 OKR Restructure, Support Tasks & Seed Migration

**Domain:** OKR data model restructure in an existing Next.js/Prisma/MariaDB application
**Researched:** 2026-01-27
**Overall confidence:** HIGH (based on direct codebase analysis + verified Prisma/MariaDB documentation)

---

## Critical Pitfalls

Mistakes that cause data loss, broken migrations, or application-wide breakage.

---

### Pitfall C1: String-to-FK Migration Leaves 22 Files with Stale `keyResult` References

**Severity:** CRITICAL
**Phase:** Schema migration + Frontend refactor
**What goes wrong:** The `keyResult` field on `Initiative` is currently a `String @db.VarChar(20)` used as a plain text value across 22 source files. Promoting it to a `KeyResult` model with a FK (`keyResultId`) means every file that references `initiative.keyResult` as a string will break simultaneously. The breakage is not just the field name -- the *shape* of the data changes (string "KR1.1" becomes an object `{ id, code, description, ... }`).

**Why it happens:** The existing code treats `keyResult` as a groupable, displayable string everywhere:
- `initiative-group-utils.ts`: Groups by `initiative.keyResult` string, calls `normalizeKeyResult()` which does `.trim().toUpperCase().replace(/\s+/g, '')`
- `objective-hierarchy.tsx`: Uses `keyResult` string in expand/collapse Set keys (`g.objective + ':' + kr.keyResult`)
- `initiative-form.tsx`: Has a plain text `<Input>` for `keyResult` (line 128-134)
- `initiative-detail-sheet.tsx`: Displays `initiative.keyResult` in a Badge (line 350)
- `initiative-export-utils.ts`: Maps `initiative.keyResult` directly to Excel column (line 131)
- `kanban-board.tsx`: Builds filter list from `initiatives.map(i => i.keyResult)` (line 199)
- `kanban-filter-bar.tsx`: Iterates `keyResults` array of strings
- `calendar-view.tsx`: Uses `initiative.keyResult` in tooltip title (line 289)
- `gantt-chart.tsx`: Displays `initiative.keyResult` as label (line 195)
- All 5 page server components select `keyResult: true` from Prisma
- Both API routes (`POST`, `PUT`) write `body.keyResult` as a string

**Consequences:** If you change the schema without updating all 22 files simultaneously, the application will crash with TypeScript errors at build time and runtime errors for any dynamically typed paths. The objectives page (the primary OKR view) will break completely since it is the deepest consumer of the grouping logic.

**Detection (warning signs):**
- TypeScript build errors mentioning `keyResult` type mismatch
- Runtime "Cannot read property of undefined" on objectives page
- Kanban filter dropdown showing `[object Object]` instead of "KR1.1"
- Export XLSX showing `[object Object]` in Key Result column

**Prevention:**
1. **Introduce the `KeyResult` model with a `code` field** (e.g., `code: String @unique @db.VarChar(20)`) that preserves the current string representation.
2. **Keep a computed/virtual `keyResult` string accessible** -- when querying initiatives, include `keyResult: { select: { code: true } }` and flatten in the API response as `keyResult: initiative.keyResult.code`.
3. **Refactor in two passes:**
   - Pass 1: Add `KeyResult` model, add `keyResultId` FK on Initiative, seed KR records. Keep old `keyResult` string field temporarily.
   - Pass 2: Update all 22 consumer files to use the new relation. Remove old `keyResult` string field only after all consumers are migrated.
4. **Create a checklist of all 22 files** and check them off as refactored. The full list is documented below in Appendix A.

---

### Pitfall C2: Seed Script Wipe Deletes Comments, Projects, and Activity Logs via CASCADE

**Severity:** CRITICAL
**Phase:** Seed migration
**What goes wrong:** The current seed script does `await prisma.initiative.deleteMany()` (line 161 of `prisma/seed.ts`). The Initiative model has `comments Comment[]` with `onDelete: Cascade` and `projects Project[]` linked via `initiativeId`. Wiping initiatives will CASCADE-delete all comments. Projects have `initiativeId` as an optional FK, so those will be set to null (not deleted), but the link is lost.

More critically, when adding new models like `KeyResult` and `SupportTask` with FKs pointing to `Initiative`, the deletion order in the seed script must be carefully sequenced. If `SupportTask` has a FK to `KeyResult` which has a FK to `Initiative`, deleting `Initiative` first will fail unless cascades are properly configured or FK checks are disabled.

**Why it happens:** The seed script was written for a simpler schema (only initiatives + events). The v2.0 schema adds KeyResult, SupportTask, and SupportTaskKeyResult (join table) -- all interconnected. The naive `deleteMany()` approach breaks with circular or deep FK chains.

**Consequences:**
- Foreign key constraint errors crash the seed script
- If CASCADE is used broadly, unintended data deletion (e.g., all project-initiative links lost)
- Partial seed state: some tables wiped, others not, leaving orphaned records

**Detection:**
- Seed script throws `Foreign key constraint failed on the field: foreign key`
- After seeding, projects show "No linked initiative" even though they had one
- Comment counts drop to zero

**Prevention:**
1. **Use `SET FOREIGN_KEY_CHECKS = 0` for the wipe phase** in MariaDB:
   ```typescript
   await prisma.$executeRawUnsafe('SET FOREIGN_KEY_CHECKS = 0;');
   try {
     await prisma.supportTaskKeyResult.deleteMany();
     await prisma.supportTask.deleteMany();
     await prisma.keyResult.deleteMany();
     await prisma.initiative.deleteMany();
     await prisma.eventToAttend.deleteMany();
   } finally {
     await prisma.$executeRawUnsafe('SET FOREIGN_KEY_CHECKS = 1;');
   }
   ```
2. **Seed in dependency order** (parents first): Initiatives, then KeyResults, then SupportTasks, then join table.
3. **Back up production data before running** -- even on a NAS-hosted MariaDB, run `mysqldump` first.
4. **Never run `prisma migrate reset` or `prisma db push` on the production database** -- use `prisma migrate deploy` only.

---

### Pitfall C3: MariaDB Drift Detection Loop on Foreign Key Migrations

**Severity:** CRITICAL
**Phase:** Schema migration
**What goes wrong:** Prisma's migration engine has a known issue with MariaDB where it does not properly introspect foreign key metadata. This causes `prisma migrate dev` to generate redundant migration files that drop and recreate foreign keys on every run, creating an infinite migration loop. This is especially likely when adding multiple new FK relations (KeyResult, SupportTask).

**Why it happens:** MariaDB stores FK metadata differently from MySQL 8. Prisma's introspection engine may see the FKs as "different" on each run, generating new migrations that are functionally identical. This is documented in [prisma/prisma#11242](https://github.com/prisma/prisma/issues/11242) and [prisma/prisma#10900](https://github.com/prisma/prisma/issues/10900).

**Consequences:**
- Migration history becomes polluted with dozens of redundant migration files
- `prisma migrate deploy` in production applies unnecessary FK drop/recreate operations
- Risk of downtime during production deployment as FK constraints are temporarily removed

**Detection:**
- `prisma migrate dev` generates a new migration file even when no schema changes were made
- Migration SQL contains `DROP FOREIGN KEY` followed by `ADD CONSTRAINT` for the same FK
- Migration names like `20260127_add_key_result` followed by `20260128_add_key_result2` with identical content

**Prevention:**
1. **Use `--create-only` flag** with `prisma migrate dev` to generate migration SQL without applying it. Review the SQL before applying.
2. **After generating, run `prisma migrate dev` once more** -- if it generates another migration with only FK changes, use `prisma migrate resolve --applied <migration_name>` to mark it as applied and stop the loop.
3. **Batch all FK-adding changes into a single migration** rather than incremental ones. Add KeyResult model, SupportTask model, and the join table in one schema change.
4. **Test migration on a local MariaDB instance** (matching the Docker version on the Synology NAS) before deploying to production.

---

### Pitfall C4: Dropping KPI Columns Before Migrating KPI Logic to KeyResult Level

**Severity:** CRITICAL
**Phase:** Schema migration (field removal)
**What goes wrong:** Initiative currently has 5 KPI fields (`kpiLabel`, `kpiTarget`, `kpiActual`, `kpiUnit`, `kpiManualOverride`) used in 8 source files. These fields power the KPI Progress Bar in the objectives view, the KPI Tracking section in the initiative detail sheet, the export Excel columns, and the aggregated KPI totals in key-result group headers. Dropping these columns from the Initiative model before the replacement KR-level metrics are built and integrated means:
- The objectives page loses all KPI progress bars
- The initiative detail sheet loses the entire KPI Tracking section
- The export API loses 4 columns (KPI Label, Target, Actual, % Achievement)
- `initiative-kpi-utils.ts` (the entire file) becomes dead code that still gets imported

**Why it happens:** Prisma migration will generate `ALTER TABLE initiatives DROP COLUMN kpi_label, DROP COLUMN kpi_target, ...` the moment you remove these fields from the schema. There is no "soft deprecation" in Prisma -- the column is either in the schema or it is gone.

**Consequences:**
- Application crashes on any page that references `initiative.kpiLabel` (8 files)
- Build failure if TypeScript catches it; runtime failure if types are loose
- KPI historical data permanently lost (even if it was manually entered)
- `aggregateKpiTotals()` in key-result-group headers returns `hasData: false` for everything

**Detection:**
- TypeScript errors: `Property 'kpiLabel' does not exist on type 'Initiative'`
- Objectives page: KPI progress bars disappear, headers show no KPI data
- Export: missing columns in XLSX output

**Prevention:**
1. **Use the Expand and Contract pattern:**
   - Phase A (Expand): Add KR-level metrics fields to the new KeyResult model. Build KR-level KPI UI.
   - Phase B (Migrate): Copy/transform any needed KPI data from Initiative to KeyResult.
   - Phase C (Contract): Remove KPI fields from Initiative model. Remove old KPI UI code.
2. **Never remove fields and add replacements in the same migration.** Two separate migrations with a code deployment between them.
3. **Update the 8 consuming files** before dropping columns:
   - `src/lib/initiative-kpi-utils.ts` (entire file rewrite)
   - `src/lib/initiative-export-utils.ts` (lines 46-50, 72-75, 98-106, 139-145)
   - `src/components/objectives/key-result-group.tsx` (line 13, 39)
   - `src/components/objectives/initiative-row.tsx` (lines 14, 25-31)
   - `src/components/objectives/objective-hierarchy.tsx` (lines 24-29)
   - `src/components/kanban/initiative-detail-sheet.tsx` (lines 87-92, 144-154, 457-541)
   - `src/app/(dashboard)/objectives/page.tsx` (lines 27-31, 52-53)
   - `src/app/api/initiatives/[id]/route.ts` (lines 69-70, 155-173)

---

## High Pitfalls

Mistakes that cause significant rework or multi-day delays.

---

### Pitfall H1: Many-to-Many SupportTask-KeyResult Without Extra Fields (Wrong Relation Type)

**Severity:** HIGH
**Phase:** Schema design
**What goes wrong:** The Excel data has a `supports` column with values like "KR1.1, KR1.3" and "All KRs". This is a many-to-many relationship between SupportTask and KeyResult. Choosing Prisma's implicit many-to-many relation (no join model) seems simpler but prevents storing metadata on the link, and has API limitations: no `set` operation, no `connect` shorthand, no referential actions, and the auto-generated join table has no primary key.

**Why it happens:** Prisma's implicit M:N is seductively simple:
```prisma
model SupportTask {
  keyResults KeyResult[]
}
model KeyResult {
  supportTasks SupportTask[]
}
```
But this creates a `_KeyResultToSupportTask` table with no primary key (problematic for some cloud providers), no ability to customize referential actions, and a more limited Client API.

**Consequences:**
- Cannot add a `weight` or `priority` field to the SupportTask-KeyResult link later without migrating to explicit
- Cannot use `set` to replace all KR links for a SupportTask in one operation
- Join table name `_KeyResultToSupportTask` is ugly in database tools
- If you later need to track "how much does this task contribute to this KR", you need a full schema migration to add the join model

**Detection:**
- You realize you need metadata on the link (e.g., "primary vs. secondary support")
- Prisma Client API is more verbose than expected for disconnecting/reconnecting KRs
- Database inspection shows no PK on the join table

**Prevention:**
1. **Use explicit many-to-many with a join model** from the start:
   ```prisma
   model SupportTaskKeyResult {
     id            String      @id @default(cuid())
     supportTaskId String
     supportTask   SupportTask @relation(fields: [supportTaskId], references: [id], onDelete: Cascade)
     keyResultId   String
     keyResult     KeyResult   @relation(fields: [keyResultId], references: [id], onDelete: Cascade)

     @@unique([supportTaskId, keyResultId])
     @@map("support_task_key_results")
   }
   ```
2. This matches the existing pattern in the codebase (`TaskTag` join model at line 756-773 of schema).
3. The explicit model allows adding `contributionWeight` or `isPrimary` later without migration.

---

### Pitfall H2: "All KRs" Support Task Parsing Creates Fragile Coupling

**Severity:** HIGH
**Phase:** Seed script
**What goes wrong:** The Excel `supports` field has special values: "KR1.1, KR1.3" (specific KRs) and "All KRs" (all KRs under the parent objective). Parsing "All KRs" requires knowing which Objective the SupportTask belongs to, then finding all KeyResults for that Objective. If the seed script processes SupportTasks before all KeyResults are created, or if the Objective mapping is wrong, "All KRs" will link to the wrong set or an empty set.

**Why it happens:** "All KRs" is a relative reference that depends on context (the Objective). The seed script must:
1. Parse "KR1.1, KR1.3" into individual KR codes
2. For "All KRs", determine the Objective, then query all KR codes for that Objective
3. Look up each KR code to get its database ID
4. Create the join table records

Any of these steps can fail silently if the mapping is wrong.

**Consequences:**
- SupportTasks linked to wrong KeyResults (wrong Objective)
- "All KRs" links to 0 KRs because they haven't been created yet
- Partial links: some KRs found, others not, no error thrown

**Detection:**
- After seeding, SupportTask shows 0 linked KRs when it should show all
- Dashboard rollup shows wrong progress because tasks aren't linked
- Manual inspection reveals "All KRs" tasks are only linked to OBJ1 KRs, not OBJ2

**Prevention:**
1. **Seed in strict order:** Objectives (enum, already exists), then KeyResults, then Initiatives, then SupportTasks, then SupportTaskKeyResult links.
2. **Build a lookup map** of `code -> keyResultId` before processing SupportTasks:
   ```typescript
   const krMap = new Map<string, string>(); // "KR1.1" -> cuid
   const krsByObjective = new Map<string, string[]>(); // "OBJ1" -> ["KR1.1", "KR1.2", ...]
   ```
3. **For "All KRs", require the Objective to be specified** in the Excel or infer from the KR code prefix (KR1.x = OBJ1, KR2.x = OBJ2).
4. **Validate after seeding:** Query SupportTask with `_count` on keyResults and assert no task has 0 links.

---

### Pitfall H3: Grouping Logic Breaks When `keyResult` Changes from String to Relation

**Severity:** HIGH
**Phase:** Frontend refactor
**What goes wrong:** `initiative-group-utils.ts` is the core grouping engine. It takes `initiative.keyResult` as a string and groups by it using `normalizeKeyResult()`. When `keyResult` becomes a relation, the grouping function's input type changes. But the function is imported by `objective-hierarchy.tsx`, `objective-group.tsx`, and indirectly by the export route. All these callers must be updated to pass the correct shape.

The specific breaking change: `GroupedKeyResult.keyResult` is currently a `string` (line 21). After migration, it should still be a string (the KR code) for display, but the source changes from `initiative.keyResult` (direct) to `initiative.keyResult.code` (nested).

**Why it happens:** The grouping utility was designed for a flat string field. The refactor introduces one level of nesting that propagates through the entire objectives view hierarchy.

**Consequences:**
- Objectives page renders empty groups or crashes
- Key result headers show "undefined" instead of "KR1.1"
- Expand/collapse state breaks (keys contain `undefined`)

**Detection:**
- Objectives page shows "0 initiatives" under each KR
- Console error: `Cannot read properties of undefined (reading 'code')`
- Expand all/collapse all stops working

**Prevention:**
1. **Normalize at the API layer, not the component layer.** When fetching initiatives, flatten `keyResult.code` to `keyResultCode` in the API response. This keeps the grouping utility unchanged.
2. **Or update `InitiativeForGrouping` interface** to accept a `keyResultCode: string` and update callers.
3. **Write a unit test for `groupInitiativesByObjective`** before refactoring, using the current data shape, then update the test to use the new shape.

---

### Pitfall H4: Weight Fields Without Validation Allow Progress > 100% or Negative Progress

**Severity:** HIGH
**Phase:** Weight/priority rollup implementation
**What goes wrong:** Adding `weight` fields to KeyResult (for Objective rollup) and SupportTask (for KR rollup) enables weighted progress calculation. But without validation:
- Weights that don't sum to 1.0 (or 100) produce misleading progress
- A weight of 0 means a completed KR doesn't move the Objective
- Negative weights (data entry error) produce negative progress
- Adding/removing a KR doesn't automatically rebalance weights

The formula: `Objective Progress = SUM(KR_progress * KR_weight)`. If weights sum to 0.7 instead of 1.0, max achievable progress is 70%.

**Why it happens:** OKR tools like Profit.co and Lattice have learned this lesson -- they prompt for weight rebalancing when KRs change. A custom implementation often skips this validation initially.

**Consequences:**
- Dashboard shows Objective at 70% when all KRs are 100% (weights don't sum to 1.0)
- A completed KR with weight=0 shows no progress contribution
- Stakeholders lose trust in the progress dashboard

**Detection:**
- Objective progress never reaches 100% despite all KRs complete
- Progress percentage exceeds 100% (weights sum > 1.0)
- Progress shows negative values

**Prevention:**
1. **Enforce weight sum validation** at the API level: when saving weights, verify `SUM(weights for this Objective) = 1.0` (or 100).
2. **Default to equal weights** when no custom weights are set: `weight = 1.0 / count(KRs)`.
3. **Add a `rebalanceWeights()` utility** that auto-adjusts when KRs are added/removed.
4. **Clamp progress to 0-100%** in display, even if raw calculation produces out-of-range values.
5. **Consider starting with equal weights only** (no custom weights) for v2.0 MVP, add custom weights in a later phase.

---

### Pitfall H5: `prisma migrate dev` vs `prisma migrate deploy` Confusion on Production NAS

**Severity:** HIGH
**Phase:** Deployment
**What goes wrong:** The production database is on a Synology NAS running MariaDB via Docker. Running `prisma migrate dev` on this database (even accidentally, via SSH or wrong `.env`) will prompt for a database reset, which would wipe all production data. `prisma migrate dev` is designed for development only and will detect drift, prompt for resets, and run seed scripts.

**Why it happens:** Both commands are `prisma migrate ...` and developers sometimes copy-paste the wrong one. The `.env` file might point to production if not careful.

**Consequences:**
- Complete production data loss (all projects, costs, documents, comments, activity logs)
- Recovery requires database backup restore
- If no backup exists, data is permanently lost

**Detection:**
- Command output shows "Are you sure you want to reset your database?" -- but this may be auto-confirmed in scripts
- After running, all tables are empty
- Users report all data missing

**Prevention:**
1. **Use separate `.env` files:** `.env.development` and `.env.production`. Never have `DATABASE_URL` pointing to production in the default `.env`.
2. **Add a safety check in the seed script:** Before wiping, check if the database has more than N records. If yes, prompt for confirmation or abort.
3. **Only use `prisma migrate deploy`** in production. This applies pending migrations without prompting for resets or running seeds.
4. **Document the deployment process** explicitly: "For production: `npx prisma migrate deploy` ONLY."
5. **Create a MariaDB backup script** that runs before any deployment: `mysqldump -u user -p saap2026 > backup_$(date +%Y%m%d).sql`.

---

## Moderate Pitfalls

Mistakes that cause days of rework or subtle bugs.

---

### Pitfall M1: Quarterly Deadlines (Q4 2026) Stored as Exact Dates Lose Context

**Severity:** MEDIUM
**Phase:** Schema design
**What goes wrong:** Key Results often have quarterly deadlines like "Q4 2026" or "By end of Q3". Storing these as exact DateTime (`2026-12-31T23:59:59Z`) loses the quarterly context. The UI then shows "Dec 31, 2026" instead of "Q4 2026", which confuses users who think in quarters.

**Why it happens:** The existing Initiative model uses `startDate DateTime` and `endDate DateTime` (exact dates). It's natural to do the same for KeyResult deadlines. But KR deadlines are conceptually different -- they represent time horizons, not precise dates.

**Consequences:**
- UI shows "Dec 31, 2026" instead of "Q4 2026" -- users find this misleading
- Date comparisons (is this KR overdue?) work correctly but display is wrong
- Cannot group/filter by quarter without reverse-computing from the date

**Prevention:**
1. **Store both:** Add `quarter` as a `String?` (e.g., "Q4 2026") alongside `deadline DateTime?`. Use `quarter` for display, `deadline` for calculations.
2. **Or use an enum:** `enum Quarter { Q1_2026, Q2_2026, Q3_2026, Q4_2026 }` with helper functions to convert to date ranges.
3. **The simplest approach for v2.0:** Store `deadline DateTime` and add a `quarterLabel String? @db.VarChar(10)` for display. Compute quarter from date if label is missing.

---

### Pitfall M2: ObjectiveGroup KPI Aggregation Hardcoded to Initiative-Level KPIs

**Severity:** MEDIUM
**Phase:** Frontend refactor
**What goes wrong:** `key-result-group.tsx` imports `aggregateKpiTotals` from `initiative-kpi-utils.ts` and calls it with `keyResult.initiatives` (line 39). This function iterates each initiative's `kpiLabel`, `kpiTarget`, `kpiActual`, `kpiUnit`, and `kpiManualOverride` fields. When KPI fields move to the KeyResult model, this aggregation function becomes meaningless -- it's aggregating fields that no longer exist on initiatives.

But the replacement is fundamentally different: instead of aggregating *initiative-level* KPIs, the header should show the *KeyResult-level* metrics directly (each KR has its own target/actual/progress). The aggregation function is no longer needed -- it should be replaced by direct KR metric display.

**Why it happens:** The current architecture pushes KPI data down to initiatives and then re-aggregates it at the KR level. The v2.0 architecture moves KPI data to the KR level, eliminating the need for aggregation.

**Consequences:**
- KR headers show "No data" or stale values
- `aggregateKpiTotals()` throws because input objects lack required fields

**Prevention:**
1. **Replace `aggregateKpiTotals()` with `getKeyResultProgress()`** that reads from the KR model directly.
2. **Update `key-result-group.tsx`** to receive KR-level metrics in its props instead of computing from child initiatives.
3. **Delete `aggregateKpiTotals()`** from `initiative-kpi-utils.ts` or deprecate the file entirely.

---

### Pitfall M3: Export API Column Layout Breaks When KR Becomes a Relation

**Severity:** MEDIUM
**Phase:** Export refactor
**What goes wrong:** `initiative-export-utils.ts` has a hardcoded column list (`EXPORT_COLUMNS`, line 61-82) that includes `keyResult` as column 3. The `mapInitiativeToExportRow` function (line 131) maps `initiative.keyResult` directly to the "Key Result" column. After the FK migration, `initiative.keyResult` is no longer a string -- it's a relation object.

Additionally, the export currently includes KPI columns (KPI Label, KPI Target, KPI Actual, % Achievement) at positions 11-14. When KPI moves to the KR level, these columns either need to be removed or reworked to show KR-level metrics.

**Why it happens:** The export utils are tightly coupled to the flat Initiative model shape. Any structural change to Initiative's fields breaks the export.

**Consequences:**
- Export produces `[object Object]` in Key Result column
- KPI columns show `undefined` or `null` for all rows
- Users downloading XLSX reports get corrupted data

**Prevention:**
1. **Update the Prisma query in `export/route.ts`** to include `keyResult: { select: { code: true } }`.
2. **Update `mapInitiativeToExportRow`** to use `initiative.keyResult.code` (or flatten in API layer).
3. **Decide on export KPI strategy:** Either remove KPI columns from Initiative export and create a separate KR export, or include KR metrics as Initiative-level columns (denormalized).

---

### Pitfall M4: Enum Changes in Objective Without Matching KeyResult Mapping

**Severity:** MEDIUM
**Phase:** Schema design
**What goes wrong:** The current `Objective` enum has two values: `OBJ1_SCALE_EVENTS` and `OBJ2_BUILD_AI_TRAINING`. KeyResults need to be associated with an Objective. If the v2.0 Excel introduces new objectives or changes existing ones, the Prisma enum must be updated. Prisma enum changes on MariaDB are non-trivial -- adding a value is fine, but renaming or removing requires a custom migration with raw SQL.

**Why it happens:** MariaDB stores enums as strings. Adding a new enum value is append-only and safe. But renaming `OBJ1_SCALE_EVENTS` to `OBJ1_SCALE_OPERATIONS` requires `ALTER TABLE ... MODIFY COLUMN ... ENUM(...)` which Prisma may not generate correctly.

**Consequences:**
- Existing data with old enum value becomes invalid
- Prisma migration may generate a table recreation (DROP + CREATE) for enum changes
- Seed script enum normalizer (`normalizeObjective()`) may not match new values

**Prevention:**
1. **Keep existing enum values unchanged.** If objectives change, add new values rather than modifying existing ones.
2. **If rename is necessary,** use `--create-only` and manually edit the migration SQL to use `ALTER TABLE ... MODIFY COLUMN`.
3. **Update `normalizeObjective()` in seed.ts** to handle any new Excel objective strings.
4. **Add `@@map` to new enum values** to decouple Prisma names from DB values.

---

### Pitfall M5: SupportTask Seed Parsing "KR1.1, KR1.3" with Inconsistent Delimiters

**Severity:** MEDIUM
**Phase:** Seed script
**What goes wrong:** The Excel `supports` field uses comma-separated KR codes. But Excel data is often inconsistent: "KR1.1, KR1.3" vs "KR1.1,KR1.3" vs "KR1.1 and KR1.3" vs "KR 1.1, KR 1.3". The existing `normalizeKeyResult()` function handles spacing variations but not delimiter variations.

**Why it happens:** Manual data entry in Excel introduces formatting inconsistencies. The seed script's parser must be robust against all variations.

**Consequences:**
- "KR1.1 and KR1.3" parsed as a single unknown KR code, linked to nothing
- "KR 1.1, KR 1.3" with extra spaces parsed correctly only if normalized
- Silent failures: SupportTask created with 0 KR links instead of 2

**Prevention:**
1. **Normalize aggressively:** Split on `,`, `and`, `;`, then trim and uppercase each part, then strip all spaces.
2. **Log warnings** for any KR code that doesn't match a known KeyResult after normalization.
3. **Validate after seeding:** Every SupportTask should have at least 1 KR link. Log any with 0.
4. **Consider a validation step** that prints "SupportTask X: parsed supports 'KR1.1, KR1.3' -> linked to [KR1.1, KR1.3]" for manual verification.

---

## Minor Pitfalls

Mistakes that cause annoyance but are easily fixable.

---

### Pitfall L1: Initiative Form `<Input>` for keyResult Becomes Stale After FK Migration

**Severity:** LOW
**Phase:** Frontend cleanup
**What goes wrong:** `initiative-form.tsx` (line 128-134) has a plain text `<Input>` for keyResult. After migration to FK, this needs to become a `<Select>` dropdown populated from the KeyResult table. If missed, users can type free-text KR codes that don't match any KeyResult record, causing FK constraint errors on save.

**Prevention:** Replace the `<Input>` with a `<Select>` populated from `GET /api/key-results`. Add the API endpoint if it doesn't exist.

---

### Pitfall L2: Kanban Swimlane View Uses `keyResult` String for Row Grouping

**Severity:** LOW
**Phase:** Frontend cleanup
**What goes wrong:** `kanban-swimlane-view.tsx` (line 12) defines `keyResult: string` on its item type and uses it for swimlane row headers (line 96). After FK migration, this displays incorrectly if the API returns the full relation object.

**Prevention:** Ensure API layer flattens `keyResult.code` to `keyResultCode` string before returning to the client. Or update the swimlane component to read from the nested property.

---

### Pitfall L3: Calendar Tooltip Uses `initiative.keyResult` for Display Text

**Severity:** LOW
**Phase:** Frontend cleanup
**What goes wrong:** `calendar-view.tsx` (line 289) uses `initiative.keyResult` in tooltip title string interpolation. After FK migration, this would show `[object Object]` in calendar tooltips.

**Prevention:** Update to `initiative.keyResult.code` or use the flattened API response field.

---

### Pitfall L4: Initiative `sequenceNumber` Auto-Increment May Conflict with Seed Data

**Severity:** LOW
**Phase:** Seed migration
**What goes wrong:** The current seed script manually assigns `sequenceNumber` starting from 1. The API POST route calculates next sequence from `MAX(sequenceNumber) + 1`. If the seed creates 37 initiatives (seq 1-37), then a user creates a new one (seq 38), then the seed runs again, it will try to create seq 1 again. But `sequenceNumber` has `@unique` constraint, causing a duplicate key error.

**Prevention:** The seed script already deletes all initiatives first, so this only matters if the seed is run while the app is also in use. Add a warning comment: "Do not seed while users are active."

---

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Severity | Mitigation |
|-------------|---------------|----------|------------|
| Schema: Add KeyResult model | C1 (22 files break), C3 (MariaDB drift) | CRITICAL | Use `--create-only`, batch FK changes, two-pass refactor |
| Schema: Add SupportTask + join table | H1 (wrong M:N type), H2 (All KRs parsing) | HIGH | Use explicit join model, strict seed ordering |
| Schema: Remove KPI fields from Initiative | C4 (8 files break, data loss) | CRITICAL | Expand-and-Contract pattern, two migrations |
| Schema: Add weight fields | H4 (invalid weights, progress > 100%) | HIGH | Validate sum = 1.0, default equal weights |
| Seed: Wipe and reseed | C2 (CASCADE deletes), H5 (wrong command) | CRITICAL | FK_CHECKS=0, separate .env, backup first |
| Frontend: Objectives page refactor | H3 (grouping breaks), M2 (KPI aggregation) | HIGH | Normalize at API layer, new KR progress function |
| Frontend: Form refactor | L1 (Input -> Select) | LOW | Replace Input with Select, add API endpoint |
| Frontend: Export refactor | M3 (column layout breaks) | MEDIUM | Update query + mapping, decide KPI column strategy |
| Deployment: Production NAS | H5 (migrate dev vs deploy) | HIGH | Only `migrate deploy`, backup first, separate .env |

---

## Appendix A: Complete File Impact List for keyResult String-to-FK Migration

All 22 files referencing `initiative.keyResult` as a string, grouped by change type:

**Schema/API (must change first):**
1. `prisma/schema.prisma` -- Add KeyResult model, change Initiative.keyResult to relation
2. `prisma/seed.ts` -- Add KR seeding, update Initiative creation to use keyResultId
3. `src/app/api/initiatives/route.ts` -- POST: `body.keyResult` -> `body.keyResultId`
4. `src/app/api/initiatives/[id]/route.ts` -- PUT: `body.keyResult` -> `body.keyResultId`; GET: include relation
5. `src/app/api/initiatives/export/route.ts` -- orderBy, select changes

**Utility/Logic (change second):**
6. `src/lib/initiative-group-utils.ts` -- `InitiativeForGrouping.keyResult`, `normalizeKeyResult()`, grouping logic
7. `src/lib/initiative-export-utils.ts` -- `InitiativeForExport.keyResult`, column mapping

**Page Server Components (change third):**
8. `src/app/(dashboard)/objectives/page.tsx` -- select, orderBy
9. `src/app/(dashboard)/kanban/page.tsx` -- select
10. `src/app/(dashboard)/calendar/page.tsx` -- select
11. `src/app/(dashboard)/timeline/page.tsx` -- select

**UI Components (change last):**
12. `src/components/objectives/objective-hierarchy.tsx` -- Initiative interface, expand state keys
13. `src/components/objectives/key-result-group.tsx` -- GroupedKeyResult prop type
14. `src/components/objectives/objective-group.tsx` -- key prop, expand key
15. `src/components/initiatives/initiative-form.tsx` -- Input -> Select, formData shape
16. `src/components/initiatives/initiatives-list.tsx` -- search filter, Badge display
17. `src/components/initiatives/initiative-detail.tsx` -- Badge display
18. `src/components/kanban/initiative-detail-sheet.tsx` -- Badge display, Initiative interface
19. `src/components/kanban/kanban-board.tsx` -- filter list, Initiative type
20. `src/components/kanban/kanban-filter-bar.tsx` -- keyResults prop
21. `src/components/kanban/kanban-card.tsx` -- display
22. `src/components/kanban/kanban-swimlane-view.tsx` -- swimlane row grouping
23. `src/components/timeline/gantt-chart.tsx` -- label display
24. `src/components/calendar/calendar-view.tsx` -- tooltip display

---

## Appendix B: Complete File Impact List for KPI Field Removal

All 8 files referencing Initiative KPI fields:

1. `src/lib/initiative-kpi-utils.ts` -- Entire file: `calculateKpi()`, `aggregateKpiTotals()`, types
2. `src/lib/initiative-export-utils.ts` -- `InitiativeForExport` type, KPI columns, row mapping
3. `src/components/objectives/key-result-group.tsx` -- `aggregateKpiTotals()` import + call
4. `src/components/objectives/initiative-row.tsx` -- `calculateKpi()` import + call, KpiProgressBar
5. `src/components/objectives/objective-hierarchy.tsx` -- Initiative interface KPI fields
6. `src/components/kanban/initiative-detail-sheet.tsx` -- KPI state, KPI Tracking section, save handler
7. `src/app/(dashboard)/objectives/page.tsx` -- Prisma select + serialization
8. `src/app/api/initiatives/[id]/route.ts` -- Prisma include + serialization, PATCH handler KPI fields

---

## Sources

- [Prisma Foreign Key Constraints on MariaDB (GitHub #13339)](https://github.com/prisma/prisma/issues/13339)
- [Prisma Migration Drift Detection (GitHub #11242)](https://github.com/prisma/prisma/issues/11242)
- [Prisma MariaDB Adapter Bug (GitHub #27598)](https://github.com/prisma/prisma/issues/27598)
- [Prisma FK Drop/Recreate Loop (GitHub #10900)](https://github.com/prisma/prisma/issues/10900)
- [Prisma Many-to-Many Relations Documentation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations)
- [Prisma Referential Actions Documentation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions)
- [Prisma Customizing Migrations Documentation](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations)
- [Common Data Loss Scenarios in Prisma Schema Changes](https://dev.to/vatul16/common-data-loss-scenarios-solutions-in-prisma-schema-changes-52id)
- [Prisma Seed Database in Production Discussion (#15890)](https://github.com/prisma/prisma/discussions/15890)
- [Prisma FK Disable Discussion (#8108)](https://github.com/prisma/prisma/issues/8108)
- [Profit.co: Key Result Weights](https://www.profit.co/blog/okr-university/key-result-weights/)
- [Lattice: Progress Calculation](https://help.lattice.com/hc/en-us/articles/360059451414-Understand-Progress-Calculation-in-Lattice)
- [PeopleForce: OKR Progress Calculation](https://help.peopleforce.io/en/articles/8498885-okr-progress-calculation)
- [Perdoo: Customize Progress Calculation](https://support.perdoo.com/en/articles/4898961-customize-how-progress-is-calculated-for-objectives)
